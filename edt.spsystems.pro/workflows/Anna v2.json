{
  "createdAt": "2025-05-30T19:15:49.406Z",
  "updatedAt": "2025-05-30T19:15:49.406Z",
  "id": "arciMIAEpl4MZzZR",
  "name": "Anna v2",
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Main Agent1').first().json.body.mapping.parseJson().system.conversations_id }}",
        "tableName": "core_chat_histories",
        "contextWindowLength": "={{ $('Main Agent1').first().json.body.mapping.parseJson().system.context_window }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        6080,
        1200
      ],
      "id": "8493f101-fd26-4e38-90eb-38c676bd5d14",
      "name": "Memory"
    },
    {
      "parameters": {
        "content": "",
        "height": 180,
        "width": 760,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        6040,
        1160
      ],
      "typeVersion": 1,
      "id": "354eb24b-8461-4933-ae79-682450c1f113",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "operation": "push",
        "list": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "messageData": "={{ JSON.stringify({\n    'content': $('Mapping').first().json.chatwoot.content,\n    'data_url': $('Mapping').first().json.chatwoot.data_url,\n    'timestamp': $now,\n    'message_id': $('Mapping').first().json.chatwoot.message_id\n}) }}",
        "tail": true
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1200,
        320
      ],
      "id": "975e6722-429c-43e6-a91b-cb410789de3e",
      "name": "Add to List"
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1400,
        320
      ],
      "id": "e8173650-3c48-4036-af17-9fbb62f6ef3a",
      "name": "Get List"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1800,
        120
      ],
      "id": "0ddacac3-14ff-4e11-bea2-2b2bb5bd00ec",
      "name": "No Operation"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"data\": {{ \n    (() => {\n      const sourceNodeName = $('Get Final List 2').isExecuted ? 'Get Final List 2' : $prevNode.name;\n      const data = $(sourceNodeName).first().json.data;\n      const uniqueIds = new Set();\n      const messages = [];\n\n      data.reduce((_, buffer) => {\n        const parsed = JSON.parse(buffer);\n        if (!uniqueIds.has(parsed.message_id)) {\n          uniqueIds.add(parsed.message_id);\n\n          let index = messages.findIndex(msg => msg.message_id > parsed.message_id);\n          if (index === -1) index = messages.length;\n          messages.splice(index, 0, parsed);\n        }\n      }, []);\n\n      return messages.reduce((acc, msg) => {\n        delete msg.message_id;\n        acc.push({ content: msg, loop_reset: true });\n        return acc;\n      }, []);\n\n    })()\n  }}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2200,
        420
      ],
      "id": "b636ba3f-6a58-48ae-89b6-ad9b91c36ef3",
      "name": "Parse JSON"
    },
    {
      "parameters": {
        "fieldToSplitOut": "data",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        0,
        960
      ],
      "id": "afc33911-33af-4e06-bd6c-f017c3374618",
      "name": "Split Itens"
    },
    {
      "parameters": {
        "options": {
          "reset": "={{ $json.loop_reset }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        200,
        960
      ],
      "id": "3362209b-8598-45c7-9912-981241cbf2ca",
      "name": "Loop"
    },
    {
      "parameters": {
        "url": "={{ $json.content.data_url }}",
        "options": {
          "batching": {
            "batch": {}
          },
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "=data{{ $runIndex }}"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        600,
        960
      ],
      "id": "37ff09d6-9294-42f2-8a1c-3c0a8c06bade",
      "name": "Download Media"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{\n  $binary.data?.fileExtension === 'oga' \n    ? 0 \n    : !$binary.data || ['png', 'jpg', 'jpeg'].includes($binary.data.fileExtension)\n      ? 1 \n      : $binary.data.fileExtension === 'pdf' \n        ? 2 \n        : 3\n}}"
      },
      "id": "42733564-72a2-4dc9-bda9-362dcdbde95e",
      "name": "Switch 02",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        800,
        960
      ]
    },
    {
      "parameters": {
        "content": "",
        "height": 540,
        "width": 3140,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -100,
        40
      ],
      "typeVersion": 1,
      "id": "98512a69-82dd-4cc1-980a-6116a44a320d",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "",
        "height": 1360,
        "width": 4220,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -140,
        20
      ],
      "typeVersion": 1,
      "id": "cf06cad9-c360-4fd4-a77e-7c800dada54d",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}"
      },
      "id": "bceba6fd-1a4b-46ff-b642-31290eec38f1",
      "name": "Reset List",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1600,
        960
      ],
      "notesInFlow": false
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1200,
        760
      ],
      "id": "b40f4cff-2ae0-4b5d-8744-a7ebee663890",
      "name": "Get Final List 2"
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2000,
        220
      ],
      "id": "0bd8523d-5b9b-4128-857a-6c275e7995e0",
      "name": "Get Final List 1"
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "=6"
      },
      "id": "346a13ae-74e3-483d-86ac-614a9725ddf5",
      "name": "Reset List 2",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2540,
        140
      ],
      "notesInFlow": false
    },
    {
      "parameters": {
        "amount": "={{ \n  $('Mapping').first().json.system.cooldown - $now.diffTo(\n    JSON.parse($('Get List').item.json.data.last()).timestamp,\n    'seconds'\n  )\n}}"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1800,
        320
      ],
      "id": "295d11e8-06bb-4c1f-b0c3-9d62af8e01d3",
      "name": "Cooldown",
      "webhookId": "816f562a-62f9-4197-b5da-004f01f371fe"
    },
    {
      "parameters": {
        "queue": "main-n8n",
        "options": {
          "acknowledge": "executionFinishesSuccessfully",
          "jsonParseBody": true,
          "onlyContent": true
        }
      },
      "type": "n8n-nodes-base.rabbitmqTrigger",
      "typeVersion": 1,
      "position": [
        0,
        220
      ],
      "id": "710ac2ed-a70d-4355-a8d9-6d9fcc8430dd",
      "name": "Consumer"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{ \n  $node[\"Get Final List 2\"].runIndex === 0\n    ? (\n        JSON.parse($('Get Final List 1').first().json.data.last()).timestamp ===\n        JSON.parse($('Get Final List 2').first().json.data.last()).timestamp\n      ) ? 1 : 0\n    : (\n          JSON.parse($('Get Final List 2').all(0, $runIndex - 0).first().json.data.last()).timestamp ===\n          JSON.parse($('Get Final List 2').all(0, $runIndex - 1).first().json.data.last()).timestamp\n      ) ? 1 : 0\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1400,
        860
      ],
      "id": "1a3fb85a-a6cd-49e8-b6f2-cb10a251a4fa",
      "name": "Switch 3"
    },
    {
      "parameters": {
        "model": "={{ $json.body.mapping.parseJson().system.model }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        3900,
        1860
      ],
      "id": "752e8bd4-58bd-4850-8e31-b39de82a4bad",
      "name": "OpenRouter"
    },
    {
      "parameters": {
        "content": "",
        "height": 380,
        "width": 2700,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        4160,
        760
      ],
      "id": "89fb3994-60e1-4ff3-a750-91e431379120",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "",
        "height": 640,
        "width": 2740,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        4140,
        740
      ],
      "typeVersion": 1,
      "id": "5882b1be-8ecb-45cd-b41f-29fcab2f2c23",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "content": "",
        "height": 740,
        "width": 4160,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -100,
        620
      ],
      "typeVersion": 1,
      "id": "f034a2b3-dda4-4a3f-893f-145eb419778d",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=DO $agents$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 \n    FROM ai_agents\n    WHERE account_id = {{ $json.body.account.id }}\n      AND {{ $json.body.inbox.id }} = ANY(string_to_array(inboxes_ids, ',')::int[])\n  ) THEN\n    RAISE EXCEPTION 'Nenhum AI Agent encontrado para a conta % e inbox %', {{ $json.body.account.id }}, {{ $json.body.inbox.id }};\n  END IF;\nEND $agents$;\nWITH\n-- 1) Seleciona o AI Agent associado à conta e à caixa de entrada\nselected_ai AS (\n    SELECT ai.*\n    FROM ai_agents ai\n    WHERE ai.account_id = {{ $json.body.account.id }}\n      AND {{ $json.body.inbox.id }} = ANY(string_to_array(ai.inboxes_ids, ',')::int[])\n    LIMIT 1\n),\n-- 2) Seleciona as variáveis globais (assume-se que seja um singleton)\nselected_gv AS (\n    SELECT *\n    FROM global_vars\n    LIMIT 1\n),\n-- 3) Faz o upsert do usuário: insere se não existir, caso contrário, ignora\nupsert_user AS (\n    INSERT INTO users (id, date_created, picture_url, username, phone, ai_agent)\n    SELECT {{ $json.body.sender.id }}, NOW(), '{{ $json.body.sender.avatar }}', '{{ $json.body.sender.name }}', '{{ $json.body.sender.phone_number }}', ai.id\n    FROM selected_ai ai\n    WHERE ai.id IS NOT NULL\n    ON CONFLICT (id) DO NOTHING\n    RETURNING *\n),\n-- 4) Seleciona o usuário (recém-inserido ou existente)\nfinal_user AS (\n    SELECT * FROM upsert_user\n    UNION\n    SELECT * FROM users\n    WHERE id = {{ $json.body.sender.id }}\n),\n-- 5) Cria uma nova conversa apenas se não existir nenhuma para esse usuário\nmaybe_new_conversation AS (\n    INSERT INTO conversations (id, user_id, date_created)\n    SELECT gen_random_uuid(), final_user.id, NOW()\n    FROM final_user\n    WHERE NOT EXISTS (\n        SELECT 1\n        FROM conversations\n        WHERE user_id = final_user.id\n    )\n    RETURNING *\n),\n-- 6) Seleciona a última conversa do usuário (nova ou existente)\nlast_conversation AS (\n    SELECT * FROM maybe_new_conversation\n    UNION\n    SELECT * FROM conversations\n    WHERE user_id = (SELECT id FROM final_user)\n    ORDER BY date_created DESC\n    LIMIT 1\n),\n-- 7) Seleciona os históricos de chat (simplificado)\nchat_histories AS (\n    SELECT ch.*\n    FROM core_chat_histories ch\n    JOIN last_conversation lc ON ch.session_id = lc.id\n    ORDER BY ch.date_created DESC\n    LIMIT (SELECT context_window FROM selected_ai)\n),\n-- 8) Seleciona os calendários (scheduling) associados ao usuário\nuser_calendars AS (\n    SELECT sch.*\n    FROM event_history_user sch\n    WHERE sch.user_id = (SELECT id FROM final_user)\n),\n-- 9) Seleciona os eventos do usuário a partir da data atual\nuser_events AS (\n    SELECT eh.*\n    FROM event_history eh\n    JOIN user_calendars uc ON eh.session_id = uc.id\n    WHERE eh.date >= CURRENT_DATE\n    ORDER BY eh.date ASC  -- Ordenando cronologicamente a partir de hoje\n)\n-- 10) Retorna os resultados no formato JSON\nSELECT\n    (SELECT row_to_json(ai) FROM selected_ai ai) AS ai_agents,\n    (SELECT row_to_json(gv) FROM selected_gv gv) AS global_vars,\n    (SELECT row_to_json(final_user) FROM final_user) AS users,\n    (SELECT row_to_json(last_conversation) FROM last_conversation) AS conversations,\n    (SELECT json_agg(row_to_json(ch)) FROM chat_histories ch) AS core_chat_histories,\n    (SELECT COALESCE(json_agg(evt), '[]'::json) FROM user_events evt) AS events;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        400,
        220
      ],
      "id": "31b1536d-5e77-4427-942a-e5a0e82a2416",
      "name": "Get Vars"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://{{ $('Mapping').item.json.system.stirling_pdf_service }}:8080/api/v1/convert/pdf/img",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-KEY",
              "value": "={{ $('Mapping').first().json.system.stirling_pdf_key }}"
            },
            {
              "name": "accept",
              "value": "*/*"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "imageFormat",
              "value": "jpg"
            },
            {
              "name": "singleOrMultiple",
              "value": "single"
            },
            {
              "name": "colorType",
              "value": "color"
            },
            {
              "name": "dpi",
              "value": "80"
            },
            {
              "parameterType": "formBinaryData",
              "name": "fileInput",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "20c86219-3d3a-43ea-855b-6c3743b187c2",
      "name": "Convert PDF",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1000,
        1060
      ],
      "notesInFlow": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/audio/transcriptions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $('Mapping').first().json.system.openai_key }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "whisper-1"
            },
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "3dde70dd-a0f7-4a4a-8906-76cf62eff774",
      "name": "Transcription",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1000,
        860
      ],
      "notesInFlow": true
    },
    {
      "parameters": {
        "content": "Fluxo de processamento principal",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "5aaf3300-b574-42eb-b40f-a976c3565be4",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "content": "Fluxo Core, responsável pelo processamento da AI",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        4240,
        720
      ],
      "id": "0563ed97-750e-44e7-90d2-a6cd3a7d3938",
      "name": "Sticky Note14"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Obtém o último item da tabela conversations com base no campo 'date_created'\nWITH last_conversation AS (\n    SELECT id \n    FROM conversations\n    WHERE user_id = {{ $('Mapping').first().json.chatwoot.contact_id }}\n    ORDER BY date_created DESC\n    LIMIT 1\n),\n\n-- Obtém os últimos dois registros da tabela core_chat_histories com base no session_id\nlast_two_chat_histories AS (\n    SELECT id \n    FROM core_chat_histories\n    WHERE session_id = (SELECT id FROM last_conversation)\n    ORDER BY id DESC\n    LIMIT 2\n)\n\n-- Deleta os últimos dois registros encontrados\nDELETE FROM core_chat_histories\nWHERE id IN (SELECT id FROM last_two_chat_histories);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1800,
        760
      ],
      "id": "de1662ed-0608-4a7a-a052-fe3557b586dd",
      "name": "Clear History",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "name": "restart_history",
        "description": "=Invoque essa tool para iniciar uma nova conversa para o user, assim ignorando o histórico passado. Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\n\n// Converte o mapeamento recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usuário é admin; caso contrário, retorna erro\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usuário não autorizado.\" });\n}\n\n/**\n * Função que espera pelo tempo especificado.\n * @param {number} ms - Milissegundos a aguardar.\n * @returns {Promise<void>}\n */\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Função para enviar a requisição para criar uma conversa no Directus.\n * Tenta até 3 vezes em caso de falha, com delay de 1 segundo entre as tentativas.\n * @returns {Promise<object>} - Objeto com sucesso ou erro.\n */\nasync function sendRequest() {\n  const url = `http://${mapping.system.directus_service}:8055/items/conversations`;\n  const data = {\n    user_id: mapping.chatwoot.contact_id,\n    date_created: new Date().toISOString()\n  };\n  const headers = {\n    Authorization: `Bearer ${mapping.system.directus_token}`,\n    'Content-Type': 'application/json'\n  };\n\n  let attempt = 0;\n  let lastError = null;\n\n  while (attempt < 3) {\n    try {\n      const response = await axios.post(url, data, { headers });\n      console.log(`Requisição realizada com sucesso na tentativa ${attempt + 1}.`);\n      return { success: true, data: response.data };\n    } catch (error) {\n      attempt++;\n      lastError = error;\n      console.error(`Tentativa ${attempt} falhou:`, error.response ? error.response.data : error.message);\n      if (attempt < 3) {\n        console.log(\"Aguardando 1 segundo antes da nova tentativa...\");\n        await delay(1000);\n      }\n    }\n  }\n  \n  return { success: false, error: lastError.response ? lastError.response.data : lastError.message };\n}\n\nreturn sendRequest().then(result => JSON.stringify(result));"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        6200,
        1200
      ],
      "id": "57d3d6b0-d9c9-47b6-babe-13c709158432",
      "name": "Restart History"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{\n  $json.content.data_url?.match(/\\.(oga|png|jpg|jpeg|txt|pdf)$/i) !== null \n  && !!$json.content.data_url \n    ? 0 \n    : !!$json.content.content \n      ? 1\n      : 2\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        400,
        1160
      ],
      "id": "bd8afb93-19b4-4263-b396-8a3de34b2d03",
      "name": "Switch 2"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{ \n  $('Add to List').item.json.chatwoot.message_id !==\n  JSON.parse($('Get List').item.json.data.first()).message_id\n    ? 0\n    : $now.minus($('Mapping').first().json.system.cooldown, 'seconds').diffTo(\n        JSON.parse($('Get List').item.json.data.last()).timestamp,\n        'seconds'\n      ) >= 0\n      ? 1\n      : 2\n}}\n\n\n\n"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1600,
        220
      ],
      "id": "c18a7854-f41f-45f0-a94f-22d0fd5dfa9a",
      "name": "Switch 1"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{\n  (\n    $('Mapping').first().json.chatwoot.channel !== 'WhatsApp Web Group' ||\n    (\n      $('Mapping').first().json.system.allow_whatsapp_groups === 'always_enabled' ||\n      (\n        $('Mapping').first().json.system.allow_whatsapp_groups === 'enabled_when_mentioned' &&\n        $('Mapping').first().json.system.agent_mentioned\n      )\n    )\n  )\n  &&\n  {\n    'pending_status': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact' &&\n      $('Mapping').first().json.chatwoot.conversation_status === 'pending',\n\n    'all_status': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact',\n\n    'not_assigned': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact' &&\n      !$('Mapping').first().json.chatwoot.assignee\n  }[$('Mapping').first().json.system.enabled_condition]\n    ? 1\n    : 0\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1000,
        220
      ],
      "id": "33adae75-9544-45fd-842a-63732ed494d8",
      "name": "Switch 0"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7cade77f-2498-4515-991a-cbe2d5ffe67a",
              "name": "content",
              "value": "={{\n  $json.content?.content \n  || $json.text \n  || (\n    $('Switch 2').item.json.content.data_url.endsWith('.txt') \n      ? $json.data + '\\n\\n' + $('Switch 2').item.json.content?.content \n      : null\n  )\n}}",
              "type": "string"
            },
            {
              "id": "e8da4202-58a2-4990-9e36-9a56f18c7263",
              "name": "loop_reset",
              "value": false,
              "type": "boolean"
            }
          ]
        },
        "includeOtherFields": true,
        "include": "selected",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1400,
        1160
      ],
      "id": "d5dc8c7f-d612-4277-a7e6-6972808ce41a",
      "name": "Keep Loop"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "core_chat_histories",
          "mode": "list",
          "cachedResultName": "core_chat_histories"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "date_created": "={{ $now }}",
            "session_id": "={{ $json.system.conversations_id }}",
            "message": "={{ JSON.parse(JSON.stringify({\n  \"type\": \"human\",\n  \"content\": $json.chatwoot.content,\n  \"user_name\": $json.chatwoot.user_name\n})) }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "message",
              "displayName": "message",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "date_created",
              "displayName": "date_created",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1200,
        120
      ],
      "id": "f3a45466-7002-42c8-8e07-6510f0382cfb",
      "name": "Update History"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\nconst mapping = $('Mapping').first().json;\nconst { system, chatwoot } = mapping;\n\nif (\n  system.allow_human_interruption &&\n  system.enabled_condition === 'pending_status' &&\n  chatwoot.sender_type === 'User' &&\n  chatwoot.conversation_status !== 'open'\n) {\n  const chatwootService = system.chatwoot_service;\n  return axios.post(\n    `http://${chatwootService}:3000/api/v1/accounts/${chatwoot.account_id}/conversations/${chatwoot.conversation_id}/toggle_status`,\n    { status: \"open\" },\n    { headers: { api_access_token: chatwoot.bot_token } }\n  )\n  .then(res => [{ json: res.data }])\n  .catch(err => [{ json: { error: err.response?.data || err.message } }]);\n}\n\nreturn [{ json: { message: \"Nenhuma ação realizada\" } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        120
      ],
      "id": "35716a94-d455-481f-89c9-bba3a4083de1",
      "name": "Open Conversation"
    },
    {
      "parameters": {
        "name": "set_timer",
        "description": "Invoque essa tool para configurar um timer que iniciará uma ação após o tempo especificado. Apenas usuários admin podem usar essa tool. O tempo deve ser informado com valor e unidade (s, m, h). Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\nconst dayjs = require('dayjs');\nconst duration = require('dayjs/plugin/duration');\ndayjs.extend(duration);\n\n/**\n * Esta tool configura um timer via webhook.\n * Ela envia, para o endpoint, todo o objeto mapping (obtido em Core Input)\n * e o tempo em segundos calculado a partir dos parâmetros \"timer_value\" e \"timer_unit\".\n * Apenas usuários admin podem utilizar esta tool.\n */\n\n// Converte o mapping recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usuário é admin\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usuário não autorizado.\" });\n}\n\n// Obtém os parâmetros do timer a partir do input (query)\nconst timerValue = query.timer_value;  // Número (ex: 30)\nconst timerUnit = query.timer_unit;      // \"s\", \"m\" ou \"h\"\n\n// Calcula o tempo em segundos usando dayjs.duration\nconst timerSeconds = dayjs.duration(timerValue, timerUnit).asSeconds();\n\n// Prepara o payload para o webhook\nconst payload = {\n  mapping: mapping,\n  timer_seconds: timerSeconds\n};\n\n// URL do webhook substituindo 'n8n_webhook' pelo valor da variável no mapping\nconst url = `http://${mapping.system.n8n_webhook_service}:5678/webhook/timer`;\n\n/**\n * Função para enviar a requisição ao webhook.\n * Tenta enviar uma única vez e retorna o resultado.\n */\nasync function sendTimerRequest() {\n  try {\n    console.log(`Enviando requisição para configurar o timer para ${timerSeconds} segundos...`);\n    const response = await axios.post(url, payload, {\n      headers: { 'Content-Type': 'application/json' }\n    });\n    console.log(\"Timer configurado com sucesso.\");\n    return { success: true, message: `Timer configurado com sucesso. Ele será acionado em ${timerSeconds} segundos.` };\n  } catch (error) {\n    console.error(\"Erro ao configurar o timer:\", error.response ? error.response.data : error.message);\n    return { success: false, error: error.response ? error.response.data : error.message };\n  }\n}\n\nreturn sendTimerRequest().then(result => JSON.stringify(result));",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"timer_value\": {\n      \"type\": \"number\",\n      \"description\": \"Valor do timer. Exemplo: 30\"\n    },\n    \"timer_unit\": {\n      \"type\": \"string\",\n      \"description\": \"Unidade de tempo para o timer: 's' para segundos, 'm' para minutos, 'h' para horas.\",\n      \"enum\": [\"s\", \"m\", \"h\"]\n    }\n  },\n  \"required\": [\"timer_value\", \"timer_unit\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        6320,
        1200
      ],
      "id": "0ddbb3a6-d2a3-47a5-a88b-b13721816f28",
      "name": "Set Timer"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "tableName": {
          "__rl": true,
          "value": "knowledge",
          "mode": "list",
          "cachedResultName": "knowledge"
        },
        "additionalFields": {},
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTrigger",
      "typeVersion": 1,
      "position": [
        -20,
        1520
      ],
      "id": "a70767b9-0aba-414e-980f-17c1400f2a2b",
      "name": "Knowledge Trigger"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  k.*,\n  n.value AS namespace,\n  ph.value AS pinecone_host,\n  (\n    SELECT json_agg(ku.url)\n    FROM knowledge_urls ku\n    WHERE ku.knowledge_id = k.id\n  ) AS urls,\n  (\n    SELECT json_agg(kf.directus_files_id)\n    FROM knowledge_files kf\n    WHERE kf.knowledge_id = k.id\n  ) AS files_id,\n  (\n    SELECT row_to_json(gv)\n    FROM global_vars gv\n    LIMIT 1\n  ) AS global_vars\nFROM knowledge k\nLEFT JOIN namespace n ON n.id = k.name_id\nLEFT JOIN pinecone_host ph ON ph.id = k.pinecone_host_id\nWHERE k.id = {{ $('Knowledge Trigger').first().json.payload.id }};\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        180,
        1520
      ],
      "id": "eedcb31b-079a-4498-b0ba-e0ac72aaa504",
      "name": "Get Global Vars"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\n// Delay configurável\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Executa requisição GET com retry, usando parâmetros configuráveis.\nasync function axiosGetWithRetry(url, config, maxAttempts = 3, delayMs = 1000) {\n  let attempt = 1;\n  while (attempt <= maxAttempts) {\n    try {\n      return await axios.get(url, config);\n    } catch (err) {\n      console.error(`Tentativa ${attempt} para ${url} falhou:`, {\n        message: err.message,\n        status: err.response?.status,\n        data: err.response?.data,\n      });\n      if (attempt === maxAttempts) throw err;\n      attempt++;\n      await delay(delayMs);\n    }\n  }\n}\n\n// Prompt para gerar resumo de um bloco de texto\nconst SUMMARY_PROMPT = `Analise o texto a seguir e elabore um resumo conciso e direto, destacando os principais tópicos e informações essenciais. Esse resumo servirá de base para compor a descrição geral do documento.\n\nTexto:\n{conteudo}\n\nResumo:`;\n\n// Prompt para criar a descrição diretamente a partir do texto completo\nconst DIRECT_DESCRIPTION_PROMPT = `Analise o texto a seguir e crie uma descrição clara e objetiva do conteúdo geral do documento. A resposta deve ser um único parágrafo conciso de texto simples, sem formatação, com aproximadamente 300 caracteres.\n\nTexto:\n{conteudo}\n\nDescrição:`;\n\n// Prompt para gerar a descrição final a partir dos resumos\nconst FINAL_DESCRIPTION_PROMPT = `Com base nos resumos a seguir, elabore uma descrição clara e objetiva do conteúdo geral do documento. A resposta deve ser um único parágrafo conciso de texto simples, sem formatação, com aproximadamente 300 caracteres.\n\nResumos:\n{conteudo}\n\nDescrição:`;\n\n// Cria chunks de forma orgânica, sem misturar conteúdos de diferentes scrapings\nfunction createChunks(text, chunkLength, overlapPercentage) {\n  const overlapLength = Math.floor(chunkLength * (overlapPercentage / 100));\n  const chunks = [];\n  let currentPos = 0;\n  while (currentPos < text.length) {\n    let endPos = currentPos + chunkLength;\n    if (endPos >= text.length) {\n      endPos = text.length;\n    } else {\n      const searchStart = Math.max(currentPos, endPos - 100);\n      let breakPos = -1;\n      let pos = text.lastIndexOf(\"\\n\\n\", endPos);\n      if (pos >= searchStart) {\n        breakPos = pos + 2;\n      } else {\n        pos = text.lastIndexOf(\"\\n\", endPos);\n        if (pos >= searchStart) {\n          breakPos = pos + 1;\n        } else {\n          pos = text.lastIndexOf(\".\", endPos);\n          if (pos >= searchStart) {\n            breakPos = pos + 1;\n          } else {\n            pos = text.lastIndexOf(\"?\", endPos);\n            if (pos >= searchStart) {\n              breakPos = pos + 1;\n            } else {\n              pos = text.lastIndexOf(\"!\", endPos);\n              if (pos >= searchStart) {\n                breakPos = pos + 1;\n              }\n            }\n          }\n        }\n      }\n      if (breakPos > currentPos) {\n        endPos = breakPos;\n      }\n    }\n    const chunk = text.substring(currentPos, endPos).trim();\n    if (chunk.length > 0) chunks.push(chunk);\n    if (endPos === text.length) break;\n    currentPos = endPos - overlapLength;\n    if (currentPos < 0) currentPos = 0;\n  }\n  return chunks;\n}\n\n// Função para atualizar o campo \"description\" da tabela \"knowledge\" no Directus\nasync function updateDirectusDescription(newDescription, globalVars, globalId) {\n  const patchUrl = `http://${globalVars.directus_service}:8055/items/knowledge/${globalId}`;\n  const patchPayload = { description: newDescription };\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": `Bearer ${globalVars.directus_token}`\n  };\n  let attempts = 0;\n  while (attempts < 3) {\n    try {\n      const response = await axios.patch(patchUrl, patchPayload, { headers });\n      console.log(`Directus update successful: ${JSON.stringify(response.data)}`);\n      return response.data;\n    } catch (error) {\n      attempts++;\n      console.error(`Directus update attempt ${attempts} failed: ${error.message}`);\n      if (attempts < 3) {\n        await delay(1000);\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n\nasync function processScraping() {\n  // Extrai dados do nó Get Global Vars\n  const globalData = $('Get Global Vars').first().json;\n  const globalVars = globalData.global_vars;\n  const filesIds = Array.isArray(globalData.files_id) ? globalData.files_id : [];\n  const originalUrls = Array.isArray(globalData.urls) ? globalData.urls : [];\n  // Usa s3_url definido em global_vars\n  const host = globalVars.s3_url;\n  const directusToken = globalVars.directus_token;\n  const jinaToken = globalVars.jina_ai_token;\n  const openrouterKey = globalVars.openrouter_key;\n  const directusService = globalVars.directus_service;\n  const n8nWebhookService = globalVars.n8n_webhook_service;\n  const chunkLength = globalData.chunks_length || 2000; // fallback default\n  const overlapPercentage = globalData.overlap || 0;      // fallback default\n  \n  // Extrai o valor de Knowledge Trigger\n  const knowledgeTriggerId = $('Knowledge Trigger').first().json.payload.id;\n\n  // Processa arquivos para obter finalUrl com retry (se existirem)\n  const fileResults = await Promise.all(\n    filesIds.map(async (fileId) => {\n      try {\n        const response = await axiosGetWithRetry(\n          `http://${directusService}:8055/files/${fileId}`,\n          { headers: { Authorization: `Bearer ${directusToken}` } }\n        );\n        const filename_disk = response.data.data.filename_disk;\n        // Retira o \"s3\" pois já está incluso na URL\n        const finalUrl = `${host}/directus/${filename_disk}`;\n        return { type: 'file', fileId, url: finalUrl };\n      } catch (err) {\n        return {\n          type: 'file',\n          fileId,\n          error: err.message,\n          status: err.response?.status,\n          responseData: err.response?.data,\n        };\n      }\n    })\n  );\n\n  // Prepara URLs para scraping (se existirem)\n  const originalUrlsToScrape = originalUrls.map(url => ({ type: 'original', url }));\n  const allUrlsToScrape = [\n    ...fileResults.filter(item => item.url),\n    ...originalUrlsToScrape\n  ];\n\n  // Executa scraping com retry para cada URL (se houver)\n  const scrapeResults = await Promise.all(\n    allUrlsToScrape.map(async (item) => {\n      try {\n        const scrapingUrl = `https://r.jina.ai/${item.url}`;\n        const response = await axiosGetWithRetry(\n          scrapingUrl,\n          { headers: { Authorization: `Bearer ${jinaToken}` } }\n        );\n        return { ...item, scrapeData: response.data };\n      } catch (err) {\n        return {\n          ...item,\n          scrapeError: err.message,\n          status: err.response?.status,\n          errorData: err.response?.data,\n        };\n      }\n    })\n  );\n\n  // Agrega e limpa conteúdo dos scrapings para gerar chunks e descrição\n  const scrapedTexts = scrapeResults.map(item => item.scrapeData ? JSON.stringify(item.scrapeData) : '');\n  const aggregatedContent = scrapedTexts.join(' ');\n  const cleanedContent = aggregatedContent.replace(/[^a-zA-Z0-9\\s]/g, ' ');\n\n  // Gera chunks dos scrapings (mantendo conteúdo orgânico por scraping)\n  const chunks = [];\n  scrapeResults.forEach(item => {\n    if (item.scrapeData) {\n      const text = JSON.stringify(item.scrapeData);\n      const itemChunks = createChunks(text, chunkLength, overlapPercentage);\n      itemChunks.forEach(chunk => {\n        chunks.push({ chunk, source: item.url });\n      });\n    }\n  });\n\n  // Geração da descrição do conteúdo\n  const blockSize = 200000;\n  let finalDescription;\n  async function enviarPrompt(promptContent) {\n    const response = await axios.post(\n      'https://openrouter.ai/api/v1/chat/completions',\n      {\n        model: 'google/gemini-pro',\n        messages: [{ role: 'user', content: promptContent }]\n      },\n      { headers: { Authorization: `Bearer ${openrouterKey}` } }\n    );\n    return response.data;\n  }\n  if (cleanedContent.length > blockSize) {\n    const blocks = [];\n    for (let i = 0; i < cleanedContent.length; i += blockSize) {\n      blocks.push(cleanedContent.substring(i, i + blockSize));\n    }\n    const summaries = await Promise.all(\n      blocks.map(async (block) => {\n        const prompt = `<dados>${block}</dados>\\n` + SUMMARY_PROMPT.replace('{conteudo}', block);\n        try {\n          const summaryResponse = await enviarPrompt(prompt);\n          return (summaryResponse.choices && summaryResponse.choices[0].message.content) || '';\n        } catch (err) {\n          return '';\n        }\n      })\n    );\n    const aggregatedSummaries = summaries.join(' ');\n    const descriptionPrompt = `<dados>${aggregatedSummaries}</dados>\\n` + FINAL_DESCRIPTION_PROMPT.replace('{conteudo}', aggregatedSummaries);\n    try {\n      const descriptionResponse = await enviarPrompt(descriptionPrompt);\n      finalDescription = descriptionResponse;\n    } catch (err) {\n      finalDescription = { error: err.message, status: err.response?.status, errorData: err.response?.data };\n    }\n  } else {\n    const directPrompt = `<dados>${cleanedContent}</dados>\\n` + DIRECT_DESCRIPTION_PROMPT.replace('{conteudo}', cleanedContent);\n    try {\n      const descriptionResponse = await enviarPrompt(directPrompt);\n      finalDescription = descriptionResponse;\n    } catch (err) {\n      finalDescription = { error: err.message, status: err.response?.status, errorData: err.response?.data };\n    }\n  }\n  \n  // Extrai somente o conteúdo da descrição, se disponível\n  if (finalDescription && finalDescription.choices && finalDescription.choices[0] && finalDescription.choices[0].message) {\n    finalDescription = finalDescription.choices[0].message.content;\n  }\n\n  // Atualiza o campo \"description\" na tabela \"knowledge\" no Directus\n  try {\n    const updateResponse = await updateDirectusDescription(finalDescription, globalVars, globalData.id);\n    console.log(\"Directus update response:\", updateResponse);\n  } catch (error) {\n    console.error(\"Falha ao atualizar o Directus após 3 tentativas:\", error.message);\n  }\n\n  // Geração dos vetores a partir dos chunks\n  for (const chunkItem of chunks) {\n    const vectorPromptBody = {\n      messages: [\n        {\n          role: \"user\",\n          content: `Você é um agente interno de um sistema especializado em extrair perguntas e respostas de documentos. Sua tarefa é analisar o chunk fornecido, que representa um segmento de um documento completo, e gerar perguntas e respostas baseadas nas informações contidas nele. \n\nContexto do documento: ${globalData.Instruction_Prompt}\n\nDiretrizes:\n1. Extraia informações relevantes (respostas) do chunk fornecido. Essas informações devem ser associadas a perguntas principais, mantendo sempre o tom e o estilo do texto original.\n2. Para cada resposta extraída:\n   - Crie uma pergunta principal (q) que tenha como resposta a informação extraída (a).\n   - Identifique o trecho específico do documento (t) de onde a resposta foi retirada.\n   - Formule perguntas alternativas (sq) que poderiam ser feitas para obter a mesma resposta (a).\n3. Sempre que encontrar múltiplas informações relevantes, crie múltiplas perguntas e respostas.\n4. Mantenha a originalidade e fidelidade ao conteúdo fornecido.\n\nChunk:\n${chunkItem.chunk}`\n        }\n      ],\n      response_format: {\n        type: \"json_schema\",\n        json_schema: {\n          name: \"extracted_data\",\n          strict: true,\n          schema: {\n            type: \"object\",\n            properties: {\n              results: {\n                type: \"array\",\n                items: {\n                  type: \"object\",\n                  properties: {\n                    a: { type: \"string\", description: \"A resposta ou informação extraída.\" },\n                    t: { type: \"string\", description: \"O trecho exato do documento de onde a resposta foi retirada.\" },\n                    q: { type: \"string\", description: \"A pergunta principal que leva à resposta.\" },\n                    sq: { type: \"array\", items: { type: \"string\" }, description: \"Perguntas alternativas que poderiam obter a mesma resposta.\" }\n                  },\n                  required: [\"a\", \"t\", \"q\", \"sq\"],\n                  additionalProperties: false\n                }\n              }\n            },\n            required: [\"results\"],\n            additionalProperties: false\n          }\n        }\n      }\n    };\n    try {\n      const vectorResponse = await axios.post(\n        'https://openrouter.ai/api/v1/chat/completions',\n        vectorPromptBody,\n        { headers: { Authorization: `Bearer ${openrouterKey}` } }\n      );\n      // Envia a resposta para o webhook incluindo global_vars, knowledge_trigger_id, pinecone_host e namespace\n      await axios.post(\n        `http://${n8nWebhookService}:5678/webhook/vector`,\n        {\n          ...vectorResponse.data,\n          global_vars: globalVars,\n          knowledge_trigger_id: knowledgeTriggerId,\n          pinecone_host: globalData.pinecone_host,\n          namespace: globalData.namespace\n        }\n      );\n    } catch (err) {\n      console.error('Erro ao gerar vetor para chunk:', err.message);\n    }\n    // Aguarda 10 segundos antes da próxima requisição\n    await delay(10000);\n  }\n\n  return { files: fileResults, scraping: scrapeResults, description: finalDescription, chunks };\n}\n\nreturn processScraping()\n  .then(result => [{ json: result }])\n  .catch(error => {\n    console.error('Erro geral:', { message: error.message, details: error });\n    return [{ json: { error: error.message, details: error } }];\n  });"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        380,
        1520
      ],
      "id": "0f231286-9978-43f9-9133-0c7014f6448e",
      "name": "Process Docs"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "vector",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        700,
        1520
      ],
      "id": "1f327c3f-3619-4160-901a-a41479d36ee7",
      "name": "Vector Trigger",
      "webhookId": "31a23ccc-c8b7-4a93-980c-783c0490d567"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $('Vector Trigger').first().json.body.global_vars.openai_key }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "input",
              "value": "={{ `Context: ${$('Split Vectors').item.json.t} Question: ${$('Split Vectors').item.json.q} Answer: ${$('Split Vectors').item.json.a} Similar Questions: ${$('Split Vectors').item.json.sq.join(\", \")}` }}"
            },
            {
              "name": "model",
              "value": "text-embedding-3-small"
            },
            {
              "name": "dimensions",
              "value": "={{ 1536 }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1300,
        1520
      ],
      "id": "3857e8dc-ad00-413e-a335-dab7681e8b07",
      "name": "Embeddings",
      "notesInFlow": true
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={{ $json.body.choices[0].message.content.parseJson() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        900,
        1520
      ],
      "id": "f664c968-ba14-471d-aaee-b64092f77006",
      "name": "Parse JSON 2"
    },
    {
      "parameters": {
        "fieldToSplitOut": "results",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        1100,
        1520
      ],
      "id": "36b6fcf9-7cff-4afc-bbba-fcb91513f1e8",
      "name": "Split Vectors"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH new_vector AS (\n  INSERT INTO vectors \n    (id, date_created, question, answer, context, similar_questions, knowledge_id)\n  VALUES \n    (\n      uuid_generate_v4(), \n      NOW(), \n      $ {{ $('Parse JSON 2').item.json.results[$itemIndex].q }} $, \n      $ {{ $('Parse JSON 2').item.json.results[$itemIndex].a }} $, \n      $ {{ $('Parse JSON 2').item.json.results[$itemIndex].t }} $, \n      $ {{ $('Parse JSON 2').item.json.results[$itemIndex].sq.join(',') }} $, \n      {{ $('Vector Trigger').item.json.body.knowledge_trigger_id }}\n    )\n  RETURNING id AS vector_id\n),\nnew_dimension AS (\n  INSERT INTO dimensions (values, date_created, vector_id)\n  SELECT $ {{ $('Embeddings').item.json.data[0].embedding.join(',') }} $, NOW(), vector_id\n  FROM new_vector\n  RETURNING vector_id\n)\nINSERT INTO vectors_status (vector_id, value)\nSELECT vector_id, '#2ECDA7'\nFROM new_vector\nRETURNING vector_id;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1500,
        1520
      ],
      "id": "76a28cd8-154e-4e42-9907-5fda8aca205c",
      "name": "Add Vectors"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "/agent/knowledge",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -20,
        1840
      ],
      "id": "9a4e7188-463b-4022-8851-8af7982ce06e",
      "name": "RAG Input",
      "webhookId": "d503e6f9-0989-42d5-a598-e268b20c3182"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Por favor, analise a entrada do usuário e o histórico recente. \n\nEntrada do usuário: \n<user_input>{{ $('RAG Input').first().json.body.content }}</user_input>\n\nHistórico das últimas 10 mensagens: \n<conversation_history>{{ $('Get History').first().json.chat_histories.map(item => item.message).slice(-10).toJsonString() }}</conversation_history>",
        "options": {
          "systemMessage": "=Você é um agente especializado em realizar buscas no banco vetorial para fornecer contexto adicional à inteligência artificial principal.\n\nObjetivo:\nAnalisar a entrada do usuário e o histórico recente de mensagens para decidir se deve invocar a tool 'retriever' e, caso necessário, realizar buscas eficientes.\n\nDiretrizes:\nBusca desnecessária: Se a entrada do usuário não contiver perguntas relevantes ou específicas (ex.: saudações, mensagens genéricas ou irrelevantes), retorne: \"Busca desnecessária.\"\nNenhuma informação encontrada: Se, ao usar a tool 'retriever', nenhuma informação relevante for encontrada, retorne: \"Nenhuma informação relevante encontrada.\"\nForneça respostas precisas: Se encontrar informações no banco vetorial, forneça apenas o conteúdo necessário para responder à solicitação do usuário, de forma objetiva e sem interpretações adicionais.\nRegras para invocar a tool 'retriever':\nAnalise cuidadosamente a entrada do usuário e as descrições dos conhecimentos disponíveis para identificar qualquer possibilidade de relação com os temas abordados nos conhecimentos.\nConsidere como relevante qualquer pergunta do usuário que possa estar relacionada aos documentos descritos nos conhecimentos disponíveis. Se houver uma chance de associação, a busca deve ser realizada.\nUse as descrições dos conhecimentos disponíveis para identificar o knowledge_id mais adequado:\n\n<knowledge_metadata>{{ $('Get History').first().json.knowledge.map(item => ({ knowledge_id: item.id, description: item.description })).toJsonString() }}</knowledge_metadata>\n\nUse múltiplas queries, se necessário: Se a solicitação do usuário for ampla ou ambígua, faça buscas utilizando palavras-chave diferentes para cobrir todas as possibilidades.\nCombine os resultados de forma precisa e concisa, retornando apenas o contexto essencial à AI principal.\nInstruções adicionais:\nSe houver qualquer relação potencial entre a solicitação do usuário e os conhecimentos disponíveis, realize a busca imediatamente.\nAo invocar a tool 'retriever', faça perguntas claras e precisas, alinhadas ao contexto da entrada do usuário e aos temas descritos nos conhecimentos disponíveis.\nO foco é fornecer contexto relevante e direto para a AI principal.",
          "passthroughBinaryImages": true
        }
      },
      "id": "871b206a-a846-4729-9590-051580dd7e47",
      "name": "RAG Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        580,
        1840
      ],
      "retryOnFail": false,
      "executeOnce": false
    },
    {
      "parameters": {
        "name": "retriever",
        "description": "=Invoque essa tool para buscar informações no banco vetorial e fornecer respostas relevantes com base nos conhecimentos disponíveis. Use-a somente quando necessário para complementar o contexto.",
        "jsCode": "const axios = require('axios');\n\nasync function runTool() {\n  let logs = \"\";\n  \n  try {\n    // Obter parâmetros de entrada\n    logs += \"Obtendo parâmetros de entrada...\\n\";\n    const searchQuery = query.query;\n    const knowledgeId = query.knowledge_id;\n    logs += `searchQuery: ${searchQuery}\\nknowledgeId: ${knowledgeId}\\n`;\n    \n    // Obter mapping a partir do nó \"RAG Input\"\n    let mappingInput = $('RAG Input').first().json.body.mapping;\n    if (typeof mappingInput === 'string') {\n      try {\n        mappingInput = JSON.parse(mappingInput);\n        logs += \"Mapping Input convertido de string para objeto.\\n\";\n      } catch (e) {\n        throw new Error(\"Falha ao converter mapping para objeto.\");\n      }\n    }\n    logs += \"Mapping Input obtido.\\n\";\n    \n    if (!mappingInput.system) {\n      throw new Error(\"mappingInput.system está indefinido.\");\n    }\n    \n    // Gerar embeddings usando a API do OpenAI\n    logs += \"Chamando endpoint de embeddings da OpenAI...\\n\";\n    const openaiKey = mappingInput.system.openai_key;\n    const embeddingResponse = await axios.post(\n      'https://api.openai.com/v1/embeddings',\n      {\n        input: searchQuery,\n        model: \"text-embedding-3-small\"\n      },\n      {\n        headers: {\n          \"Authorization\": `Bearer ${openaiKey}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    logs += \"Embeddings obtidos com sucesso.\\n\";\n    const embedding = embeddingResponse.data.data[0].embedding;\n    logs += `Embedding (primeiros 5 valores): ${embedding.slice(0,5).join(\", \")}...\\n`;\n    \n    // Obter pinecone_host e namespace do histórico\n    logs += \"Obtendo pinecone_host e namespace a partir do histórico...\\n\";\n    const historyKnowledge = $('Get History').first().json.knowledge;\n    const knowledgeItem = historyKnowledge.find(item => item.id === knowledgeId);\n    if (!knowledgeItem) {\n      throw new Error(`Conhecimento com id ${knowledgeId} não encontrado.`);\n    }\n    const pineconeHostRaw = knowledgeItem.pinecone_host;\n    const namespace = knowledgeItem.namespace;\n    logs += `pineconeHostRaw: ${pineconeHostRaw}, namespace: ${namespace}\\n`;\n    \n    // Garantir que pinecone_host comece com \"https://\"\n    let pineconeHost = pineconeHostRaw;\n    if (!pineconeHost.startsWith(\"https://\")) {\n      pineconeHost = \"https://\" + pineconeHost;\n    }\n    logs += `pineconeHost final: ${pineconeHost}\\n`;\n    \n    // Requisição para a API do Pinecone\n    logs += \"Chamando API do Pinecone...\\n\";\n    const pineconeKey = mappingInput.system.pinecone_key;\n    const pineconeQueryUrl = `${pineconeHost}/query`;\n    const pineconeResponse = await axios.post(\n      pineconeQueryUrl,\n      {\n        namespace: namespace,\n        vector: embedding,\n        topK: 3,\n        includeValues: false,\n        includeMetadata: true\n      },\n      {\n        headers: {\n          \"Api-Key\": pineconeKey,\n          \"X-Pinecone-API-Version\": \"2024-10\",\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    logs += \"Resposta do Pinecone obtida com sucesso.\\n\";\n    logs += `Pinecone response data: ${JSON.stringify(pineconeResponse.data)}\\n`;\n    \n    // Processar os resultados do Pinecone usando as chaves corretas dos metadados (\"a\", \"q\" e \"t\")\n    const matches = pineconeResponse.data.matches;\n    matches.forEach((m, idx) => {\n      logs += `Match ${idx + 1}: id=${m.id}, score=${m.score}, metadata=${JSON.stringify(m.metadata)}\\n`;\n    });\n    \n    const filteredMatches = matches.filter(item => item.score >= 0.0)\n      .map(item => ({\n        vector: item.id,\n        score: item.score,\n        answer: item.metadata ? item.metadata.a : null,\n        question: item.metadata ? item.metadata.q : null,\n        context: item.metadata ? item.metadata.t : null\n      }));\n    logs += `Matches filtrados: ${JSON.stringify(filteredMatches)}\\n`;\n    \n    const resultString = `Os vetores retornados foram: ${JSON.stringify(filteredMatches)}`;\n    logs += \"Processamento final concluído.\\n\";\n    \n    console.log(\"Logs:\", logs);\n    // Retorna apenas o resultado final (string) sem os logs.\n    return resultString;\n  } catch (error) {\n    logs += `Erro: ${error.message}\\n`;\n    console.error(\"Erro:\", error.message, \"Logs:\", logs);\n    return `Erro: ${error.message}`;\n  }\n}\n\nreturn runTool();\n",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"knowledge_id\": {\n      \"type\": \"integer\",\n      \"description\": \"O ID do conhecimento específico no qual a busca será realizada.\"\n    },\n    \"query\": {\n      \"type\": \"string\",\n      \"description\": \"A pergunta ou consulta que será usada para realizar a busca no banco vetorial.\"\n    }\n  }\n}"
      },
      "id": "ede92031-961c-4d3f-a08e-0b48f1f217f6",
      "name": "Retriever",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        740,
        2120
      ]
    },
    {
      "parameters": {
        "content": "",
        "height": 660,
        "width": 2060,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -140,
        1400
      ],
      "typeVersion": 1,
      "id": "a046cb15-53fb-4899-a72b-948a7ee71d1b",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1300,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -120,
        1740
      ],
      "id": "6d173cb2-9fd7-4c68-aecd-b90d7b06a22f",
      "name": "Sticky Note9"
    },
    {
      "parameters": {
        "content": "",
        "width": 210,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        680,
        2080
      ],
      "typeVersion": 1,
      "id": "4dc9eb08-7f1e-4cc3-9040-47edde3a2eca",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 700,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -120,
        1420
      ],
      "id": "7ef905d4-ac9e-482a-bc60-67766ff1bc60",
      "name": "Sticky Note10"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1300,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        600,
        1420
      ],
      "id": "145f9ec4-341d-4d7c-9bc1-6a8bd7e1e715",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"chatwoot\": {\n    \"account_id\": {{ $('Consumer').first().json.body.account.id }},\n    \"contact_id\": {{ $('Consumer').first().json.body.conversation.contact_inbox.contact_id }},\n    \"conversation_id\": {{ $('Consumer').first().json.body.conversation.messages[0].conversation_id }},\n    \"sender_type\": {{ JSON.stringify($('Consumer').first().json.body.conversation.messages[0].sender_type) }},\n    \"bot_token\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.bot_token) }},\n    \"conversation_status\": {{ JSON.stringify($json.current_status) }},\n    \"assignee\": {{ JSON.stringify($('Consumer').first().json.body.conversation?.meta?.assignee?.name || null ) }},   \n    \"content\": {{ ($('Consumer').first().json.body?.content || \"\").toJsonString() }},    \n    \"data_url\": {{ JSON.stringify(\n        $('Consumer').first().json.body.conversation.messages?.[0]?.attachments?.[0]?.data_url || null\n      )\n    }},  \n    \"message_id\": {{ $('Consumer').first().json.body.id }},  \n    \"channel\": {{\n      JSON.stringify(\n        $('Consumer').first().json.body.conversation.channel === 'Channel::Api' \n        ? (\n            /@s\\.whatsapp\\.net$/.test($('Consumer').first().json.body.sender.identifier) \n            ? 'WhatsApp Web' \n            : /@g\\.us$/.test($('Consumer').first().json.body.sender.identifier) \n            ? 'WhatsApp Web Group' \n            : $('Consumer').first().json.body.conversation.channel.replace('Channel::', '')\n          ) \n        : $('Consumer').first().json.body.conversation.channel.replace('Channel::', '')\n      )\n    }},  \n    \"user_name\": {{ JSON.stringify(\n      $('Consumer').first().json.body.sender.identifier?.match(/@g\\.us$/)\n        ? (\n            $('Consumer').first().json.body?.content?.match(/^\\*\\*(.*?)\\*\\*/)?.[1] || ''\n          )\n        : $('Consumer').first().json.body.sender?.name || ''\n    ) }},\n    \"phone_number\": {{ JSON.stringify($('Consumer').first().json.body.sender.phone_number) || null }},\n    \"events\": {{ JSON.stringify($('Get Vars').first().json.events) }}\n  },\n  \n  \"system\": {\n    \"cooldown\": {{ $('Get Vars').first().json.ai_agents.cooldown }},\n    \"workflow_path\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.workflow_path) }},\n    \"model\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.model) }},\n    \"openai_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.openai_key) }},\n    \"directus_token\": {{ JSON.stringify($('Get Vars').first().json.global_vars.directus_token) }},\n    \"stirling_pdf_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.stirling_pdf_key) }},\n    \"elevenlabs_key\": \"{{ $('Get Vars').first().json.global_vars.elevenlabs_key }}\",\n    \"conversations_id\": {{ JSON.stringify($('Get Vars').first().json.conversations.id) }},\n    \"context_window\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.context_window) }},\n    \"enabled_condition\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.enabled_condition) }},\n    \"allow_whatsapp_groups\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.allow_whatsapp_groups) }},\n    \"allow_human_interruption\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.allow_human_interruption) }},\n    \"agent_phone_number\": {{ JSON.stringify(($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, '')) }},\n    \"agent_mentioned\": {{ JSON.stringify(($('Consumer').first().json.body?.content || '' ).includes('@' + ($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, ''))) }},\n    \"agent_name\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.name) }},\n    \"system_message\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.system_message) }},\n    \"user_type\": {{ JSON.stringify($('Get Vars').first().json.users.type) }},\n    \"output_format\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.output_format) }},\n    \"elevenlabs_model\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.elevenlabs_model) }},\n    \"elevenlabs_voice\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.elevenlabs_voice) }},\n    \"chatwoot_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.chatwoot_service) }},\n    \"n8n_webhook_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.n8n_webhook_service) }},\n    \"stirling_pdf_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.stirling_pdf_service) }},\n    \"directus_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.directus_service) }},\n    \"enabled_rag\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.enabled_rag) }},\n    \"ai_agent_id\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.id) }},\n    \"pinecone_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.pinecone_key) }},\n    \"downtime\": {{ new Date(\"1970-01-01T\" + $('Get Vars').first().json.ai_agents.downtime + \"Z\").getTime() / 1000 }},\n    \"clientId\": {{ JSON.stringify($('Get Vars').first().json.global_vars.clientId) }},\n    \"clientSecret\": {{ JSON.stringify($('Get Vars').first().json.global_vars.clientSecret) }},\n    \"refreshToken\": {{ JSON.stringify($('Get Vars').first().json.global_vars.refreshToken) }},\n    \"accessToken\": {{ JSON.stringify($('Get Vars').first().json.global_vars.accessToken) }},\n    \"core_chat_histories\": {{ JSON.stringify($('Get Vars').item.json.core_chat_histories, null, 2) }}\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        800,
        220
      ],
      "id": "b99d5110-2e21-4d35-a5c7-ab3170660d27",
      "name": "Mapping"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1600,
        760
      ],
      "id": "e4b38d6c-dc8c-41a3-87fd-6ce7891e1ef5",
      "name": "No Operation "
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\nasync function runTool() {\n  const logArray = [];\n  let currentStatus = \"\";\n  \n  try {\n    console.log(\"Obtendo data de última interação e downtime...\");\n    logArray.push(\"Obtendo data de última interação e downtime...\");\n    \n    const dateUpdatedStr = $('Get Vars').first().json.users.date_updated;\n    const downtimeStr = $('Get Vars').first().json.ai_agents.downtime;\n    console.log(`date_updated: ${dateUpdatedStr}`);\n    console.log(`downtime: ${downtimeStr}`);\n    logArray.push(`date_updated: ${dateUpdatedStr}`);\n    logArray.push(`downtime: ${downtimeStr}`);\n    \n    // Se downtime for \"00:00:00\", considere desativado e não realizar a requisição.\n    if (downtimeStr === \"00:00:00\") {\n      console.log(\"Downtime é 00:00:00. Nenhuma ação será realizada.\");\n      logArray.push(\"Downtime é 00:00:00. Nenhuma ação será realizada.\");\n      currentStatus = $('Consumer').first().json.body.conversation.status;\n      return [{ json: { current_status: currentStatus, logs: logArray } }];\n    }\n    \n    const lastUpdated = new Date(dateUpdatedStr);\n    const now = new Date();\n    const diffMs = now - lastUpdated;\n    const diffMinutes = (diffMs / 60000).toFixed(2);\n    \n    // Converter downtime (HH:MM:SS) para milissegundos e para minutos\n    const [hours, minutes, seconds] = downtimeStr.split(':').map(Number);\n    const downtimeMs = ((hours * 3600) + (minutes * 60) + seconds) * 1000;\n    const downtimeMinutes = (downtimeMs / 60000).toFixed(2);\n    \n    console.log(`diff: ${diffMinutes} minutes, downtime: ${downtimeMinutes} minutes`);\n    logArray.push(`diff: ${diffMinutes} minutes, downtime: ${downtimeMinutes} minutes`);\n    \n    // Obter conversation status e conversation_id do nó Consumer\n    const conversationStatus = $('Consumer').first().json.body.conversation.status;\n    const convId = $('Consumer').first().json.body.conversation.messages[0].conversation_id;\n    console.log(`conversation status: ${conversationStatus}`);\n    console.log(`conversation_id: ${convId}`);\n    logArray.push(`conversation status: ${conversationStatus}`);\n    logArray.push(`conversation_id: ${convId}`);\n    \n    // Inicialmente, currentStatus recebe o status atual\n    currentStatus = conversationStatus;\n    \n    // Verifica se o tempo de inatividade foi excedido e se conversation.status é diferente de \"pending\"\n    if (diffMs >= downtimeMs && conversationStatus !== \"pending\") {\n      console.log(\"Condições atendidas: tempo de inatividade excedido e conversation.status não é 'pending'.\");\n      logArray.push(\"Condições atendidas: tempo de inatividade excedido e conversation.status não é 'pending'. Tentando abrir conversa no Chatwoot...\");\n      \n      const chatwootService = $('Get Vars').first().json.global_vars.chatwoot_service;\n      const accountId = $('Consumer').first().json.body.account.id;\n      const conversationId = convId;\n      const botToken = $('Get Vars').first().json.ai_agents.bot_token;\n      \n      const toggleUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/toggle_status`;\n      console.log(`Toggle URL: ${toggleUrl}`);\n      logArray.push(`Toggle URL: ${toggleUrl}`);\n      \n      try {\n        const response = await axios.post(\n          toggleUrl,\n          { status: \"pending\" },\n          { headers: { api_access_token: botToken } }\n        );\n        console.log(\"Conversa aberta com sucesso no Chatwoot.\");\n        logArray.push(\"Conversa aberta com sucesso no Chatwoot.\");\n        currentStatus = \"pending\";\n      } catch (err) {\n        console.error(\"Erro ao abrir conversa:\", err.message);\n        logArray.push(`Erro ao abrir conversa: ${err.message}`);\n      }\n    } else {\n      console.log(\"Condições não atendidas: tempo de inatividade não excedido ou conversation.status é 'pending'. Nenhuma ação realizada.\");\n      logArray.push(\"Condições não atendidas: tempo de inatividade não excedido ou conversation.status é 'pending'. Nenhuma ação realizada.\");\n    }\n    \n    return [{ json: { current_status: currentStatus, logs: logArray } }];\n  } catch (error) {\n    console.error(\"Erro geral:\", error.message);\n    logArray.push(`Erro geral: ${error.message}`);\n    return [{ json: { error: error.message, current_status: currentStatus, logs: logArray } }];\n  }\n}\n\nreturn runTool();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        220
      ],
      "id": "474a7bea-16ff-49a8-b7bf-6d21eee80d8b",
      "name": "Downtime",
      "alwaysOutputData": false
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1200,
        960
      ],
      "id": "06e0f1f3-789d-473e-988d-91393e7af597",
      "name": "No Operation 0"
    },
    {
      "parameters": {
        "triggerMode": "listenTrigger",
        "channelName": "specific_channel",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTrigger",
      "typeVersion": 1,
      "position": [
        1300,
        1840
      ],
      "id": "10dec1d5-d749-4839-aa58-b7956a11f717",
      "name": "Postgres Trigger"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\nasync function main() {\n  const trimLog = (msg, limit = 100) => (typeof msg === 'string' && msg.length > limit ? msg.substring(0, limit) + '...' : msg);\n  let logs = [];\n\n  try {\n    const payload = $('Postgres Trigger').first().json.payload;\n    logs.push(\"Payload carregado.\");\n\n    const op = payload.operation;\n    logs.push(\"Operação: \" + op);\n\n    let pineconeHost = payload.data.pinecone_host;\n    if (!pineconeHost.startsWith(\"https://\")) pineconeHost = \"https://\" + pineconeHost;\n\n    const pineconeHeaders = {\n      \"Api-Key\": payload.global_vars.pinecone_key,\n      \"X-Pinecone-API-Version\": \"2024-10\",\n      \"Content-Type\": \"application/json\"\n    };\n    logs.push(\"Headers Pinecone configurados.\");\n\n    let endpoint, response, mainResponse;\n\n    const axiosRequest = async (options) => {\n      try {\n        const res = await axios(options);\n        return res.data;\n      } catch (err) {\n        throw new Error(err?.response?.data?.message || err.message || JSON.stringify(err));\n      }\n    };\n\n    const getDirectus = async (url, headers, params) => axiosRequest({ method: 'GET', url, headers, params });\n    const postDirectus = async (url, headers, data) => axiosRequest({ method: 'POST', url, headers, data });\n    const patchDirectus = async (url, headers, data) => axiosRequest({ method: 'PATCH', url, headers, data });\n\n    if (op === \"DISABLED\" || op === \"DELETE\") {\n      endpoint = pineconeHost + \"/vectors/delete\";\n      const deleteBody = { ids: [payload.data.id], namespace: payload.data.namespace };\n      response = await axiosRequest({ method: 'POST', url: endpoint, headers: pineconeHeaders, data: deleteBody });\n      mainResponse = response;\n    } else if ((op === \"UPDATE\" || op === \"INSERT\") && payload.data.enabled === true) {\n      let embedding;\n\n      if (op === \"INSERT\") {\n        const directusEndpoint = `http://${payload.global_vars.directus_service}:8055/items/dimensions`;\n        const directusHeaders = { Authorization: `Bearer ${payload.global_vars.directus_token}`, \"Content-Type\": \"application/json\" };\n        const params = { \"filter[vector_id][_eq]\": payload.data.id };\n\n        const directusRecord = await getDirectus(directusEndpoint, directusHeaders, params);\n        if (directusRecord?.data?.length > 0 && directusRecord.data[0].values) {\n          const directusValues = directusRecord.data[0].values;\n          embedding = typeof directusValues === 'string' ? directusValues.split(\",\").map(Number) : directusValues;\n          logs.push(\"Embedding reutilizado do Directus (dimensions).\");\n        }\n      }\n\n      if (!embedding) {\n        const openAIInput = `Context: ${payload.data.context} Question: ${payload.data.question} Answer: ${payload.data.answer} Similar Questions: ${payload.data.similar_questions?.replace(/,/g, ', ')}`;\n        const openAIBody = { input: openAIInput, model: \"text-embedding-3-small\", dimensions: 1536 };\n        const openAIHeaders = { Authorization: `Bearer ${payload.global_vars.openai_key}`, \"Content-Type\": \"application/json\" };\n        const openAIEndpoint = \"https://api.openai.com/v1/embeddings\";\n\n        const openAIResponse = await axiosRequest({ method: 'POST', url: openAIEndpoint, headers: openAIHeaders, data: openAIBody });\n        embedding = openAIResponse?.data?.[0]?.embedding;\n        if (!embedding) throw new Error(\"Embedding não retornado pelo OpenAI.\");\n      }\n\n      const similarQuestionsArray = payload.data.similar_questions?.split(',').map(s => s.trim()) || [];\n\n      endpoint = pineconeHost + \"/vectors/upsert\";\n      const upsertBody = {\n        vectors: [{\n          id: payload.data.id,\n          values: embedding,\n          metadata: {\n            a: payload.data.answer,\n            t: payload.data.context,\n            q: payload.data.question,\n            sq: similarQuestionsArray\n          }\n        }],\n        namespace: payload.data.namespace\n      };\n\n      response = await axiosRequest({ method: 'POST', url: endpoint, headers: pineconeHeaders, data: upsertBody });\n      mainResponse = response;\n\n      // Atualização/Criação Directus\n      const dimensionsUrl = `http://${payload.global_vars.directus_service}:8055/items/dimensions`;\n      const dimensionsHeaders = { Authorization: `Bearer ${payload.global_vars.directus_token}`, \"Content-Type\": \"application/json\" };\n      const dimensionsParams = { \"filter[vector_id][_eq]\": payload.data.id };\n      const dimensionsRecord = await getDirectus(dimensionsUrl, dimensionsHeaders, dimensionsParams);\n\n      const directusValues = Array.isArray(embedding) ? embedding.join(\",\") : embedding;\n      const timestamp = new Date().toISOString();\n      const dimensionsBody = { values: directusValues, vector_id: payload.data.id, date_created: timestamp, date_updated: timestamp };\n\n      if (dimensionsRecord?.data?.length > 0) {\n        const id = dimensionsRecord.data[0].id;\n        await patchDirectus(`${dimensionsUrl}/${id}`, dimensionsHeaders, dimensionsBody);\n      } else {\n        await postDirectus(dimensionsUrl, dimensionsHeaders, dimensionsBody);\n      }\n    }\n\n    return [{ json: { mainResponse, logs } }];\n  } catch (error) {\n    logs.push(\"Erro: \" + (error?.message || JSON.stringify(error)));\n    return [{ json: { error: error?.message || String(error), logs } }];\n  }\n}\n\nreturn main();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1700,
        1840
      ],
      "id": "d97cee19-4abb-40b8-826d-2dfecda8b8ed",
      "name": "Update Vectors"
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "dimensions",
          "mode": "list",
          "cachedResultName": "dimensions"
        },
        "returnAll": true,
        "where": {
          "values": [
            {
              "column": "vector_id",
              "value": "={{ $json.payload.data.id }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1500,
        1840
      ],
      "id": "b84716a9-244b-4793-a84c-87879fa2ffc5",
      "name": "Get Dimensions",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 700,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1200,
        1740
      ],
      "id": "2af932aa-8d2c-440c-9532-08123d8a7831",
      "name": "Sticky Note15"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        940,
        1840
      ],
      "id": "2a21dd7c-5591-4ff9-a7d0-e302228d3b4a",
      "name": "No Operation 3"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH knowledge_descriptions AS (\n  SELECT json_agg(\n    json_build_object(\n      'id', k.id,\n      'description', k.description,\n      'pinecone_host', ph.value,\n      'namespace', ns.value\n    )\n  ) AS knowledge_data\n  FROM knowledge_ai_agents kaa\n  JOIN knowledge k ON k.id = kaa.knowledge_id\n  LEFT JOIN pinecone_host ph ON ph.id = k.pinecone_host_id\n  LEFT JOIN namespace ns ON ns.id = k.name_id\n  WHERE kaa.ai_agents_id = {{ $('RAG Input').item.json.body.mapping.parseJson().system.ai_agent_id }}\n),\nchat_histories AS (\n  SELECT json_agg(ch.*) AS chat_items\n  FROM core_chat_histories ch\n  WHERE ch.session_id = '{{ $('RAG Input').item.json.body.mapping.parseJson().system.conversations_id }}'\n)\nSELECT\n  (SELECT knowledge_data FROM knowledge_descriptions) AS knowledge,\n  (SELECT chat_items FROM chat_histories) AS chat_histories;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        380,
        1840
      ],
      "id": "1fe6a73e-2123-4b40-af58-980aa04850c7",
      "name": "Get History"
    },
    {
      "parameters": {
        "name": "clickup",
        "description": "Ferramenta para gerenciar tarefas no ClickUp. Permite criar, listar, atualizar ou remover tarefas. Para criar, forneça pelo menos o título. Para atualizar ou remover, você precisa fornecer o ID da tarefa. Para listar, você pode aplicar filtros opcionais.",
        "jsCode": "const workspaceId = '9011917991';\nconst listId = '901109860036';\nconst apiKey = 'pk_44163283_ZIFREHZQNJWKZ5YSD0XVV45B272AOARG';\nconst https = require('https');\n\nconst logs = [];\n\nfunction log(message) {\n  logs.push({ time: new Date().toISOString(), message });\n}\n\nfunction request(path, method, body = null) {\n  log(`Requisição: ${method} ${path}`);\n  \n  return new Promise((resolve, reject) => {\n    const options = {\n      hostname: 'api.clickup.com',\n      path,\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': apiKey\n      }\n    };\n    \n    const req = https.request(options, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        try {\n          log(`Resposta: status ${res.statusCode}`);\n          \n          // Tratamento de respostas vazias (comum em DELETEs)\n          if (!data || data.trim() === '') {\n            return res.statusCode < 300 \n              ? resolve({ success: true }) \n              : reject({ \n                  success: false, \n                  message: `Erro: ${res.statusMessage}`, \n                  statusCode: res.statusCode \n                });\n          }\n          \n          const responseData = JSON.parse(data);\n          \n          if (res.statusCode < 300) {\n            resolve(responseData);\n          } else {\n            reject({\n              success: false,\n              message: `Erro: ${responseData.err || res.statusMessage}`,\n              statusCode: res.statusCode\n            });\n          }\n        } catch (error) {\n          log(`Erro ao processar resposta: ${error.message}`);\n          reject({\n            success: false,\n            message: `Erro ao processar resposta: ${error.message}`,\n            data\n          });\n        }\n      });\n    });\n\n    req.on('error', (error) => {\n      log(`Erro na requisição: ${error.message}`);\n      reject({ success: false, message: `Erro na requisição: ${error.message}` });\n    });\n\n    if (body) {\n      const data = typeof body === 'string' ? body : JSON.stringify(body);\n      log(`Enviando dados: ${data.substring(0, 100)}${data.length > 100 ? '...' : ''}`);\n      req.write(data);\n    }\n    \n    req.end();\n  });\n}\n\nconst operations = {\n  async list(query) {\n    log('Operação: listar tarefas');\n    \n    try {\n      // Construir parâmetros de consulta\n      const params = [];\n      \n      if (query.status) params.push(`statuses[]=${encodeURIComponent(query.status)}`);\n      if (query.assignee) params.push(`assignees[]=${encodeURIComponent(query.assignee)}`);\n      if (query.due_date_gt) params.push(`due_date_gt=${encodeURIComponent(query.due_date_gt)}`);\n      if (query.due_date_lt) params.push(`due_date_lt=${encodeURIComponent(query.due_date_lt)}`);\n      \n      // Paginação\n      params.push(`page=${query.page || 0}`);\n      const limit = Math.min(query.limit || 20, 100);\n      params.push(`limit=${limit}`);\n      \n      log(`Parâmetros: ${params.join('&')}`);\n      \n      // Fazer requisição\n      const data = await request(\n        `/api/v2/list/${listId}/task?${params.join('&')}`, \n        'GET'\n      );\n      \n      log(`Tarefas encontradas: ${data.tasks.length}`);\n      \n      return {\n        success: true,\n        tasks: data.tasks,\n        total_count: data.tasks.length,\n        has_more: data.tasks.length === limit\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n\n  async create(query) {\n    log('Operação: criar tarefa');\n    \n    if (!query.title) {\n      log('Erro: Título da tarefa não fornecido');\n      return { success: false, message: \"Título da tarefa é obrigatório para criação\" };\n    }\n    \n    const body = {\n      name: query.title,\n      description: query.description || '',\n      due_date: query.due_date || null,\n      priority: query.priority || 3,\n      assignees: query.assignees || []\n    };\n    \n    try {\n      log(`Criando tarefa: \"${query.title}\"`);\n      const data = await request(`/api/v2/list/${listId}/task`, 'POST', body);\n      log(`Tarefa criada com sucesso, ID: ${data.id}`);\n      \n      return {\n        success: true,\n        message: \"Tarefa criada com sucesso\",\n        taskId: data.id,\n        taskUrl: data.url\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n  \n  async delete(query) {\n    log('Operação: remover tarefa');\n    \n    if (!query.task_id) {\n      log('Erro: ID da tarefa não fornecido');\n      return { success: false, message: \"ID da tarefa é obrigatório para remoção\" };\n    }\n    \n    try {\n      log(`Removendo tarefa: ${query.task_id}`);\n      await request(`/api/v2/task/${query.task_id}`, 'DELETE');\n      log('Tarefa removida com sucesso');\n      \n      return {\n        success: true,\n        message: \"Tarefa removida com sucesso\",\n        taskId: query.task_id\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n  \n  async update(query) {\n    log('Operação: atualizar tarefa');\n    \n    if (!query.task_id) {\n      log('Erro: ID da tarefa não fornecido');\n      return { success: false, message: \"ID da tarefa é obrigatório para atualização\" };\n    }\n    \n    // Mapear campos\n    const fields = {\n      title: 'name',\n      description: 'description',\n      due_date: 'due_date',\n      priority: 'priority',\n      status: 'status',\n      assignees: 'assignees'\n    };\n    \n    const body = {};\n    \n    // Filtrar campos fornecidos\n    Object.entries(fields).forEach(([src, dest]) => {\n      if (query[src] !== undefined) body[dest] = query[src];\n    });\n    \n    if (Object.keys(body).length === 0) {\n      log('Erro: Nenhum campo fornecido para atualização');\n      return { success: false, message: \"Nenhum campo fornecido para atualização\" };\n    }\n    \n    try {\n      log(`Atualizando tarefa: ${query.task_id}`);\n      await request(`/api/v2/task/${query.task_id}`, 'PUT', body);\n      log('Tarefa atualizada com sucesso');\n      \n      return {\n        success: true,\n        message: \"Tarefa atualizada com sucesso\",\n        taskId: query.task_id\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  }\n};\n\ntry {\n  log(`Iniciando processamento: ${JSON.stringify(query)}`);\n  \n  const operation = query.operation || 'create';\n  \n  const result = await operations[operation](query);\n  \n  return JSON.stringify({\n    success: true,\n    ...result,\n    logs: logs\n  });\n} catch (error) {\n  log(`Erro não tratado: ${error.message || JSON.stringify(error)}`);\n  return JSON.stringify({ \n    success: false, \n    message: `Erro não tratado: ${error.message || 'Erro desconhecido'}`,\n    logs \n  });\n}",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"operation\": {\n      \"type\": \"string\",\n      \"description\": \"Operação a ser realizada: criar, listar, atualizar ou remover tarefas\",\n      \"enum\": [\"create\", \"list\", \"update\", \"delete\"],\n      \"default\": \"create\"\n    },\n    \"task_id\": {\n      \"type\": \"string\",\n      \"description\": \"ID da tarefa (obrigatório para atualizar ou remover)\"\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"description\": \"Título da tarefa (obrigatório para criar, opcional para atualizar)\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"Descrição detalhada da tarefa (opcional)\"\n    },\n    \"due_date\": {\n      \"type\": \"string\",\n      \"description\": \"Data de vencimento no formato timestamp ou ISO 8601 (opcional)\"\n    },\n    \"priority\": {\n      \"type\": \"integer\",\n      \"description\": \"Prioridade da tarefa (1: Urgente, 2: Alta, 3: Normal, 4: Baixa) (opcional)\",\n      \"enum\": [1, 2, 3, 4]\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"description\": \"Status da tarefa (para atualizar ou filtrar na listagem)\"\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"integer\"\n      },\n      \"description\": \"Lista de IDs dos usuários atribuídos à tarefa (opcional)\"\n    },\n    \"assignee\": {\n      \"type\": \"integer\",\n      \"description\": \"Filtrar por ID do usuário atribuído (para listar)\"\n    },\n    \"due_date_gt\": {\n      \"type\": \"string\",\n      \"description\": \"Filtrar tarefas com data de vencimento posterior (para listar)\"\n    },\n    \"due_date_lt\": {\n      \"type\": \"string\",\n      \"description\": \"Filtrar tarefas com data de vencimento anterior (para listar)\"\n    },\n    \"page\": {\n      \"type\": \"integer\",\n      \"description\": \"Número da página para paginação (para listar)\",\n      \"default\": 0\n    },\n    \"limit\": {\n      \"type\": \"integer\",\n      \"description\": \"Número de tarefas por página (máximo 100, para listar)\",\n      \"default\": 20\n    }\n  },\n  \"required\": [\"operation\"],\n  \"dependencies\": {\n    \"operation\": {\n      \"oneOf\": [\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"create\"]\n            }\n          },\n          \"required\": [\"title\"]\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"list\"]\n            }\n          }\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"update\"]\n            }\n          },\n          \"required\": [\"task_id\"]\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"delete\"]\n            }\n          },\n          \"required\": [\"task_id\"]\n        }\n      ]\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        6560,
        1200
      ],
      "id": "86408c5e-10d1-4ef8-8164-e1990ce448e8",
      "name": "Clickup",
      "disabled": true
    },
    {
      "parameters": {
        "name": "scheduling",
        "description": "Chama agente de calendário como ferramenta para gerenciar agendamentos e compromissos do calendário através do n8n. Processa solicitações relacionadas a criação, atualização, consulta e cancelamento de eventos agendados. Sem parâmetros necessários.",
        "jsCode": "// SchedulingAssistant tool for n8n\nconst axios = require('axios');\n\ntry {\n  // Acessar parâmetros e variáveis do mapeamento\n  const params = query;\n  const mapping = $('Mapping').first().json;\n\n  const user = mapping.chatwoot.contact_id;\n  const directus_token = mapping.system.directus_token;\n  const directus_service = mapping.system.directus_service;\n  const n8n_service = mapping.system.n8n_webhook_service;\n\n  // Corrigido: caminho correto para o webhook\n  const url = `${n8n_service}/webhook/calendar/agent`;\n\n  // Montar payload para envio\n  const payload = {\n    params,\n    directus_token,\n    directus_service,\n    user\n  };\n\n  // Chamar o webhook do outro fluxo\n  const response = await axios.post(url, payload);\n\n  // Retornar resposta como string para o n8n\n  return JSON.stringify(response.data);\n\n} catch (error) {\n  // Lançar erro para que o n8n registre corretamente\n  throw new Error(`Erro ao processar agendamento: ${error.message}`);\n}\n",
        "specifyInputSchema": true,
        "jsonSchemaExample": "{\n\t\"solicitacao\": \"Descreva a solicitação do usuario relativa a operacao do calendario com maximo de detalhes para o agente de calendário\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        6440,
        1200
      ],
      "id": "ecbc2606-ec92-44f6-a5af-dcfebe569d38",
      "name": "Google Calendar",
      "disabled": true
    },
    {
      "parameters": {
        "toolDescription": "Chama agente de calendário como ferramenta para gerenciar agendamentos e compromissos do calendário através do n8n. Processa solicitações relacionadas a criação, atualização, consulta e cancelamento de eventos agendados. Sem parâmetros necessários.",
        "method": "POST",
        "url": "={{ $env.WEBHOOK_URL }}webhook/calendar/agent",
        "sendHeaders": true,
        "specifyHeaders": "json",
        "jsonHeaders": "={\n  \"api-address\": \"http://{{ $('Main Agent1').first().json.body.mapping.parseJson().system.directus_service }}:8055\",\n  \"api-token\": \"{{ $('Main Agent1').first().json.body.mapping.parseJson().system.directus_token }}\",\n  \"last-workflow\": \"{{ $workflow.name }}\"\n}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"solicitacao\": \"{{ $fromAI(\n    \"solicitacao\",\n    \"Descreva a solicitação do usuario relativa a operacao do calendario com maximo de detalhes para o agente de calendário\",\n    \"string\"\n  )}}\",\n  \"contact\": \"{{ $('Main Agent1').first().json.body.mapping.parseJson().chatwoot.contact_id }}\"\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        6680,
        1200
      ],
      "id": "9634dd9c-bbec-4209-b39f-e5887aca63d0",
      "name": "Agent Calendar"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Get Vars').first().json.global_vars.chatwoot_service.startsWith('chatwoot') \n  ? \"http://\" \n      + $('Get Vars').first().json.global_vars.chatwoot_service \n      + \":3000\" \n  : $('Get Vars').first().json.global_vars.chatwoot_service\n}}/api/v1/accounts/{{ $('Get Vars').first().json.ai_agents.account_id }}/conversations/{{ $('Mapping').first().json.chatwoot.conversation_id }}/messages",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Mapping').first().json.chatwoot.bot_token }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $json.segment }}"
            }
          ]
        },
        "options": {}
      },
      "id": "1e7fdbdb-5863-4e37-86ca-2ab99e69a0c1",
      "name": "Envia Chatwoot Text",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2960,
        980
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Mapping').first().json.system.output_format }}",
                    "rightValue": "text",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "e93af114-87ee-4381-a219-c11dc5473382"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "text"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "c67b209f-0c91-4209-823e-d31f6c280071",
                    "leftValue": "={{ $('Mapping').first().json.system.output_format }}",
                    "rightValue": "audio",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "audio"
            }
          ]
        },
        "options": {
          "allMatchingOutputs": true
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        2760,
        1080
      ],
      "id": "86750edf-ff26-4620-a9ee-449c89a56111",
      "name": "Response Format"
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "03054703-1071-4ba3-891c-68e6966a75d7",
      "name": "Loop Messages",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        2360,
        960
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Get Vars').first().json.global_vars.chatwoot_service.startsWith('chatwoot') \n  ? \"http://\" \n      + $('Get Vars').first().json.global_vars.chatwoot_service \n      + \":3000\" \n  : $('Get Vars').first().json.global_vars.chatwoot_service\n}}/api/v1/accounts/{{ $('Get Vars').item.json.ai_agents.account_id }}/conversations/{{ $('Mapping').item.json.chatwoot.conversation_id }}/messages",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Mapping').first().json.chatwoot.bot_token }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "Mensagem com anexo"
            },
            {
              "parameterType": "formBinaryData",
              "name": "attachments[]",
              "inputDataFieldName": "data"
            },
            {
              "name": "file_type",
              "value": "audio"
            },
            {
              "name": "message_type",
              "value": "outgoing"
            }
          ]
        },
        "options": {}
      },
      "id": "5316d6bb-00bc-44d1-9be4-c46ae8cad658",
      "name": "Send Chatwoot Media",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3620,
        1180
      ]
    },
    {
      "parameters": {
        "amount": 0
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2560,
        1080
      ],
      "id": "c5d68d42-cb75-43f8-8659-e868def41a8d",
      "name": "Delay Before Message",
      "webhookId": "b77f8239-7758-41ad-b4ad-ad2207bc2c18",
      "notesInFlow": true,
      "notes": "Delay antes de todas mensagens"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        3820,
        1080
      ],
      "id": "adb7abc4-ebb1-465d-97e8-2fdbe9a8aa7a",
      "name": "Delay After Message",
      "webhookId": "3696b807-1a5f-4264-b8c7-31858e152dd4",
      "notesInFlow": true,
      "notes": "Delay depois de todas mensagens"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.elevenlabs.io/v1/text-to-speech/{{ $('Mapping').first().json.system.elevenlabs_voice }}",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "output_format",
              "value": "mp3_44100_128"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "xi-api-key",
              "value": "={{ $('Mapping').first().json.system.elevenlabs_key }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model_id",
              "value": "={{ $('Mapping').first().json.system.elevenlabs_model }}"
            },
            {
              "name": "text",
              "value": "={{ $json.segment }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2960,
        1180
      ],
      "id": "e43e6800-98b7-4a97-8787-5a3860a68145",
      "name": "Text To Speech ElevenLabs"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        3620,
        980
      ],
      "id": "ad16688b-c097-4afd-aa25-b1ab733a2e14",
      "name": "No Operation, do nothing"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"messages\": {\n      \"description\": \"Array com as mensagens\",\n      \"type\": \"array\",\n      \"items\": {\n        \"description\": \"As mensagens segmentadas\",\n        \"type\": \"string\"\n      }\n    }\n  },\n  \"required\": [\"messages\"]\n}"
      },
      "id": "e4b55d65-9bb6-4b54-9b79-c6785ab65250",
      "name": "OutputParser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        2020,
        1220
      ]
    },
    {
      "parameters": {
        "fieldToSplitOut": "=output.messages",
        "options": {
          "destinationFieldName": "segment"
        }
      },
      "id": "b562a41e-9710-449d-b372-f1895d0cb7de",
      "name": "Split Messages",
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        2160,
        960
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('Call Agent Main').item.json.output }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=<prompt>\n  <papel>\n    Você é um assistente especializado em separar textos em pequenas mensagens claras e naturais, sem modificar o conteúdo original. Seu papel é facilitar a leitura e o entendimento das mensagens, produzindo resultados em formato JSON.\n  </papel>\n\n  <requisicao>\n    Receba um texto de entrada e divida-o em partes coerentes e fáceis de ler, retornando exatamente no formato JSON descrito abaixo:\n\n    {\n      \"messages\": [\n        \"mensagemSeparada\",\n        \"mensagemSeparada\",\n        \"mensagemSeparada\"\n      ]\n    }\n  </requisicao>\n\n  <explicacao>\n    Sua tarefa é dividir as mensagens respeitando a fluidez e coerência natural do texto. Considere pontos finais (.), vírgulas (,), e especialmente quebras de linha (\\n) como indicações claras para separar o conteúdo em novas mensagens. Mensagens contendo listas (numeradas ou não) jamais devem ser divididas; mantenha-as intactas em uma única mensagem.\n    Cada parte separada deve ser compreensível isoladamente, como se você estivesse ajudando uma pessoa a entender rapidamente o conteúdo.\n  </explicacao>\n\n  <parametros>\n    - Divida o texto em no mínimo 1 e no máximo 5 mensagens.\n    - Nunca divida listas em mais de uma mensagem; listas sempre completas.\n    - Preserve exatamente o conteúdo original.\n    - Evite dividir frases pela metade ou causar quebra de sentido.\n    - Cada mensagem deve ser clara, concisa e de fácil leitura.\n    - Sempre preserve as quebras de linha originais do texto.\n    - Nunca mude ou adicione conteúdo além do original.\n  </parametros>\n</prompt>"
            }
          ]
        }
      },
      "id": "331514f3-0573-4b19-ba0c-2f291f18a39a",
      "name": "Message Segment Agent",
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.4,
      "position": [
        1800,
        960
      ],
      "retryOnFail": true,
      "maxTries": 5
    },
    {
      "parameters": {
        "operation": "binaryToPropery",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        3180,
        1180
      ],
      "id": "61c02df3-0a70-4fc0-89b5-33f53c1a45a6",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "operation": "toBinary",
        "sourceProperty": "data",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        3400,
        1180
      ],
      "id": "ea249440-2474-4ccc-ba92-531a11400994",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH last_conversation AS (\n  -- Última conversa do usuário\n  SELECT id\n  FROM conversations\n  WHERE user_id = {{ $('Mapping').first().json.chatwoot.contact_id }}\n  ORDER BY date_created DESC\n  LIMIT 1\n),\nlast_two_chat_histories AS (\n  -- Dois últimos históricos da conversa\n  SELECT \n    id,\n    ROW_NUMBER() OVER (ORDER BY id DESC) AS rn\n  FROM core_chat_histories\n  WHERE session_id = (SELECT id FROM last_conversation)\n  ORDER BY id DESC\n  LIMIT 2\n),\nupdate_chat_histories AS (\n  UPDATE core_chat_histories c\n  SET \n    date_created = NOW(),\n    message = (\n      CASE \n        WHEN l.rn = 2 \n          THEN jsonb_set(\n            c.message::jsonb, \n            '{user_name}', \n            to_jsonb('{{ $('Mapping').first().json.chatwoot.user_name }}'::text), \n            true\n          )\n        ELSE c.message::jsonb\n      END\n    )::json\n  FROM last_two_chat_histories l\n  WHERE c.id = l.id\n  RETURNING 1\n),\nupdate_conversations AS (\n  UPDATE conversations conv\n  SET date_updated = NOW()\n  WHERE conv.id = (SELECT id FROM last_conversation)\n  RETURNING 1\n)\nUPDATE users u\nSET date_updated = NOW()\nWHERE u.id = {{ $('Mapping').first().json.chatwoot.contact_id }};\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        2560,
        860
      ],
      "id": "61d40015-8562-4c5c-8d0c-986331c5f838",
      "name": "Add Conversation Info"
    },
    {
      "parameters": {
        "dataToSave": {
          "values": [
            {
              "key": "lastWorkflow",
              "value": "[Anna] Consumer"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executionData",
      "typeVersion": 1,
      "position": [
        200,
        220
      ],
      "id": "2cfe234b-939d-47a8-bcc2-bd3fae7e5c7e",
      "name": "Execution Data"
    },
    {
      "parameters": {
        "dataToSave": {
          "values": [
            {
              "key": "lastWorkflow",
              "value": "[Anna] Main Agent"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executionData",
      "typeVersion": 1,
      "position": [
        4440,
        860
      ],
      "id": "0ee9a267-c4a2-499f-97b6-888873673c0b",
      "name": "Execution Data1"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "/agent/main",
        "responseMode": "responseNode",
        "options": {
          "binaryPropertyName": "binaries"
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        4240,
        860
      ],
      "id": "2ed8acfa-62e4-40b3-bad7-5e7145292c8f",
      "name": "Main Agent1",
      "webhookId": "d503e6f9-0989-42d5-a598-e268b20c3182"
    },
    {
      "parameters": {
        "content": "# Modelos\nUsar o openRouter para testes de modelos e trocar o modelo em produção.",
        "height": 300,
        "width": 540,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        3820,
        1720
      ],
      "typeVersion": 1,
      "id": "c53b87b6-1b3b-4c84-8e90-4e47c06aa332",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "model": "gpt-4.1-mini",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        4060,
        1860
      ],
      "id": "19c5e144-454e-4859-bf45-3881a8e89235",
      "name": "Openai"
    },
    {
      "parameters": {
        "model": "gemma2-9b-it",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGroq",
      "typeVersion": 1,
      "position": [
        4220,
        1860
      ],
      "id": "676a404e-5e8d-4b1d-946d-9b8a29fbc820",
      "name": "Groq"
    },
    {
      "parameters": {
        "dataToSave": {
          "values": [
            {
              "key": "lastWorkflow",
              "value": "[Anna] Main Agent"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executionData",
      "typeVersion": 1,
      "position": [
        180,
        1840
      ],
      "id": "7702c187-8c10-4476-a39c-44d498995af4",
      "name": "Execution Data2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://{{$('Mapping').first().json.system.n8n_webhook_service}}:5678/webhook/{{ $('Mapping').first().json.system.workflow_path }}",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $json.content ?  $json.content :\n    $input.all()\n      .map(item => item.json?.content)\n      .filter(content => content)\n      .join('\\n\\n') || \"Sem contexto em texto.\"\n}}"
            },
            {
              "name": "mapping",
              "value": "={{JSON.stringify($('Mapping').first().json) }}"
            },
            {
              "name": "files",
              "value": "={{ $input.all().map(item => item.json.binaries) || [] }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        600,
        760
      ],
      "id": "70af2276-df6f-4d11-a135-d2c7e1cdde59",
      "name": "Call Agent Main",
      "executeOnce": true,
      "notesInFlow": true,
      "notes": "Chama o agente principal"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://{{ $('Main Agent1').first().json.body.mapping.parseJson().system.n8n_webhook_service}}:5678/webhook/agent/knowledge",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $('Main Agent1').first().json.body.mapping.parseJson().chatwoot.content ?? $input.all()\n        .map(item => item.json.content)\n        .filter(content => content)\n        .join('\\n\\n') }}"
            },
            {
              "name": "mapping",
              "value": "={{ $('Main Agent1').first().json.body.mapping }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4840,
        960
      ],
      "id": "9dab96db-75c5-444a-b341-eddcd7a38d59",
      "name": "Call Agent Rag",
      "executeOnce": true,
      "notesInFlow": true,
      "notes": "Chama o agente principal"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {
          "includeUnpaired": true
        }
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        5020,
        860
      ],
      "id": "fc50bbce-ef86-44d9-8a37-455d9bf2b860",
      "name": "Merge"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "main",
                    "rightValue": "main",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "b746f04a-ab1b-44de-bde2-6eae85e7b6cf"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "main"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "2f483833-145f-43e4-a8bd-99f55eb0b523",
                    "leftValue": "={{ $('Main Agent1').item.json.body.mapping.parseJson().system.enabled_rag  }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "rag"
            }
          ]
        },
        "options": {
          "allMatchingOutputs": true
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        4640,
        860
      ],
      "id": "774bef42-39a8-4c9a-8c4e-8cb69021627d",
      "name": "Agents"
    },
    {
      "parameters": {
        "fieldToSplitOut": "body.files",
        "options": {
          "destinationFieldName": "binary",
          "includeBinary": false
        }
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        5220,
        860
      ],
      "id": "f42cb0e3-0d82-4342-9584-518a91c1a4d5",
      "name": "Split Base64",
      "executeOnce": false,
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "a699652f-1f2d-4be5-b011-87f0f640faed",
              "leftValue": "={{ $('Main Agent1').item.json.body.files }}",
              "rightValue": "",
              "operator": {
                "type": "array",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        5440,
        860
      ],
      "id": "dc5aa720-5121-4443-8b78-fcb68cea669c",
      "name": "Binary Exists?"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        6040,
        860
      ],
      "id": "7a73eadb-3093-429e-bd0a-102a2be6b695",
      "name": "Merge Binaries",
      "alwaysOutputData": true,
      "notesInFlow": true,
      "executeOnce": true,
      "notes": "Junta os binarios"
    },
    {
      "parameters": {
        "jsCode": "const mergedItem = { binary: {}};\n\n// Coleta todos os binários de todos os itens sem manipulação\n$input.all().forEach((inputItem) => {\n  if (inputItem.binary) {\n    Object.assign(mergedItem.binary, inputItem.binary);\n  }\n});\n\n// Retorna um único item com todos os binários\nreturn [mergedItem];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5840,
        760
      ],
      "id": "62492c55-3f79-45ad-8b33-07e89836f294",
      "name": "Binaries"
    },
    {
      "parameters": {
        "operation": "toBinary",
        "sourceProperty": "binary",
        "binaryPropertyName": "=data{{ $itemIndex }}",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        5640,
        760
      ],
      "id": "ae5e606a-a352-495c-a87e-a602f6521c2b",
      "name": "Convert",
      "notesInFlow": true,
      "notes": "Converte texto em binário"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('Main Agent1').first().json.body.mapping.parseJson().chatwoot.content || \" \"  }}",
        "options": {
          "systemMessage": "=You are a helpful assistant\n\nNunca use hiperlinks\n\n<system_information>\n1. Data e hora atuais: {{ $now.format(\"EEE, MMM dd, yyyy, HH:mm\") }}\n</system_information>\n\n<retrieval_augmented_generation_result>\n{{ \n  $('Call Agent Rag').isExecuted\n      ? $('Call Agent Rag').first().json.output\n      : \"Rag desativado\" \n}}\n\n</retrieval_augmented_generation_result>\n\n<prompt>\n  {{ $('Main Agent1').first().json.body.mapping.parseJson().system.system_message }}\n</prompt>",
          "passthroughBinaryImages": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        6240,
        860
      ],
      "id": "e6052d0d-5020-4e7f-8118-06544f6145ac",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "operation": "binaryToPropery",
        "binaryPropertyName": "=data{{ $itemIndex }}",
        "destinationKey": "binaries",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        400,
        760
      ],
      "id": "ec13a1e2-1096-4560-86af-c2c3e6820591",
      "name": "Transform File In Text"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.2,
      "position": [
        6600,
        860
      ],
      "id": "5e7ce4f9-3b7e-4f90-9e98-c6c9b70d06ff",
      "name": "Respond "
    }
  ],
  "connections": {
    "Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Add to List": {
      "main": [
        [
          {
            "node": "Get List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get List": {
      "main": [
        [
          {
            "node": "Switch 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON": {
      "main": [
        [
          {
            "node": "Split Itens",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop": {
      "main": [
        [
          {
            "node": "Transform File In Text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Itens": {
      "main": [
        [
          {
            "node": "Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Media": {
      "main": [
        [
          {
            "node": "Switch 02",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 02": {
      "main": [
        [
          {
            "node": "Transcription",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Convert PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset List": {
      "main": [
        [
          {
            "node": "Message Segment Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Final List 2": {
      "main": [
        [
          {
            "node": "Switch 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Final List 1": {
      "main": [
        [
          {
            "node": "Parse JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cooldown": {
      "main": [
        [
          {
            "node": "Get List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Consumer": {
      "main": [
        [
          {
            "node": "Execution Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 3": {
      "main": [
        [
          {
            "node": "No Operation ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Reset List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Vars": {
      "main": [
        [
          {
            "node": "Downtime",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert PDF": {
      "main": [
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transcription": {
      "main": [
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear History": {
      "main": [
        [
          {
            "node": "Parse JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restart History": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Switch 2": {
      "main": [
        [
          {
            "node": "Download Media",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Keep Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 1": {
      "main": [
        [
          {
            "node": "No Operation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Final List 1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Cooldown",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 0": {
      "main": [
        [
          {
            "node": "Update History",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Add to List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Keep Loop": {
      "main": [
        [
          {
            "node": "Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update History": {
      "main": [
        [
          {
            "node": "Open Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Timer": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Knowledge Trigger": {
      "main": [
        [
          {
            "node": "Get Global Vars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Global Vars": {
      "main": [
        [
          {
            "node": "Process Docs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Trigger": {
      "main": [
        [
          {
            "node": "Parse JSON 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON 2": {
      "main": [
        [
          {
            "node": "Split Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Vectors": {
      "main": [
        [
          {
            "node": "Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings": {
      "main": [
        [
          {
            "node": "Add Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG Input": {
      "main": [
        [
          {
            "node": "Execution Data2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retriever": {
      "ai_tool": [
        [
          {
            "node": "RAG Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Mapping": {
      "main": [
        [
          {
            "node": "Switch 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation ": {
      "main": [
        [
          {
            "node": "Clear History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Downtime": {
      "main": [
        [
          {
            "node": "Mapping",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation 0": {
      "main": [
        [
          {
            "node": "Keep Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Trigger": {
      "main": [
        [
          {
            "node": "Get Dimensions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Dimensions": {
      "main": [
        [
          {
            "node": "Update Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG Agent": {
      "main": [
        [
          {
            "node": "No Operation 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get History": {
      "main": [
        [
          {
            "node": "RAG Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clickup": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Google Calendar": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Agent Calendar": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Envia Chatwoot Text": {
      "main": [
        [
          {
            "node": "No Operation, do nothing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response Format": {
      "main": [
        [
          {
            "node": "Envia Chatwoot Text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Text To Speech ElevenLabs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Messages": {
      "main": [
        [
          {
            "node": "Add Conversation Info",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Delay Before Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Chatwoot Media": {
      "main": [
        [
          {
            "node": "Delay After Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delay Before Message": {
      "main": [
        [
          {
            "node": "Response Format",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delay After Message": {
      "main": [
        [
          {
            "node": "Loop Messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Text To Speech ElevenLabs": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation, do nothing": {
      "main": [
        [
          {
            "node": "Delay After Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OutputParser": {
      "ai_outputParser": [
        [
          {
            "node": "Message Segment Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Split Messages": {
      "main": [
        [
          {
            "node": "Loop Messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message Segment Agent": {
      "main": [
        [
          {
            "node": "Split Messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to File": {
      "main": [
        [
          {
            "node": "Send Chatwoot Media",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execution Data": {
      "main": [
        [
          {
            "node": "Get Vars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Main Agent1": {
      "main": [
        [
          {
            "node": "Execution Data1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execution Data1": {
      "main": [
        [
          {
            "node": "Agents",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Openai": {
      "ai_languageModel": [
        [
          {
            "node": "Message Segment Agent",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "RAG Agent",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Execution Data2": {
      "main": [
        [
          {
            "node": "Get History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Agent Main": {
      "main": [
        [
          {
            "node": "Get Final List 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Agent Rag": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Split Base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agents": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Call Agent Rag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Base64": {
      "main": [
        [
          {
            "node": "Binary Exists?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Binary Exists?": {
      "main": [
        [
          {
            "node": "Convert",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Binaries",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Binaries": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Binaries": {
      "main": [
        [
          {
            "node": "Merge Binaries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert": {
      "main": [
        [
          {
            "node": "Binaries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Respond ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform File In Text": {
      "main": [
        [
          {
            "node": "Call Agent Main",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "b2811a77-1502-41a5-b41b-b62e63627a43",
  "triggerCount": 0,
  "tags": [
    {
      "createdAt": "2025-05-30T17:26:54.137Z",
      "updatedAt": "2025-05-30T17:26:54.137Z",
      "id": "LRORuWhx0wCsNKeV",
      "name": "v2.1.6-correcao"
    }
  ]
}