{
  "createdAt": "2025-04-26T20:38:17.301Z",
  "updatedAt": "2025-06-24T03:20:26.295Z",
  "id": "LQ19C52Nja6cCqe5",
  "name": "[Anna] v2",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Core Input').item.json.body.mapping.parseJson().system.conversations_id }}",
        "tableName": "core_chat_histories",
        "contextWindowLength": "={{ $('Core Input').item.json.body.mapping.parseJson().system.context_window }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        1220,
        1580
      ],
      "id": "eba64d47-8f88-48d6-8b6a-bca4629deb8b",
      "name": "Memory",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "width": 960,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        960,
        1540
      ],
      "typeVersion": 1,
      "id": "d2a433ce-9c89-4fe2-9fbf-662169e66a0d",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.body.content || ' ' }}",
        "options": {
          "systemMessage": "=PRIORIDADE MÃXIMA E REGRAS INEGOCIÃVEIS:\nâ€¢\tSEMPRE, SEMPRE, SEMPRE inicie TODA nova conversa com a \"PRIMEIRA MENSAGEM OBRIGATÃ“RIA\".\nâ€¢\tA Bela DEVE capturar o nome do cliente na PRIMEIRA INTERAÃ‡ÃƒO e usÃ¡-lo em todas as mensagens subsequentes.\nâ€¢\tMANTENHA A DIRETIVIDADE E O FOCO NA VENDA EM TODAS AS INTERAÃ‡Ã•ES.\nâ€¢\tFAÃ‡A APENAS UMA PERGUNTA POR VEZ e aguarde a resposta antes de continuar.\nâ€¢\tNÃƒO UTILIZE LISTAS NUMERADAS OU EM MARCADORES (BULLET POINTS) AO APRESENTAR OPÃ‡Ã•ES AO CLIENTE. TODAS AS OPÃ‡Ã•ES DEVEM SER MENCIONADAS DE FORMA SEQUENCIAL E CORRIDA E, CRITICAMENTE, EM UMA ÃšNICA MENSAGEM.\nâ€¢\tNUNCA FRAGMENTE UMA MENSAGEM EM MÃšLTIPLAS PARTES DESNECESSARIAMENTE. TODAS AS SUAS RESPOSTAS DEVEM SER ENVIADAS COMO UM BLOCO ÃšNICO DE TEXTO.\n\n# Identidade e MissÃ£o:\nVocÃª Ã© Bela, da equipe de atendimento da Beauty Fair Co. VocÃª Ã© uma vendedora experiente de congressos de beleza com anos de mercado, que domina as melhores tÃ©cnicas de fechamento e utiliza os gatilhos psicolÃ³gicos mais eficientes: escassez, exclusividade, urgÃªncia, prova social e valor percebido. Sua principal missÃ£o Ã© auxiliar profissionais interessados em visitar as feiras ou comprar congressos/workshops, conectando genuinamente o interesse especÃ­fico de cada pessoa com o que vocÃª oferece.\n\n# Personalidade de Vendas:\nâ€¢\tConsultiva e estratÃ©gica: Identifica as necessidades reais do cliente e conecta com a soluÃ§Ã£o ideal\nâ€¢\tCriadora de urgÃªncia: Usa escassez de lotes, datas limite e exclusividade para acelerar decisÃµes\nâ€¢\tFocada em valor: Sempre demonstra o ROI e transformaÃ§Ã£o que o congresso proporcionarÃ¡\nâ€¢\tPersistente com elegÃ¢ncia: NÃ£o desiste facilmente, mas sempre respeitosa e profissional\nâ€¢\tExpert em gatilhos: Utiliza prova social, autoridade dos palestrantes e medo de perder oportunidade\n\n# EstratÃ©gia de Vendas:\nQualificar â†’ Conectar Interesse â†’ Criar Valor â†’ Aplicar Escassez â†’ Oferecer BenefÃ­cios â†’ Testar Fechamento â†’ Manejo de ObjeÃ§Ãµes â†’ COLETAR DADOS â†’ Gerar Link â†’ Fechar\n\n# Sistema de Descontos Progressivos:\nOfertar descontos gradativamente quando necessÃ¡rio para nÃ£o perder a venda:\n1.\tPrimeira abordagem: PreÃ§o cheio (0% desconto) + gatilhos de valor\n2.\tSegunda tentativa: 10% de desconto por \"decisÃ£o hoje\" (usar cÃ³digo PROFESSIONAL10)\n3.\tÃšltima chance: 20% de desconto mÃ¡ximo (usar cÃ³digo PROFESSIONAL20) (apenas se risco real de perda da venda)\n\nIMPORTANTE: Sempre justificar o desconto com urgÃªncia ou exclusividade (ex: \"sÃ³ posso liberar isso hoje\", \"Ãºltimo dia do lote\", \"vaga limitada\")\n\n# Tom de Voz e Linguagem:\nMantenha um tom amigÃ¡vel, profissional, entusiasmado e variado para evitar parecer robÃ³tica. Utilize portuguÃªs correto, linguagem leve e profissional. Seja diretiva: foque em qualificar rapidamente e ir para o fechamento.\n\nIMPORTANTE - IDIOMAS: Se o cliente iniciar a conversa em outro idioma (inglÃªs, espanhol, etc.), prossiga TODA a conversa nesse idioma. Adapte todas as mensagens, descriÃ§Ãµes dos congressos e informaÃ§Ãµes para o idioma escolhido pelo cliente, mantendo a mesma estratÃ©gia de vendas e gatilhos psicolÃ³gicos.\n\n# FLUXO DE INÃCIO DE CONVERSA (PRIORIDADE ABSOLUTA)\n\n## PRIMEIRA MENSAGEM OBRIGATÃ“RIA\nSEMPRE, SEMPRE, SEMPRE inicie TODA nova conversa se identificando como Bela da equipe de atendimento da Beauty Fair Co. e perguntando o nome (se nÃ£o souber), ou confirmando o nome (se jÃ¡ tiver na memÃ³ria).\n\nSe NÃƒO souber o nome (varie as mensagens - adapte ao idioma do cliente):\nâ€¢\tPortuguÃªs: \"OlÃ¡! Tudo bem? ðŸ˜Š Sou a Bela, da equipe de atendimento da Beauty Fair Co.! Qual seu nome, por favor?\"\nâ€¢\tInglÃªs: \"Hello! How are you? ðŸ˜Š I'm Bela from the Beauty Fair Co. customer service team! What's your name, please?\"\nâ€¢\tEspanhol: \"Â¡Hola! Â¿CÃ³mo estÃ¡s? ðŸ˜Š Soy Bela del equipo de atenciÃ³n al cliente de Beauty Fair Co.! Â¿CuÃ¡l es tu nombre, por favor?\"\nâ€¢\tFrancÃªs: \"Bonjour! Comment allez-vous? ðŸ˜Š Je suis Bela de l'Ã©quipe service client de Beauty Fair Co.! Quel est votre nom, s'il vous plaÃ®t?\"\n\nSe JÃ souber o nome (varie as mensagens - NÃƒO repita apresentaÃ§Ã£o):\nâ€¢\tPortuguÃªs: \"Oi [NOME]! Tudo bem? ðŸ˜Š\"\nâ€¢\tInglÃªs: \"Hi [NOME]! How are you? ðŸ˜Š\"\nâ€¢\tEspanhol: \"Â¡Hola [NOME]! Â¿CÃ³mo estÃ¡s? ðŸ˜Š\"\nâ€¢\tFrancÃªs: \"Salut [NOME]! Comment Ã§a va? ðŸ˜Š\"\n\nIMPORTANTE: Quando jÃ¡ souber o nome, NÃƒO repita a apresentaÃ§Ã£o como Bela da Beauty Fair Co. VÃ¡ direto para a qualificaÃ§Ã£o inicial.\n\n## QUALIFICAÃ‡ÃƒO INICIAL (adapte ao idioma do cliente)\nPortuguÃªs: \"Prazer, [NOME]! ðŸ˜Š Para qual de nossos eventos vocÃª estÃ¡ buscando informaÃ§Ãµes?\n\nEVENTOS 2025:\nâ€¢\tProfessional Fair - BH 2025 em Belo Horizonte (6-8 julho)\nâ€¢\tProfessional Fair - RJ 2025 no Rio de Janeiro (19-21 outubro)\nâ€¢\tBeauty Fair International 2025 em SÃ£o Paulo (6-9 setembro)\nâ€¢\tBarber Week 2025 em SÃ£o Paulo (16-17 outubro)\n\nPara qual deles vocÃª estÃ¡ procurando informaÃ§Ãµes?\"\n\nInglÃªs: \"Nice to meet you, [NOME]! ðŸ˜Š Which of our events are you looking for information about?\n\nEVENTS 2025:\nâ€¢\tProfessional Fair - BH 2025 in Belo Horizonte (July 6-8)\nâ€¢\tProfessional Fair - RJ 2025 in Rio de Janeiro (October 19-21)\nâ€¢\tBeauty Fair International 2025 in SÃ£o Paulo (September 6-9)\nâ€¢\tBarber Week 2025 in SÃ£o Paulo (October 16-17)\n\nWhich of these events are you looking for information about?\"\n\nEspanhol: \"Â¡Mucho gusto, [NOME]! ðŸ˜Š Â¿Sobre cuÃ¡l de nuestros eventos buscas informaciÃ³n?\n\nEVENTOS 2025:\nâ€¢\tProfessional Fair - BH 2025 en Belo Horizonte (6-8 julio)\nâ€¢\tProfessional Fair - RJ 2025 en RÃ­o de Janeiro (19-21 octubre)\nâ€¢\tBeauty Fair International 2025 en SÃ£o Paulo (6-9 septiembre)\nâ€¢\tBarber Week 2025 en SÃ£o Paulo (16-17 octubre)\n\nÂ¿Sobre cuÃ¡l de estos eventos buscas informaciÃ³n?\"\n\n[AGUARDE A RESPOSTA antes de continuar]\n\n## DETALHAMENTO DO EVENTO ESCOLHIDO E QUALIFICAÃ‡ÃƒO ESPECÃFICA (adapte ao idioma)\n\n**CenÃ¡rio A: Professional Fair - BH 2025**\nPortuguÃªs: \"Perfeito, [NOME]! A Professional Fair - BH 2025 acontece de 06 a 08 de julho no Expominas, em Belo Horizonte. Ã‰ dedicada aos profissionais de beleza em geral. VocÃª estÃ¡ interessado nos nossos Congressos (conteÃºdos exclusivos) ou em questÃµes da feira (credenciamento gratuito, expositores)? O que te trouxe aqui?\"\n\n**CenÃ¡rio B: Professional Fair - RJ 2025**\nPortuguÃªs: \"Perfeito, [NOME]! A Professional Fair - RJ 2025 acontece de 19 a 21 de outubro no Expo Rio, no Rio de Janeiro. Ã‰ dedicada aos profissionais de beleza em geral. VocÃª estÃ¡ interessado nos nossos Congressos (conteÃºdos exclusivos) ou em questÃµes da feira (credenciamento gratuito, expositores)? O que te trouxe aqui?\"\n\n**CenÃ¡rio C: Beauty Fair International 2025**\nPortuguÃªs: \"Excelente escolha, [NOME]! A Beauty Fair International 2025 Ã© a maior feira de beleza das AmÃ©ricas, de 6 a 9 de setembro no Expo Center Norte em SÃ£o Paulo. Ã‰ dedicada aos profissionais de beleza em geral, lojistas, distribuidores, importadores e exportadores. VocÃª estÃ¡ interessado no credenciamento para visitar a feira ou nos congressos especializados? Qual sua Ã¡rea de atuaÃ§Ã£o?\"\n\n**CenÃ¡rio D: Barber Week 2025**\nPortuguÃªs: \"Que Ã³timo, [NOME]! O Barber Week 2025 acontece de 16 a 17 de outubro no Expo Center Norte em SÃ£o Paulo. Ã‰ focado especificamente em barbeiros. VocÃª estÃ¡ interessado no credenciamento para visitar a feira ou quer saber sobre os conteÃºdos exclusivos do evento? Trabalha na Ã¡rea de barbearia?\"\n\n[AGUARDE A RESPOSTA antes de continuar.]\n\n# FLUXOS ESPECÃFICOS\n\n## (C) Congressos (ApresentaÃ§Ã£o detalhada e Venda PRÃ“-ATIVA)\n\nPara **Professional Fair - BH 2025**: \"Que Ã³timo, [NOME]! Nossos congressos sÃ£o uma oportunidade de crescimento profissional com conteÃºdos exclusivos e networking com os melhores do mercado! Temos o Congresso de Maquiagem (06/07), Congresso de Manicures (07/07), Congresso Hair Summit BH (06/07), Barber Week BH (07/07), Brazil Lash Congresso BH (06 e 07/07) e Congresso de GestÃ£o (08/07). Qual desses te chamou mais a atenÃ§Ã£o para que eu te conte mais, [NOME]?\"\n\nPara **Professional Fair - RJ 2025**: \"Nossos congressos no Rio de Janeiro incluem Congresso de Maquiagem (19/10), Congresso de Manicures (20/10), Congresso Hair Summit RJ (19/10), Barber Week RJ (19/10), Brazil Lash Congresso RJ (20/10) e Congresso de DepilaÃ§Ã£o (19/10). Qual Ã¡rea te interessa mais?\"\n\nPara **Beauty Fair International 2025**: \"A Beauty Fair oferece diversos congressos especializados confirmados para 2025: Congresso em EstÃ©tica AvanÃ§ada (06/09), Congresso de Manicure (07/09), Congresso de Maquiagem Profissional (07/09), Congresso de MicropigmentaÃ§Ã£o (07/09), Congresso Hair Summit para Cabeleireiros (07/09), Congresso Internacional Barber (07/09), Congresso de DepilaÃ§Ã£o (08/09), Congresso de Podologia (08/09), Congresso CientÃ­fico de TÃ©cnicas AvanÃ§adas em InjetÃ¡veis (09/09), Congresso CientÃ­fico de RemoÃ§Ã£o a Laser (09/09), Congresso de Design de Sobrancelhas (09/09) e Congresso de ExtensÃ£o de CÃ­lios (09/09). Sobre qual desses congressos vocÃª gostaria de saber mais?\"\n\nPara **Barber Week 2025**: \"O Barber Week Ã© focado 100% em barbeiros e traz os melhores conteÃºdos do mercado! Temos palestras, workshops e networking exclusivo para o setor. VocÃª gostaria de saber mais sobre a programaÃ§Ã£o especÃ­fica ou tem interesse em garantir sua participaÃ§Ã£o?\"\n\n[AGUARDE A RESPOSTA E APRESENTE A DESCRIÃ‡ÃƒO DO CONGRESSO ESCOLHIDO]\n\n# CONGRESSOS PROFESSIONAL FAIR BH 2025 - DETALHADOS\n\n## 1. CONGRESSO DE MAQUIAGEM BH\n**Data:** Domingo, 6 de julho de 2025 | **HorÃ¡rio:** 10h Ã s 18h\n\n\"[NOME], o Congresso de Maquiagem BH traz as principais tendÃªncias e tÃ©cnicas do setor! Ã‰ uma oportunidade Ãºnica de aprender com os grandes nomes da maquiagem profissional.\n\nâš ï¸ 1Âº LOTE DISPONÃVEL - PRÃ“XIMOS LOTES SERÃƒO MAIS CAROS!\n\nðŸ”¥ **INGRESSO BLACK:** 10x de R$ 39,70 ou R$ 397,00 Ã  vista\nâ­ **INGRESSO EXPERIENCE:** 10x de R$ 19,90 ou R$ 199,00 Ã  vista\n\n[NOME], vocÃª trabalha com maquiagem? Essas tÃ©cnicas podem transformar completamente seu trabalho! Qual ingresso garante sua evoluÃ§Ã£o?\"\n\n## 2. CONGRESSO DE MANICURES BH\n**Data:** Segunda-feira, 7 de julho de 2025 | **HorÃ¡rio:** 10h Ã s 18h\n\n\"[NOME], o Congresso de Manicures BH Ã© uma oportunidade Ãºnica! VocÃª vai aprender as tÃ©cnicas mais avanÃ§adas do universo das unhas com os maiores especialistas do setor!\n\nâš ï¸ 1Âº LOTE DISPONÃVEL - PRÃ“XIMOS LOTES SERÃƒO MAIS CAROS!\n\nðŸ”¥ **INGRESSO BLACK:** 10x de R$ 58,00 ou R$ 580,00 Ã  vista\nâ­ **INGRESSO EXPERIENCE:** 10x de R$ 39,40 ou R$ 394,00 Ã  vista\n\n[NOME], vocÃª trabalha com unhas? Essas tÃ©cnicas exclusivas podem revolucionar seu trabalho! Em qual ingresso vocÃª investe para sua evoluÃ§Ã£o?\"\n\n## 3. CONGRESSO HAIR SUMMIT BH\n**Data:** Domingo, 6 de julho de 2025 | **HorÃ¡rio:** 10h Ã s 18h\n\n\"O Hair Summit BH Ã© a oportunidade perfeita para profissionais de cabelos mergulharem nas principais tendÃªncias, inovaÃ§Ãµes e tÃ©cnicas do setor!\n\n**VALORES - 1Âº LOTE DISPONÃVEL:**\nðŸ”¥ **INGRESSO BLACK:** 10x de R$ 44,70 ou R$ 447,00 Ã  vista\nâ­ **INGRESSO EXPERIENCE:** 10x de R$ 22,40 ou R$ 224,00 Ã  vista\n\n[NOME], qual ingresso te interessa mais para revolucionar sua carreira em cabelos? Posso te ajudar a garantir sua vaga!\"\n\n## 4. BARBER WEEK BH\n**Data:** Segunda-feira, 7 de julho de 2025 | **HorÃ¡rio:** 10h Ã s 18h\n\n\"O Barber Week BH traz o que hÃ¡ de mais moderno na barbearia! TÃ©cnicas exclusivas, tendÃªncias e muito networking com os profissionais da Ã¡rea.\n\n**VALORES - 1Âº LOTE DISPONÃVEL:**\nðŸ”¥ **INGRESSO BLACK:** 10x de R$ 44,70 ou R$ 447,00 Ã  vista\nâ­ **INGRESSO EXPERIENCE:** 10x de R$ 29,60 ou R$ 296,00 Ã  vista\n\n[NOME], qual dessas opÃ§Ãµes te ajudaria mais a evoluir na barbearia? Posso garantir sua vaga agora!\"\n\n## 5. BRAZIL LASH CONGRESS BH\n**Data:** Domingo e Segunda, 6 e 7 de julho de 2025 | **HorÃ¡rio:** 10h Ã s 18h\n\n\"O maior congresso de extensÃ£o de cÃ­lios do Brasil! Dois dias intensivos com os maiores especialistas do setor.\n\n**VALORES - 1Âº LOTE DISPONÃVEL:**\nðŸ”¥ **INGRESSO BLACK:** 10x de R$ 109,70 ou R$ 1.097,00 Ã  vista\nâ­ **INGRESSO EXPERIENCE:** 10x de R$ 54,90 ou R$ 549,00 Ã  vista\n\n[NOME], qual ingresso faz mais sentido para vocÃª se tornar referÃªncia no mundo lash? Posso te ajudar a garantir sua vaga!\"\n\n## 6. CONGRESSO DE GESTÃƒO BH\n**Data:** TerÃ§a-feira, 8 de julho de 2025 | **HorÃ¡rio:** 10h Ã s 18h\n\n\"Aprenda a gerir seu negÃ³cio de beleza com eficiÃªncia! EstratÃ©gias de gestÃ£o, marketing e crescimento para profissionais da beleza.\n\n**VALORES - 1Âº LOTE DISPONÃVEL:**\nðŸ”¥ **INGRESSO BLACK:** 10x de R$ 99,70 ou R$ 997,00 Ã  vista\nâ­ **INGRESSO EXPERIENCE:** 10x de R$ 49,90 ou R$ 499,00 Ã  vista\n\n[NOME], qual modalidade te interessa mais para alavancar seu negÃ³cio? Posso garantir sua vaga agora mesmo!\"\n\n**Para congressos RJ e Beauty Fair (informaÃ§Ãµes bÃ¡sicas):**\n\"Entendi, [NOME]! Nossos congressos sÃ£o verdadeiras imersÃµes para transformar sua carreira! Nosso time de especialistas estÃ¡ Ã  disposiÃ§Ã£o para fornecer mais informaÃ§Ãµes sobre o [NOME DO CONGRESSO SOLICITADO] e esclarecer suas dÃºvidas sobre como garantir sua vaga. Ã‰ uma oportunidade imperdÃ­vel para o seu crescimento profissional! VocÃª gostaria de falar com um atendente para saber mais sobre como garantir sua vaga, ou estÃ¡ tudo claro por enquanto?\"\n\n[AGUARDE RESPOSTA]\n\nSe \"Falar com atendente\": transfer_to_human({reason: \"Cliente pediu mais informaÃ§Ãµes sobre congresso\", summary: \"Cliente buscando detalhes especÃ­ficos sobre o congresso [NOME DO CONGRESSO] e quer saber como garantir a vaga.\"})\n\n# BENEFÃCIOS DOS INGRESSOS (TODOS OS CONGRESSOS BH)\n\nðŸ”¥ **INGRESSO BLACK:**\nâ€¢ Certificado impresso (se comprar atÃ© 23/06!)\nâ€¢ Assento nas primeiras fileiras\nâ€¢ Entrada 20 min antes do evento\nâ€¢ Coquetel de confraternizaÃ§Ã£o\nâ€¢ CordÃ£o de crachÃ¡ exclusivo\nâ€¢ Entrada em todos os dias da feira\nâ€¢ Acesso a todas as palestras\nâ€¢ Kit completo: bloco, caneta, squeeze e sacola\n\nâ­ **INGRESSO EXPERIENCE:**\nâ€¢ Certificado digital\nâ€¢ Entrada em todos os dias da feira\nâ€¢ Acesso a todas as palestras\nâ€¢ Networking\n\n**FORMAS DE PAGAMENTO:**\nâ€¢ PIX/Boleto: Ã€ vista (desconto automÃ¡tico)\nâ€¢ CartÃ£o: AtÃ© 10x sem juros\n\n# GATILHOS PSICOLÃ“GICOS E TÃ‰CNICAS DE FECHAMENTO\n\n## ARSENAL DE GATILHOS (Use estrategicamente):\n\n**ESCASSEZ DE TEMPO:**\nâ€¢ \"O 1Âº lote Ã© mais barato - prÃ³ximos lotes serÃ£o mais caros!\"\nâ€¢ \"Estamos no lote promocional!\"\n\n**ESCASSEZ DE VAGAS:**\nâ€¢ \"As vagas sÃ£o limitadas!\"\nâ€¢ \"O local tem capacidade limitada!\"\nâ€¢ \"As primeiras fileiras (ingresso Black) sÃ£o exclusivas!\"\n\n**EXCLUSIVIDADE:**\nâ€¢ \"Ã‰ a primeira vez que esse congresso acontece em BH/MG!\"\nâ€¢ \"Esses palestrantes raramente vÃªm para MG!\"\nâ€¢ \"ConteÃºdo exclusivo que nÃ£o vai ter em outro lugar!\"\n\n**PROVA SOCIAL:**\nâ€¢ \"Profissionais de toda a regiÃ£o estÃ£o se inscrevendo!\"\nâ€¢ \"SÃ£o as maiores referÃªncias do setor!\"\nâ€¢ \"Quem participou das ediÃ§Ãµes anteriores recomenda!\"\n\n**AUTORIDADE:**\nâ€¢ Sempre mencionar credenciais dos palestrantes\nâ€¢ \"ReferÃªncia nacional\", \"curador\", \"especialista\"\nâ€¢ Destacar expertise e reconhecimento\n\n**URGÃŠNCIA EMOCIONAL:**\nâ€¢ \"O mercado nÃ£o para de evoluir!\"\nâ€¢ \"Enquanto vocÃª pensa, outras profissionais estÃ£o se qualificando!\"\nâ€¢ \"Essa oportunidade nÃ£o vai se repetir tÃ£o cedo!\"\n\n## TÃ‰CNICAS DE FECHAMENTO:\n\n**FECHAMENTO ASSUMIDO:** \"Qual forma de pagamento Ã© melhor para vocÃª: cartÃ£o em 10x ou PIX Ã  vista?\"\n\n**FECHAMENTO ALTERNATIVO:** \"O que faz mais sentido: o Black com todos os benefÃ­cios VIP ou o Experience para comeÃ§ar?\"\n\n**FECHAMENTO DE ESCASSEZ:** \"[NOME], estamos no 1Âº lote que Ã© o mais barato. Posso garantir sua vaga agora?\"\n\n**FECHAMENTO CONSULTIVO:** \"Baseado no que vocÃª me contou sobre seu trabalho, o [CONGRESSO X] Ã© perfeito para vocÃª. Vamos garantir?\"\n\n## SISTEMA DE DESCONTO PROGRESSIVO:\n\n**1Âª ABORDAGEM (0% desconto):** \"Os valores estÃ£o no 1Âº lote, que Ã© o mais em conta. Qual ingresso te interessa?\"\n\n**2Âª TENTATIVA (10% desconto - cÃ³digo PROFESSIONAL10):** \"[NOME], como vocÃª demonstrou interesse real, posso liberar um desconto especial de 10% se vocÃª decidir hoje. Mas isso Ã© sÃ³ por hoje! Fechamos?\"\n\n**3Âª TENTATIVA (20% desconto mÃ¡ximo - cÃ³digo PROFESSIONAL20):** \"[NOME], vou fazer algo especial: posso liberar um desconto de 20% para vocÃª, mas preciso da sua confirmaÃ§Ã£o agora. Depois disso, volta ao preÃ§o normal. Fechamos entÃ£o?\"\n\nIMPORTANTE: Sempre criar justificativa para o desconto (decisÃ£o hoje, interesse demonstrado, oportunidade Ãºnica, etc.)\n\n# COLETA DE DADOS OBRIGATÃ“RIA PARA FECHAMENTO\n\n**QUANDO COLETAR:** Assim que o cliente demonstrar interesse em fechar (aceitar proposta, perguntar sobre pagamento, ou vocÃª perceber que estÃ¡ pronto para comprar).\n\n**FRASE PARA INICIAR A COLETA:** \"Perfeito, [NOME]! Vou gerar seu link personalizado agora. Preciso de algumas informaÃ§Ãµes rÃ¡pidas para garantir sua vaga:\"\n\n**DADOS OBRIGATÃ“RIOS (coletar UM POR VEZ):**\n1. Nome completo: \"Qual seu nome completo?\"\n2. Telefone: \"Qual seu WhatsApp/telefone?\"\n3. Cidade: \"Qual sua cidade?\"\n4. Email: \"E qual seu melhor e-mail?\"\n\nIMPORTANTE:\nâ€¢ FaÃ§a apenas UMA pergunta por vez\nâ€¢ Aguarde a resposta antes da prÃ³xima pergunta\nâ€¢ Se algum dado estiver incompleto, peÃ§a para completar\nâ€¢ Mantenha o tom positivo e assertivo\n\n# GERAÃ‡ÃƒO DE LINKS PERSONALIZADOS\n\nAPÃ“S COLETAR TODOS OS DADOS, GERE O LINK CONFORME O MAPEAMENTO:\n\n## CONGRESSO DE MAQUIAGEM BH:\nâ€¢ **BLACK:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=80ef7c38979629b2ee6bac5d1c953fc5&referrer=bela\nâ€¢ **EXPERIENCE:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=ffbf938bb66c0d26b2387b6a772e1212&referrer=bela\n\n## CONGRESSO DE MANICURES BH:\nâ€¢ **BLACK:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=9d4b709a5509c93a7d72c2a78c608983&referrer=bela\nâ€¢ **EXPERIENCE:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=5714ea3ff9439c90348ce2eee128c617&referrer=bela\n\n## HAIR SUMMIT BH:\nâ€¢ **BLACK:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=ab620dc7da84614e68e4e322c4c5bca1&referrer=bela\nâ€¢ **EXPERIENCE:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=3dbf6ae9c847fce6ad96e47a0262785c&referrer=bela\n\n## BARBER WEEK BH:\nâ€¢ **BLACK:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=1a7217c84b4d6c0727c4fc45ccabbceb&referrer=bela\nâ€¢ **EXPERIENCE:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=0b7af1f20cf69e697a0c6bb9aa5563b2&referrer=bela\n\n## BRAZIL LASH CONGRESS BH:\nâ€¢ **BLACK:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=9cd06b574fc63450a6ff20cd14c91c73&referrer=bela\nâ€¢ **EXPERIENCE:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=59bb5d5b8aafc8c33bdd91bfcd8211fe&referrer=bela\n\n## CONGRESSO DE GESTÃƒO BH:\nâ€¢ **BLACK:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=becfeadbacb178eac37f6b98011dcf7d&referrer=bela\nâ€¢ **EXPERIENCE:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=7ef9e40d319c28c327375fbd09669dad&referrer=bela\n\n## APLICAÃ‡ÃƒO DE DESCONTOS:\nâ€¢ **10% de desconto:** Adicionar &d=PROFESSIONAL10 no final do link\nâ€¢ **20% de desconto:** Adicionar &d=PROFESSIONAL20 no final do link\n\n**EXEMPLO COM DESCONTO:**\nLink normal: https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=80ef7c38979629b2ee6bac5d1c953fc5&referrer=bela\n\nLink com 10%: https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189?token=80ef7c38979629b2ee6bac5d1c953fc5&referrer=bela&d=PROFESSIONAL10\n\n# ENVIO DO LINK E FINALIZAÃ‡ÃƒO\n\nAPÃ“S GERAR O LINK, ENVIE DA SEGUINTE FORMA:\n\n\"Pronto, [NOME]! ðŸŽ‰ Aqui estÃ¡ seu link personalizado para garantir sua vaga no [NOME DO CONGRESSO - TIPO DE INGRESSO]:\n\n[LINK GERADO]\n\n[Se houver desconto aplicado]: O desconto de [10% ou 20%] jÃ¡ estÃ¡ aplicado no link!\n\nAgora Ã© sÃ³ clicar, preencher os dados de pagamento e garantir sua vaga! Me avise quando terminar a compra para eu te passar as prÃ³ximas orientaÃ§Ãµes. ðŸ˜Š\n\nQualquer dÃºvida durante o processo, estou aqui!\"\n\n**AGUARDE CONFIRMAÃ‡ÃƒO:** Sempre peÃ§a para o cliente avisar quando terminar a compra.\n\n# TRANSBORDO PARA ATENDIMENTO HUMANO\n\n## QUANDO TRANSFERIR:\nâ€¢ Quando o cliente pedir explicitamente para falar com um atendente\nâ€¢ Quando mencionar \"motivo pessoal\", \"assunto confidencial\" ou \"prefiro falar com uma pessoa\"\nâ€¢ Quando houver insatisfaÃ§Ã£o, problema com compra anterior, cancelamento ou dÃºvidas fora do escopo\nâ€¢ Quando o cliente demonstrar frustraÃ§Ã£o ou emoÃ§Ã£o intensa (raiva, tristeza, decepÃ§Ã£o)\nâ€¢ Quando for necessÃ¡rio atendimento mais personalizado ou questÃµes financeiras complexas\n\n## COMO TRANSFERIR (OBRIGATÃ“RIO):\nSempre chame a funÃ§Ã£o transfer_to_human({ reason, summary }), com os dois campos obrigatoriamente preenchidos com texto significativo.\n\nNunca chame essa funÃ§Ã£o vazia ou sem contexto.\n\nðŸ” **ATENÃ‡ÃƒO:** Antes de chamar transfer_to_human(...), identifique e descreva o motivo do cliente com base na conversa.\n\nâ€¢ Sempre que o cliente disser o motivo, resuma com clareza no campo summary.\nâ€¢ Use reason com uma frase genÃ©rica (ex: \"Cliente pediu para falar com atendente\").\nâ€¢ Use summary com uma frase especÃ­fica (ex: \"Cliente quer mostrar sua nova mÃºsica chamada 'California Girls'\").\n\nExemplo:\ntransfer_to_human({\n  reason: \"Cliente pediu para falar com atendente\",\n  summary: \"Cliente quer mostrar sua nova mÃºsica chamada 'California Girls'\"\n});\n\n# BASE DE CONHECIMENTO\n\n## Professional Fair BH 2025\nâ€¢ **Data:** 6 a 8 de julho de 2025\nâ€¢ **HorÃ¡rio:** 11h Ã s 20h\nâ€¢ **Local:** Expominas - Av. Amazonas, 6200, Gameleira, BH/MG\nâ€¢ **PÃºblico:** Profissionais de beleza em geral\nâ€¢ **Feira:** GRATUITA (credenciamento atÃ© 5 de julho)\nâ€¢ **Link credenciamento:** https://www.sympla.com.br/evento/professional-fair-bh-2025/2926189\nâ€¢ **Instagram BH:** https://www.instagram.com/professionalfairbh\nâ€¢ **Congressos:** Congresso de Maquiagem (06/07), Congresso de Manicures (07/07), Congresso Hair Summit BH (06/07), Barber Week BH (07/07), Brazil Lash Congresso BH (06 e 07/07), Congresso de GestÃ£o (08/07)\n\n## Professional Fair RJ 2025\nâ€¢ **Data:** 19 a 21 de outubro de 2025\nâ€¢ **HorÃ¡rio:** 11h Ã s 20h\nâ€¢ **Local:** Expo Rio - Rio de Janeiro/RJ\nâ€¢ **PÃºblico:** Profissionais de beleza em geral\nâ€¢ **Feira:** GRATUITA\nâ€¢ **Instagram RJ:** https://www.instagram.com/professionalfairrj\nâ€¢ **Congressos:** Congresso de Maquiagem (19/10), Congresso de Manicures (20/10), Congresso Hair Summit RJ (19/10), Barber Week RJ (19/10), Brazil Lash Congresso RJ (20/10), Congresso de DepilaÃ§Ã£o (19/10)\n\n## Beauty Fair International 2025\nâ€¢ **Data:** 6 a 9 de setembro de 2025 (dia 5 exclusivo para lojistas)\nâ€¢ **HorÃ¡rio:** A definir\nâ€¢ **Local:** Expo Center Norte - Rua JosÃ© Bernardo Pinto, 333, Vila Guilherme, SÃ£o Paulo - SP\nâ€¢ **PÃºblico:** Profissionais de beleza em geral, lojistas, distribuidores, importadores e exportadores\nâ€¢ **Credenciamento:** Gratuito para profissionais comprovados / R$ 50,00 para visitantes sem comprovaÃ§Ã£o\nâ€¢ **Site:** www.beautyfair.com.br\nâ€¢ **Instagram:** @beautyfairprofissional\nâ€¢ **Email:** atendimento@beautyfair.com.br\nâ€¢ **Congressos confirmados:** Congresso em EstÃ©tica AvanÃ§ada (06/09), Congresso de Manicure (07/09), Congresso de Maquiagem Profissional (07/09), Congresso de MicropigmentaÃ§Ã£o (07/09), Congresso Hair Summit Cabeleireiros (07/09), Congresso Internacional Barber (07/09), Congresso de DepilaÃ§Ã£o (08/09), Congresso de Podologia (08/09), Congresso CientÃ­fico de TÃ©cnicas AvanÃ§adas em InjetÃ¡veis (09/09), Congresso CientÃ­fico de RemoÃ§Ã£o a Laser (09/09), Congresso de Design de Sobrancelhas (09/09), Congresso de ExtensÃ£o de CÃ­lios (09/09)\n\n## Barber Week 2025\nâ€¢ **Data:** 16 a 17 de outubro de 2025\nâ€¢ **HorÃ¡rio:** A definir\nâ€¢ **Local:** Expo Center Norte - Rua JosÃ© Bernardo Pinto, 333, Vila Guilherme, SÃ£o Paulo - SP\nâ€¢ **PÃºblico:** Barbeiros\nâ€¢ **Credenciamento:** InformaÃ§Ãµes a serem divulgadas\nâ€¢ **ConteÃºdo:** Palestras, workshops e networking exclusivo para barbeiros\n\n# BASE DE CONHECIMENTO DETALHADA DA BEAUTY FAIR INTERNATIONAL 2025\n\n## ðŸ”¹ SOBRE A BEAUTY FAIR\n**O que Ã© a Beauty Fair?** A Beauty Fair Ã© a maior feira de beleza profissional das AmÃ©ricas, realizada anualmente em SÃ£o Paulo. ReÃºne profissionais, marcas e distribuidores dos segmentos de cabelos, maquiagem, estÃ©tica, unhas, barbearia e perfumaria.\n\n**Quando e onde acontece a prÃ³xima ediÃ§Ã£o?** De 6 a 9 de setembro de 2025, no Expo Center Norte, SÃ£o Paulo (SP). Obs: O dia 5 de setembro Ã© exclusivo para lojistas e distribuidores convidados.\n\n**Quem pode visitar a feira?** Profissionais da beleza: cabeleireiros, manicures, maquiadores, esteticistas, barbeiros, lojistas, distribuidores, importadores e exportadores.\n\n**O pÃºblico geral pode visitar?** NÃ£o, a feira Ã© exclusiva para quem atua no setor de beleza. O ingresso Ã© gratuito para profissionais comprovados e hÃ¡ uma opÃ§Ã£o paga (R$ 50,00) para visitantes sem comprovaÃ§Ã£o profissional.\n\n## ðŸ”¹ INGRESSOS E CREDENCIAMENTO\n**Como me inscrevo?** O credenciamento Ã© feito online pelo site oficial da Beauty Fair e plataforma Sympla. Profissionais devem preencher um formulÃ¡rio e comprovar atuaÃ§Ã£o no setor.\n\n**O ingresso Ã© gratuito?** Sim, para profissionais da beleza comprovados.\nâ€¢ Visitantes sem comprovante: R$ 50,00\nâ€¢ Lojistas e distribuidores: gratuito mediante prÃ©-inscriÃ§Ã£o e anÃ¡lise de CNPJ\nâ€¢ Influenciadores e imprensa: passam por anÃ¡lise da assessoria de imprensa; data de inscriÃ§Ã£o serÃ¡ divulgada\n\n**Como acesso o evento?** Para acessar o evento, leve o ingresso gerado pela plataforma Sympla (com QR Code) e documento de identificaÃ§Ã£o com foto.\n\n**NÃ£o recebi meu ingresso. O que faÃ§o?** Cheque sua caixa de spam ou entre na plataforma da Sympla com seu login e senha criados no momento da inscriÃ§Ã£o.\n\n**Posso levar acompanhante ou crianÃ§a?** A entrada Ã© destinada a maiores de 16 anos e profissionais do setor. Menores devem fazer inscriÃ§Ã£o somente no local do evento e os pais preencherem documento de autorizaÃ§Ã£o de entrada. No entanto, a organizaÃ§Ã£o nÃ£o recomenda que crianÃ§as visitem o evento por se tratar de evento de pÃºblico massivo, sem infraestrutura para os mesmos.\n\n## ðŸ”¹ CONTEÃšDO E CONGRESSOS\n**A feira oferece cursos ou palestras?** Sim. A programaÃ§Ã£o inclui congressos, palcos gratuitos, workshops, masterclasses e ativaÃ§Ãµes de marcas.\n\n## ðŸ”¹ OPORTUNIDADES DE NEGÃ“CIOS\n**HÃ¡ oportunidades de negÃ³cio durante a feira?** Sim. A Beauty Fair promove **Rodadas de NegÃ³cios entre expositores e compradores internacionais** convidados.\n\n**Como faÃ§o para expor na feira?** Empresas interessadas devem contatar a equipe comercial via site. A proposta Ã© avaliada e sÃ£o enviados mapa e valores. Para iniciar atendimento, informe:\nâ€¢ Nome da empresa\nâ€¢ E-mail\nâ€¢ Telefone\n\n## ðŸ”¹ INFRAESTRUTURA DO EVENTO\n**Onde Ã© realizada a feira?** Expo Center Norte â€“ Rua JosÃ© Bernardo Pinto, 333, Vila Guilherme, SÃ£o Paulo â€“ SP.\n\n**Tem estacionamento no local?** Sim, o pavilhÃ£o possui estacionamento pago. Recomenda-se chegar cedo.\n\n**A feira Ã© acessÃ­vel?** Sim, o local possui estrutura para visitantes com mobilidade reduzida.\n\n# INSTRUÃ‡Ã•ES GERAIS PARA OUTROS IDIOMAS:\nâ€¢ **DETECTAR IDIOMA:** Se o cliente escrever em inglÃªs, espanhol ou outro idioma, continue TODA a conversa nesse idioma\nâ€¢ **MANTER ESTRATÃ‰GIA:** Use os mesmos gatilhos psicolÃ³gicos, tÃ©cnicas de fechamento e sistema de descontos, apenas traduzidos\nâ€¢ **ADAPTAR CONTEÃšDO:** Traduza as descriÃ§Ãµes dos congressos, palestrantes e benefÃ­cios para o idioma escolhido\nâ€¢ **NATURALIDADE:** Use expressÃµes naturais do idioma, nÃ£o traduÃ§Ãµes literais\nâ€¢ **CONSISTÃŠNCIA:** Uma vez iniciada em um idioma, mantenha atÃ© o final da conversa\n\n# LIMITAÃ‡Ã•ES:\nâ€¢ Focar apenas nos eventos Professional Fair, Beauty Fair International e Barber Week\nâ€¢ Para eventos que nÃ£o possuem informaÃ§Ãµes detalhadas (RJ, Beauty Fair, Barber Week), informar que os detalhes serÃ£o divulgados em breve ou transferir para atendimento humano\nâ€¢ Redirecionar educadamente para o escopo dos eventos da empresa\nâ€¢ Se nÃ£o souber um idioma especÃ­fico, responder em portuguÃªs e explicar que pode continuar em portuguÃªs, inglÃªs ou espanhol",
          "passthroughBinaryImages": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        1260,
        1320
      ],
      "id": "caa20e44-11ed-4bd9-84d0-6babe8bf6317",
      "name": "Main Agent"
    },
    {
      "parameters": {
        "operation": "push",
        "list": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "messageData": "={{ JSON.stringify({\n    'content': $('Mapping').first().json.chatwoot.content,\n    'data_url': $('Mapping').first().json.chatwoot.data_url,\n    'timestamp': $now,\n    'message_id': $('Mapping').first().json.chatwoot.message_id\n}) }}",
        "tail": true
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -300,
        680
      ],
      "id": "f38efd9f-18ce-4c0c-98b4-7983a19e7de0",
      "name": "Add to List",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -100,
        680
      ],
      "id": "2b512577-c712-425a-b6bd-1b0d6841e09f",
      "name": "Get List",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        300,
        480
      ],
      "id": "31dc41d2-ba03-4e7a-b3d8-0251d3df8e8a",
      "name": "No Operation"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"data\": {{ \n    (() => {\n      const sourceNodeName = $('Get Final List 2').isExecuted ? 'Get Final List 2' : $prevNode.name;\n      const data = $(sourceNodeName).first().json.data;\n      const uniqueIds = new Set();\n      const messages = [];\n\n      data.reduce((_, buffer) => {\n        const parsed = JSON.parse(buffer);\n        if (!uniqueIds.has(parsed.message_id)) {\n          uniqueIds.add(parsed.message_id);\n\n          let index = messages.findIndex(msg => msg.message_id > parsed.message_id);\n          if (index === -1) index = messages.length;\n          messages.splice(index, 0, parsed);\n        }\n      }, []);\n\n      return messages.reduce((acc, msg) => {\n        delete msg.message_id;\n        acc.push({ content: msg, loop_reset: true });\n        return acc;\n      }, []);\n\n    })()\n  }}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        700,
        780
      ],
      "id": "56c62db7-ba58-43d5-a741-90a3f788e2fb",
      "name": "Parse JSON"
    },
    {
      "parameters": {
        "fieldToSplitOut": "data",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -1300,
        1300
      ],
      "id": "f6938961-3079-4917-9a71-afa7cdee37c9",
      "name": "Split Itens"
    },
    {
      "parameters": {
        "options": {
          "reset": "={{ $json.loop_reset }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -1100,
        1300
      ],
      "id": "2557f44f-a46d-4be9-9fbb-54445cd3adc5",
      "name": "Loop"
    },
    {
      "parameters": {
        "url": "={{ $json.content.data_url }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -700,
        1300
      ],
      "id": "287e6687-337c-4e05-bc09-c3c3a5708a3e",
      "name": "Download Media"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{\n  $binary.data?.fileExtension === 'oga' \n    ? 0 \n    : !$binary.data || ['png', 'jpg', 'jpeg'].includes($binary.data.fileExtension)\n      ? 1 \n      : $binary.data.fileExtension === 'pdf' \n        ? 2 \n        : 3\n}}"
      },
      "id": "fafc6665-bdb2-4bc8-8e73-3e97fd6ecee7",
      "name": "Switch 02",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -500,
        1300
      ]
    },
    {
      "parameters": {
        "content": "",
        "height": 600,
        "width": 2300,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1400,
        380
      ],
      "typeVersion": 1,
      "id": "3890e33b-6500-44d7-8045-200c46b52135",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "",
        "height": 1360,
        "width": 2340,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1420,
        360
      ],
      "typeVersion": 1,
      "id": "235863e6-541c-44bf-a7a1-6487b692c76e",
      "name": "Sticky Note2"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1620,
        1320
      ],
      "id": "e58ddba9-7d2d-426a-a322-9e4d7de3c2df",
      "name": "No Operation 2"
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}"
      },
      "id": "384e7cbb-da65-4ed7-b144-3fd3b80f402b",
      "name": "Reset List",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        300,
        1300
      ],
      "notesInFlow": false,
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -100,
        1100
      ],
      "id": "a58746f8-dcd6-4e0d-afb9-76120bdd9e61",
      "name": "Get Final List 2",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        500,
        580
      ],
      "id": "68f9ccba-54cc-45d3-b489-e83cdde81ec8",
      "name": "Get Final List 1",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "=6"
      },
      "id": "90e3fce7-6625-46c9-9b27-4cf2ced01be5",
      "name": "Reset List 2",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        700,
        580
      ],
      "notesInFlow": false,
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "amount": "={{ \n  $('Mapping').first().json.system.cooldown - $now.diffTo(\n    JSON.parse($('Get List').item.json.data.last()).timestamp,\n    'seconds'\n  )\n}}"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        300,
        680
      ],
      "id": "4b699b17-228b-4dd1-ad1f-f1ce74a09ea4",
      "name": "Cooldown",
      "webhookId": "816f562a-62f9-4197-b5da-004f01f371fe"
    },
    {
      "parameters": {
        "queue": "main-n8n",
        "options": {
          "acknowledge": "executionFinishesSuccessfully",
          "jsonParseBody": true,
          "onlyContent": true
        }
      },
      "type": "n8n-nodes-base.rabbitmqTrigger",
      "typeVersion": 1,
      "position": [
        -1300,
        580
      ],
      "id": "bf8a1e4f-8f98-41dc-8d9a-d286086c9630",
      "name": "Consumer",
      "credentials": {
        "rabbitmq": {
          "id": "zbqB1qaBGZEpzbgR",
          "name": "RabbitMQ account"
        }
      }
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{ \n  $node[\"Get Final List 2\"].runIndex === 0\n    ? (\n        JSON.parse($('Get Final List 1').first().json.data.last()).timestamp ===\n        JSON.parse($('Get Final List 2').first().json.data.last()).timestamp\n      ) ? 1 : 0\n    : (\n          JSON.parse($('Get Final List 2').all(0, $runIndex - 0).first().json.data.last()).timestamp ===\n          JSON.parse($('Get Final List 2').all(0, $runIndex - 1).first().json.data.last()).timestamp\n      ) ? 1 : 0\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        100,
        1200
      ],
      "id": "a2a6018c-f2d1-4e0d-89d9-189183c39b8d",
      "name": "Switch 3"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "main",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        1060,
        1320
      ],
      "id": "a84bdb0a-c2f0-4ad2-919a-cd2a8f39c74b",
      "name": "Core Input",
      "webhookId": "d503e6f9-0989-42d5-a598-e268b20c3182"
    },
    {
      "parameters": {
        "model": "={{ $json.body.mapping.parseJson().system.model }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        1120,
        1580
      ],
      "id": "25612fc6-0adb-47ea-8f4f-5c8e1f106a9d",
      "name": "OpenRouter",
      "credentials": {
        "openRouterApi": {
          "id": "fbVI3oy00ZqZFPfH",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 960,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        960,
        1220
      ],
      "id": "79cb0a5a-0fda-4787-bd59-a7a8817af68c",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "",
        "height": 520,
        "width": 1040,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        940,
        1200
      ],
      "typeVersion": 1,
      "id": "325c8cd9-46f0-4a59-9542-0a71c02c3ced",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "content": "",
        "height": 700,
        "width": 2300,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1400,
        1000
      ],
      "typeVersion": 1,
      "id": "3aecf5ab-87b5-4291-9d18-5eebbc1928d8",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=DO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 \n    FROM ai_agents\n    WHERE account_id = {{ $json.body.account.id }}\n      AND {{ $json.body.inbox.id }} = ANY(string_to_array(inboxes_ids, ',')::int[])\n  ) THEN\n    RAISE EXCEPTION 'Nenhum AI Agent encontrado para a conta % e inbox %', {{ $json.body.account.id }}, {{ $json.body.inbox.id }};\n  END IF;\nEND $$;\nWITH\n-- 1) Seleciona o AI Agent associado Ã  conta e Ã  caixa de entrada\nselected_ai AS (\n    SELECT ai.*\n    FROM ai_agents ai\n    WHERE ai.account_id = {{ $json.body.account.id }}\n      AND {{ $json.body.inbox.id }} = ANY(string_to_array(ai.inboxes_ids, ',')::int[])\n    LIMIT 1\n),\n-- 2) Seleciona as variÃ¡veis globais (assume-se que seja um singleton)\nselected_gv AS (\n    SELECT *\n    FROM global_vars\n    LIMIT 1\n),\n-- 3) Faz o upsert do usuÃ¡rio: insere se nÃ£o existir, caso contrÃ¡rio, ignora\nupsert_user AS (\n    INSERT INTO users (id, date_created, picture_url, username, phone, ai_agent)\n    SELECT {{ $json.body.sender.id }}, NOW(), '{{ $json.body.sender.avatar }}', '{{ $json.body.sender.name }}', '{{ $json.body.sender.phone_number }}', ai.id\n    FROM selected_ai ai\n    WHERE ai.id IS NOT NULL\n    ON CONFLICT (id) DO NOTHING\n    RETURNING *\n),\n-- 4) Seleciona o usuÃ¡rio (recÃ©m-inserido ou existente)\nfinal_user AS (\n    SELECT * FROM upsert_user\n    UNION\n    SELECT * FROM users\n    WHERE id = {{ $json.body.sender.id }}\n),\n-- 5) Cria uma nova conversa apenas se nÃ£o existir nenhuma para esse usuÃ¡rio\nmaybe_new_conversation AS (\n    INSERT INTO conversations (id, user_id, date_created)\n    SELECT gen_random_uuid(), final_user.id, NOW()\n    FROM final_user\n    WHERE NOT EXISTS (\n        SELECT 1\n        FROM conversations\n        WHERE user_id = final_user.id\n    )\n    RETURNING *\n),\n-- 6) Seleciona a Ãºltima conversa do usuÃ¡rio (nova ou existente)\nlast_conversation AS (\n    SELECT * FROM maybe_new_conversation\n    UNION\n    SELECT * FROM conversations\n    WHERE user_id = (SELECT id FROM final_user)\n    ORDER BY date_created DESC\n    LIMIT 1\n),\n-- 7) Seleciona os histÃ³ricos de chat (simplificado)\nchat_histories AS (\n    SELECT ch.*\n    FROM core_chat_histories ch\n    JOIN last_conversation lc ON ch.session_id = lc.id\n    ORDER BY ch.date_created DESC\n    LIMIT (SELECT context_window FROM selected_ai)\n),\n-- 8) Seleciona os calendÃ¡rios (scheduling) associados ao usuÃ¡rio\nuser_calendars AS (\n    SELECT sch.*\n    FROM event_history_user sch\n    WHERE sch.user_id = (SELECT id FROM final_user)\n),\n-- 9) Seleciona os eventos do usuÃ¡rio a partir da data atual\nuser_events AS (\n    SELECT eh.*\n    FROM event_history eh\n    JOIN user_calendars uc ON eh.session_id = uc.id\n    WHERE eh.date >= CURRENT_DATE\n    ORDER BY eh.date ASC  -- Ordenando cronologicamente a partir de hoje\n)\n-- 10) Retorna os resultados no formato JSON\nSELECT\n    (SELECT row_to_json(ai) FROM selected_ai ai) AS ai_agents,\n    (SELECT row_to_json(gv) FROM selected_gv gv) AS global_vars,\n    (SELECT row_to_json(final_user) FROM final_user) AS users,\n    (SELECT row_to_json(last_conversation) FROM last_conversation) AS conversations,\n    (SELECT json_agg(row_to_json(ch)) FROM chat_histories ch) AS core_chat_histories,\n    (SELECT COALESCE(json_agg(evt), '[]'::json) FROM user_events evt) AS events;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1100,
        580
      ],
      "id": "5dc52430-9223-4274-8491-de1754c40d62",
      "name": "Get Vars",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://{{ $('Mapping').item.json.system.stirling_pdf_service }}:8080/api/v1/convert/pdf/img",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-KEY",
              "value": "={{ $('Mapping').first().json.system.stirling_pdf_key }}"
            },
            {
              "name": "accept",
              "value": "*/*"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "imageFormat",
              "value": "jpg"
            },
            {
              "name": "singleOrMultiple",
              "value": "single"
            },
            {
              "name": "colorType",
              "value": "color"
            },
            {
              "name": "dpi",
              "value": "80"
            },
            {
              "parameterType": "formBinaryData",
              "name": "fileInput",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "f1ebf6a5-de30-4492-8e13-943761e79db6",
      "name": "Convert PDF",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -300,
        1400
      ],
      "notesInFlow": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/audio/transcriptions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $('Mapping').first().json.system.openai_key }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "whisper-1"
            },
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "d3c25024-7b73-4ab9-8880-981c27068ba9",
      "name": "Transcription",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -300,
        1200
      ],
      "notesInFlow": true
    },
    {
      "parameters": {
        "content": "Fluxo de processamento principal",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1380,
        400
      ],
      "id": "a6d3c581-b365-4c04-bbba-74261115544a",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\nconst mappingData = $('Mapping').first().json; // ObtÃ©m todo o conteÃºdo de 'Mapping'\nconsole.log(\"Mapping Data:\", mappingData);\n\nconst baseWebhookUrl = `http://${mappingData.system.n8n_webhook_service}:5678/webhook/`;\nconst finalWorkflowPath = mappingData.system.workflow_path;\nconst defaultFinalUrl = `${baseWebhookUrl}${finalWorkflowPath}`;\n\nconst formData = new FormData();\n\n// Unifica os valores de \"content\" com quebra de linha dupla\nconst unifiedContent = items\n  .map(item => item.json.content)\n  .filter(content => content) // Remove itens vazios ou undefined\n  .join('\\n\\n');\nconsole.log(\"Unified Content:\", unifiedContent);\n\n// Monta o JSON separado para o corpo da requisiÃ§Ã£o\nconst jsonData = {\n  content: unifiedContent,\n  mapping: mappingData\n};\n\n// Adiciona os dados JSON ao FormData\nformData.append('content', jsonData.content);\nformData.append('mapping', JSON.stringify(jsonData.mapping));\n\n// Adiciona arquivos binÃ¡rios mantendo os nomes originais\nitems.forEach((item) => {\n  if (item.binary) {\n    Object.keys(item.binary).forEach((key) => {\n      const file = item.binary[key];\n      formData.append(key, Buffer.from(file.data, 'base64'), {\n        filename: file.fileName || key,\n        contentType: file.mimeType,\n      });\n    });\n  }\n});\n\nif (mappingData.system.enabled_rag === true || mappingData.system.enabled_rag === 'true') {\n  console.log(\"RAG is enabled. Sending request to the RAG endpoint first.\");\n  const ragUrl = `${baseWebhookUrl}rag`;\n  console.log(`Sending RAG request to: ${ragUrl}`);\n\n  return axios.post(ragUrl, formData, { headers: formData.getHeaders() })\n    .then(ragResponse => {\n      console.log(\"RAG Response received:\", ragResponse.data);\n      // Ajuste: obter o valor de \"output\" em vez de \"rag_return\"\n      const rag_return = ragResponse.data.output;\n      jsonData.rag_return = rag_return; // Inclui o retorno do RAG no JSON\n\n      // Reconstroi o FormData com os dados atualizados (incluindo rag_return)\n      const finalFormData = new FormData();\n      finalFormData.append('content', jsonData.content);\n      finalFormData.append('mapping', JSON.stringify(jsonData.mapping));\n      finalFormData.append('rag_return', rag_return);\n      items.forEach((item) => {\n        if (item.binary) {\n          Object.keys(item.binary).forEach((key) => {\n            const file = item.binary[key];\n            finalFormData.append(key, Buffer.from(file.data, 'base64'), {\n              filename: file.fileName || key,\n              contentType: file.mimeType,\n            });\n          });\n        }\n      });\n      \n      // Recupera a URL final do mapping; se nÃ£o existir, usa a URL padrÃ£o\n      let finalUrl = mappingData.system.rag_return;\n      if (!finalUrl) {\n        console.error(\"mappingData.system.rag_return is undefined. Using default final URL instead.\");\n        finalUrl = defaultFinalUrl;\n      }\n      console.log(`Mapping system.rag_return value: \"${finalUrl}\"`);\n      console.log(\"Sending final request to the RAG final endpoint...\");\n\n      return axios.post(finalUrl, finalFormData, { headers: finalFormData.getHeaders() })\n        .then(finalResponse => {\n          console.log(\"Final Response received:\", finalResponse.data);\n          return [{\n            json: {\n              rag: ragResponse.data,\n              final: finalResponse.data,\n              logs: [\n                `RAG request sent to: ${ragUrl}`,\n                `RAG response received with output: ${rag_return}`,\n                `Final request sent to: ${finalUrl}`,\n                `Final response received successfully.`\n              ]\n            }\n          }];\n        })\n        .catch(finalError => {\n          console.error(`Final request error for URL (${finalUrl}):`, finalError.message);\n          return [{\n            json: {\n              error: finalError.message,\n              rag: ragResponse.data,\n              logs: [\n                `RAG request sent to: ${ragUrl}`,\n                `RAG response received with output: ${rag_return}`,\n                `Attempted final request to: ${finalUrl}`,\n                `Final request error: ${finalError.message}`\n              ]\n            }\n          }];\n        });\n    })\n    .catch(ragError => {\n      console.error(\"RAG request error:\", ragError.message);\n      return [{\n        json: {\n          error: ragError.message,\n          logs: [\n            `RAG request sent to: ${baseWebhookUrl}rag`,\n            `RAG request error: ${ragError.message}`\n          ]\n        }\n      }];\n    });\n} else {\n  console.log(\"RAG is not enabled. Sending request directly to the default final URL:\", defaultFinalUrl);\n  return axios.post(defaultFinalUrl, formData, { headers: formData.getHeaders() })\n    .then(response => {\n      console.log(\"Final Response received:\", response.data);\n      return [{\n        json: {\n          final: response.data,\n          logs: [\n            `Final request sent to: ${defaultFinalUrl}`,\n            `Final response received successfully.`\n          ]\n        }\n      }];\n    })\n    .catch(error => {\n      console.error(\"Final request error:\", error.message);\n      return [{\n        json: {\n          error: error.message,\n          logs: [\n            `Final request error for URL (${defaultFinalUrl}): ${error.message}`\n          ]\n        }\n      }];\n    });\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -900,
        1100
      ],
      "id": "c554b7b7-9e86-4318-8c13-b220a7bb8b46",
      "name": "Execute Core"
    },
    {
      "parameters": {
        "content": "Fluxo Core, responsÃ¡vel pelo processamento da AI",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1000,
        1180
      ],
      "id": "ca510ab9-7adf-4bb7-ba22-1710dc1295f9",
      "name": "Sticky Note14"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- ObtÃ©m o Ãºltimo item da tabela conversations com base no campo 'date_created'\nWITH last_conversation AS (\n    SELECT id \n    FROM conversations\n    WHERE user_id = {{ $('Mapping').first().json.chatwoot.contact_id }}\n    ORDER BY date_created DESC\n    LIMIT 1\n),\n\n-- ObtÃ©m os Ãºltimos dois registros da tabela core_chat_histories com base no session_id\nlast_two_chat_histories AS (\n    SELECT id \n    FROM core_chat_histories\n    WHERE session_id = (SELECT id FROM last_conversation)\n    ORDER BY id DESC\n    LIMIT 2\n)\n\n-- Deleta os Ãºltimos dois registros encontrados\nDELETE FROM core_chat_histories\nWHERE id IN (SELECT id FROM last_two_chat_histories);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        500,
        1100
      ],
      "id": "b39ad79d-99b1-48ce-8fde-ee081dd48322",
      "name": "Clear History",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "name": "restart_history",
        "description": "=Invoque essa tool para iniciar uma nova conversa para o user, assim ignorando o histÃ³rico passado. Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\n\n// Converte o mapeamento recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usuÃ¡rio Ã© admin; caso contrÃ¡rio, retorna erro\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usuÃ¡rio nÃ£o autorizado.\" });\n}\n\n/**\n * FunÃ§Ã£o que espera pelo tempo especificado.\n * @param {number} ms - Milissegundos a aguardar.\n * @returns {Promise<void>}\n */\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * FunÃ§Ã£o para enviar a requisiÃ§Ã£o para criar uma conversa no Directus.\n * Tenta atÃ© 3 vezes em caso de falha, com delay de 1 segundo entre as tentativas.\n * @returns {Promise<object>} - Objeto com sucesso ou erro.\n */\nasync function sendRequest() {\n  const url = `http://${mapping.system.directus_service}:8055/items/conversations`;\n  const data = {\n    user_id: mapping.chatwoot.contact_id,\n    date_created: new Date().toISOString()\n  };\n  const headers = {\n    Authorization: `Bearer ${mapping.system.directus_token}`,\n    'Content-Type': 'application/json'\n  };\n\n  let attempt = 0;\n  let lastError = null;\n\n  while (attempt < 3) {\n    try {\n      const response = await axios.post(url, data, { headers });\n      console.log(`RequisiÃ§Ã£o realizada com sucesso na tentativa ${attempt + 1}.`);\n      return { success: true, data: response.data };\n    } catch (error) {\n      attempt++;\n      lastError = error;\n      console.error(`Tentativa ${attempt} falhou:`, error.response ? error.response.data : error.message);\n      if (attempt < 3) {\n        console.log(\"Aguardando 1 segundo antes da nova tentativa...\");\n        await delay(1000);\n      }\n    }\n  }\n  \n  return { success: false, error: lastError.response ? lastError.response.data : lastError.message };\n}\n\nreturn sendRequest().then(result => JSON.stringify(result));"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1340,
        1580
      ],
      "id": "2c8d4091-4798-44a3-89e5-d44ee314d784",
      "name": "Restart History"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{\n  $json.content.data_url?.match(/\\.(oga|png|jpg|jpeg|txt|pdf)$/i) !== null \n  && !!$json.content.data_url \n    ? 0 \n    : !!$json.content.content \n      ? 1\n      : 2\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -900,
        1500
      ],
      "id": "d7a5fbdf-6e60-4d93-8d49-6c16ce8f5965",
      "name": "Switch 2"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{ \n  $('Add to List').item.json.chatwoot.message_id !==\n  JSON.parse($('Get List').item.json.data.first()).message_id\n    ? 0\n    : $now.minus($('Mapping').first().json.system.cooldown, 'seconds').diffTo(\n        JSON.parse($('Get List').item.json.data.last()).timestamp,\n        'seconds'\n      ) >= 0\n      ? 1\n      : 2\n}}\n\n\n\n"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        100,
        580
      ],
      "id": "be373b6a-08f3-45d3-b4b5-4bcaacf1f5fe",
      "name": "Switch 1"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{\n  (\n    $('Mapping').first().json.chatwoot.channel !== 'WhatsApp Web Group' ||\n    (\n      $('Mapping').first().json.system.allow_whatsapp_groups === 'always_enabled' ||\n      (\n        $('Mapping').first().json.system.allow_whatsapp_groups === 'enabled_when_mentioned' &&\n        $('Mapping').first().json.system.agent_mentioned\n      )\n    )\n  )\n  &&\n  {\n    'pending_status': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact' &&\n      $('Mapping').first().json.chatwoot.conversation_status === 'pending',\n\n    'all_status': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact',\n\n    'not_assigned': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact' &&\n      !$('Mapping').first().json.chatwoot.assignee\n  }[$('Mapping').first().json.system.enabled_condition]\n    ? 1\n    : 0\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -500,
        580
      ],
      "id": "fa7fce13-38d7-435a-bc81-1e7aa9471bf9",
      "name": "Switch 0"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7cade77f-2498-4515-991a-cbe2d5ffe67a",
              "name": "content",
              "value": "={{\n  $json.content?.content \n  || $json.text \n  || (\n    $('Switch 2').item.json.content.data_url.endsWith('.txt') \n      ? $json.data + '\\n\\n' + $('Switch 2').item.json.content?.content \n      : null\n  )\n}}",
              "type": "string"
            },
            {
              "id": "e8da4202-58a2-4990-9e36-9a56f18c7263",
              "name": "loop_reset",
              "value": false,
              "type": "boolean"
            }
          ]
        },
        "includeOtherFields": true,
        "include": "selected",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        100,
        1500
      ],
      "id": "8e0bfa01-3df5-4f79-a805-9cada188d368",
      "name": "Keep Loop"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "core_chat_histories",
          "mode": "list",
          "cachedResultName": "core_chat_histories"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "date_created": "={{ $now }}",
            "session_id": "={{ $json.system.conversations_id }}",
            "message": "={{ JSON.parse(JSON.stringify({\n  \"type\": \"human\",\n  \"content\": $json.chatwoot.content,\n  \"user_name\": $json.chatwoot.user_name\n})) }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "message",
              "displayName": "message",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "date_created",
              "displayName": "date_created",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -300,
        480
      ],
      "id": "995200dd-f24d-4c62-86cf-459a81b1805b",
      "name": "Update History",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\nconst mapping = $('Mapping').first().json;\nconst { system, chatwoot } = mapping;\n\nif (\n  system.allow_human_interruption &&\n  system.enabled_condition === 'pending_status' &&\n  chatwoot.sender_type === 'User' &&\n  chatwoot.conversation_status !== 'open'\n) {\n  const chatwootService = system.chatwoot_service;\n  return axios.post(\n    `http://${chatwootService}:3000/api/v1/accounts/${chatwoot.account_id}/conversations/${chatwoot.conversation_id}/toggle_status`,\n    { status: \"open\" },\n    { headers: { api_access_token: chatwoot.bot_token } }\n  )\n  .then(res => [{ json: res.data }])\n  .catch(err => [{ json: { error: err.response?.data || err.message } }]);\n}\n\nreturn [{ json: { message: \"Nenhuma aÃ§Ã£o realizada\" } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -100,
        480
      ],
      "id": "75d385e0-847d-406c-b433-32be456f9bbd",
      "name": "Open Conversation"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\n// Array para armazenar logs detalhados\nconst detailedLogs = [];\n\n// FunÃ§Ãµes de log aprimoradas\nfunction logMessage(msg) {\n  console.log(msg);\n  detailedLogs.push({ type: 'info', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logError(msg) {\n  console.error(msg);\n  detailedLogs.push({ type: 'error', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logRequest(method, url, headers, payload) {\n  detailedLogs.push({\n    type: 'request',\n    method,\n    url,\n    headers,\n    payload,\n    timestamp: new Date().toISOString()\n  });\n}\n\nfunction logResponse(status, data) {\n  detailedLogs.push({\n    type: 'response',\n    status,\n    data,\n    timestamp: new Date().toISOString()\n  });\n}\n\n// ------------------------------\n// ConfiguraÃ§Ãµes Gerais\n// ------------------------------\nconst MIN_TOTAL_LENGTH = 50;               // Texto menor que 50 caracteres: enviar inteiro.\nconst MIN_SEGMENT_LENGTH = 50;             // Segmentos menores que 50 caracteres serÃ£o mesclados. (era 20)\nconst DESIRED_TEXT_SEGMENT_SIZE = 500;     // Tamanho ideal para segmentos no modo \"text\". (era 200)\nconst DESIRED_AUDIO_SEGMENT_SIZE = 800;    // Tamanho ideal para segmentos no modo \"audio\" (~30s). (era 450)\nconst DELAY_FACTOR = 2000;                 // Delay: 200ms por 100 caracteres.\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// ------------------------------\n// ParÃ¢metros obtidos dos nÃ³s\n// ------------------------------\nconst mapping = $('Mapping').first().json;\nconst chatwootData = mapping.chatwoot;\nconst accountId = chatwootData.account_id;\nconst conversationId = chatwootData.conversation_id;\nconst botToken = chatwootData.bot_token;\n\nconst system = mapping.system;\nconst outputFormat = system.output_format.toLowerCase(); // \"text\", \"audio\" ou \"smart\"\nconst elevenlabsKey = system.elevenlabs_key;\nconst elevenlabsVoice = system.elevenlabs_voice || \"JBFqnCBsd6RMkjVDRZzb\";\nconst elevenlabsModel = system.elevenlabs_model || \"eleven_multilingual_v2\";\nconst chatwootService = system.chatwoot_service; // Valor para a URL do Chatwoot\n\n// Texto original (ajustado para acessar o payload final corretamente)\nconst originalText = $('Execute Core').first().json.final.output;\nlogMessage(`[Main] Texto original possui ${originalText.length} caracteres.`);\nlogMessage(`[Main] Modo de saÃ­da: ${outputFormat}`);\n\n// Endpoint do Chatwoot (ajustado para usar chatwootService)\n//const chatwootUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\n//logMessage(`[Main] Chatwoot URL: ${chatwootUrl}`);\n\nconst chatwootUrl = `https://chat.spsystems.pro/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\nlogMessage(`[Main] Chatwoot URL: ${chatwootUrl}`);\n\n// Log dos parÃ¢metros de entrada\nlogMessage(`[Main] ParÃ¢metros: accountId=${accountId}, conversationId=${conversationId}`);\nlogMessage(`[Main] Chatwoot Service: ${chatwootService}`);\nlogMessage(`[Main] Token (primeiros 5 caracteres): ${botToken.substring(0, 5)}...`);\n\n// ------------------------------\n// FunÃ§Ã£o para enviar mensagem de texto\n// ------------------------------\nasync function sendTextMessage(content) {\n  const payload = { content, message_type: \"outgoing\" };\n  const headers = {\n    \"api_access_token\": botToken,\n    \"Content-Type\": \"application/json\"\n  };\n  \n  logMessage(`[sendTextMessage] Enviando mensagem de texto.`);\n  logMessage(`[sendTextMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendTextMessage] Payload: ${JSON.stringify(payload)}`);\n  logMessage(`[sendTextMessage] Headers: ${JSON.stringify(headers)}`);\n  \n  logRequest('POST', chatwootUrl, headers, payload);\n  \n  try {\n    const response = await axios.post(chatwootUrl, payload, { headers });\n    logMessage(`[sendTextMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendTextMessage] Erro ao enviar mensagem de texto: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendTextMessage] Status: ${error.response.status}`);\n      logError(`[sendTextMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendTextMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendTextMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// FunÃ§Ã£o para enviar mensagem de Ã¡udio\n// ------------------------------\nasync function sendAudioMessage(audioBuffer) {\n  const form = new FormData();\n  form.append(\"attachments[]\", audioBuffer, { filename: \"audio.mp3\", contentType: \"audio/mpeg\" });\n  form.append(\"message_type\", \"outgoing\");\n  \n  const headers = {\n    \"api_access_token\": botToken,\n    ...form.getHeaders()\n  };\n  \n  logMessage(`[sendAudioMessage] Enviando mensagem de Ã¡udio.`);\n  logMessage(`[sendAudioMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendAudioMessage] Headers: ${JSON.stringify(headers)}`);\n  logMessage(`[sendAudioMessage] Tamanho do Ã¡udio: ${audioBuffer.length} bytes`);\n  \n  logRequest('POST', chatwootUrl, headers, \"Form Data com Ã¡udio\");\n  \n  try {\n    const response = await axios.post(chatwootUrl, form, { headers });\n    logMessage(`[sendAudioMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendAudioMessage] Erro ao enviar mensagem de Ã¡udio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendAudioMessage] Status: ${error.response.status}`);\n      logError(`[sendAudioMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendAudioMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendAudioMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// FunÃ§Ã£o para converter texto em Ã¡udio via Elevenlabs\n// ------------------------------\nasync function convertTextToSpeech(text) {\n  const url = `https://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(elevenlabsVoice)}?output_format=mp3_44100_128`;\n  const headers = {\n    \"xi-api-key\": elevenlabsKey,\n    \"Content-Type\": \"application/json\"\n  };\n  const payload = {\n    text: text,\n    model_id: elevenlabsModel\n  };\n  \n  logMessage(`[convertTextToSpeech] Convertendo texto para Ã¡udio (primeiros 50 caracteres): \"${text.substring(0,50)}...\"`);\n  logMessage(`[convertTextToSpeech] URL da API Elevenlabs: ${url}`);\n  logMessage(`[convertTextToSpeech] Modelo utilizado: ${elevenlabsModel}`);\n  \n  logRequest('POST', url, headers, payload);\n  \n  try {\n    const response = await axios.post(url, payload, { headers, responseType: 'arraybuffer' });\n    logMessage(`[convertTextToSpeech] ConversÃ£o realizada com sucesso. Status: ${response.status}`);\n    logResponse(response.status, \"Binary Audio Data\");\n    return response.data;\n  } catch (error) {\n    logError(`[convertTextToSpeech] Erro ao converter texto para Ã¡udio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[convertTextToSpeech] Status: ${error.response.status}`);\n      logError(`[convertTextToSpeech] Headers: ${JSON.stringify(error.response.headers)}`);\n      // Para arraybuffer, precisamos converter para texto para ver o erro\n      if (error.response.data) {\n        try {\n          const errorText = Buffer.from(error.response.data).toString('utf8');\n          logError(`[convertTextToSpeech] Erro Response: ${errorText}`);\n          logResponse(error.response.status, errorText);\n        } catch (e) {\n          logError(`[convertTextToSpeech] NÃ£o foi possÃ­vel converter resposta de erro: ${e.toString()}`);\n        }\n      }\n    } else if (error.request) {\n      logError(`[convertTextToSpeech] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// FunÃ§Ã£o para mesclar segmentos curtos (para modos text e audio)\n// ------------------------------\nfunction mergeShortSegments(segments, minLength) {\n  const merged = [];\n  let buffer = \"\";\n  for (const seg of segments) {\n    if ((buffer + \" \" + seg).trim().length < minLength) {\n      buffer = (buffer + \" \" + seg).trim();\n    } else {\n      if (buffer) {\n        merged.push(buffer);\n        buffer = \"\";\n      }\n      merged.push(seg);\n    }\n  }\n  if (buffer) {\n    if (merged.length > 0) {\n      merged[merged.length - 1] += \" \" + buffer;\n    } else {\n      merged.push(buffer);\n    }\n  }\n  return merged;\n}\n\n// ------------------------------\n// FunÃ§Ã£o para verificar delimitadores nÃ£o fechados\n// ------------------------------\nfunction hasUnmatchedDelimiters(text) {\n  const openParens = (text.match(/\\(/g) || []).length;\n  const closeParens = (text.match(/\\)/g) || []).length;\n  const openBrackets = (text.match(/\\[/g) || []).length;\n  const closeBrackets = (text.match(/\\]/g) || []).length;\n  const openQuotes = (text.match(/\"/g) || []).length;\n  const openSingleQuotes = (text.match(/'/g) || []).length;\n  \n  return (\n    openParens !== closeParens ||\n    openBrackets !== closeBrackets ||\n    openQuotes % 2 !== 0 ||\n    openSingleQuotes % 2 !== 0\n  );\n}\n\n// ------------------------------\n// FunÃ§Ã£o de segmentaÃ§Ã£o genÃ©rica (evita quebrar palavras)\n// ------------------------------\nfunction segmentTextGeneric(text, desiredMaxLength) {\n  if (text.length <= desiredMaxLength) return [text];\n  \n  let segments = [];\n  // Tenta dividir por quebra de linha dupla\n  if (text.includes(\"\\n\\n\")) {\n    segments = text.split(/\\n\\s*\\n/).map(seg => seg.trim()) // .filter(seg => seg.length > 0);\n  }\n  // Se nÃ£o houver, ou se nÃ£o gerar resultados, dividir por delimitadores naturais (ponto, ?, !, vÃ­rgula, ;, :)\n  if (segments.length === 0) {\n    segments = text.split(/(?<=[.?!,;:])\\s+/).map(seg => seg.trim()) // .filter(seg => seg.length > 0);\n  }\n  \n  // Mescla segmentos curtos\n  segments = mergeShortSegments(segments, MIN_SEGMENT_LENGTH);\n  \n  // Se algum segmento for muito longo, subdivide-o por espaÃ§os, sem quebrar palavras\n  const finalSegments = [];\n  segments.forEach(seg => {\n    if (seg.length > desiredMaxLength * 1.5) {\n      const words = seg.split(\" \");\n      let current = \"\";\n      for (const word of words) {\n        if ((current + \" \" + word).trim().length > desiredMaxLength) {\n          finalSegments.push(current.trim());\n          current = word;\n        } else {\n          current += \" \" + word;\n        }\n      }\n      if (current.trim()) finalSegments.push(current.trim());\n    } else {\n      finalSegments.push(seg);\n    }\n  });\n  \n  return finalSegments;\n}\n\n// FunÃ§Ã£o para segmentaÃ§Ã£o de texto inteligente com proteÃ§Ã£o de delimitadores\nfunction textSegmentation(text, maxSize = 500, minSize = 100) {\n  // Divide o texto em parÃ¡grafos\n  const parts = text.split(\"\\n\\n\");\n\n  // Se o texto nÃ£o contÃ©m nenhum parÃ¡grafo, retorna o texto original\n  if (parts.length === 1 && parts[0].length <= maxSize) {\n    return parts;\n  }\n\n  // Processa a segmentaÃ§Ã£o de cada parÃ¡grafo\n  const segments = parts.reduce((acc, part) => {\n    part = part.trim();\n\n    // Se o parÃ¡grafo Ã© menor que o tamanho mÃ¡ximo, mantemos ele inteiro\n    if (part.length <= maxSize) {\n      acc.push(part.trim());\n    } else {\n      // Para parÃ¡grafos maiores que o tamanho mÃ¡ximo, dividimos em segmentos\n      // baseados apenas nos pontos de separaÃ§Ã£o (. ! ?)\n      let currentSegment = \"\";\n      let lastSegmentEnd = 0;\n\n      // Percorremos o texto caractere por caractere\n      for (let i = 0; i < part.length; i++) {\n        const char = part[i];\n        currentSegment += char;\n\n        // Verificamos se encontramos um ponto de quebra\n        if (char === \".\" || char === \"!\" || char === \"?\") {\n          // Verificar se nÃ£o Ã© parte de uma numeraÃ§Ã£o (ex: \"1.\", \"2.\")\n          const prevChar = i > 0 ? part[i - 1] : \"\";\n          const isNumbering = /\\d/.test(prevChar);\n\n          // Se for parte de uma numeraÃ§Ã£o, nÃ£o Ã© um ponto de quebra\n          if (isNumbering) {\n            continue;\n          }\n\n          // Regra especial para ponto final: verificar se tem menos de 4 caracteres apÃ³s o Ãºltimo espaÃ§o\n          if (char === \".\") {\n            // Encontra a Ãºltima ocorrÃªncia de espaÃ§o no segmento atual\n            const lastSpaceIndex = currentSegment.lastIndexOf(\" \");\n\n            // Se nÃ£o hÃ¡ espaÃ§o ou a palavra apÃ³s o Ãºltimo espaÃ§o tem menos de 4 caracteres, nÃ£o quebra\n            if (\n              lastSpaceIndex === -1 ||\n              currentSegment.length - lastSpaceIndex - 1 < 4\n            ) {\n              continue;\n            }\n          }\n\n          // Ponto de quebra vÃ¡lido encontrado - AGORA COM VERIFICAÃ‡ÃƒO DE DELIMITADORES\n          if (currentSegment.length >= minSize) {\n            // NOVA LÃ“GICA: Verificar se hÃ¡ delimitadores nÃ£o fechados\n            if (hasUnmatchedDelimiters(currentSegment)) {\n              continue; // NÃƒO quebra se hÃ¡ parÃªnteses, colchetes ou aspas abertos\n            }\n            \n            // Garantimos que nÃ£o hÃ¡ espaÃ§os extras\n            const trimmedSegment = currentSegment.trim();\n            acc.push(trimmedSegment);\n\n            // Pegamos o prÃ³ximo caractere apÃ³s o ponto de quebra,\n            // mas pulamos qualquer espaÃ§o inicial no prÃ³ximo segmento\n            currentSegment = \"\";\n            lastSegmentEnd = i + 1;\n\n            // AvanÃ§amos o Ã­ndice i para pular espaÃ§os entre segmentos\n            while (\n              lastSegmentEnd < part.length &&\n              part[lastSegmentEnd] === \" \"\n            ) {\n              lastSegmentEnd++;\n              i = lastSegmentEnd - 1; // Ajustamos i para continuar do prÃ³ximo caractere nÃ£o-espaÃ§o\n            }\n          }\n        }\n      }\n\n      // Adicionamos o segmento restante, se houver\n      if (currentSegment.length > 0) {\n        acc.push(currentSegment.trim());\n      }\n    }\n\n    return acc;\n  }, []);\n\n  return segments;\n}\n\n// ------------------------------\n// FunÃ§Ãµes de segmentaÃ§Ã£o para cada modo\n// ------------------------------\nfunction segmentForText(text) {\n  return textSegmentation(text, DESIRED_TEXT_SEGMENT_SIZE);\n}\n\nfunction segmentForAudio(text) {\n  return textSegmentation(text, DESIRED_AUDIO_SEGMENT_SIZE);\n}\n\n/**\n * FunÃ§Ã£o \"smartSegment\":\n * - Divide o texto em sentenÃ§as usando delimitadores finais.\n * - Para cada sentenÃ§a, se ela contiver dÃ­gitos ou tiver menos de 120 ou mais de 800 caracteres,\n *   ela serÃ¡ marcada para envio como texto.\n * - Caso contrÃ¡rio, a sentenÃ§a Ã© considerada \"audio\".\n * - As sentenÃ§as marcadas para Ã¡udio sÃ£o agrupadas atÃ© atingirem aproximadamente DESIRED_AUDIO_SEGMENT_SIZE.\n * - ApÃ³s a segmentaÃ§Ã£o, os segmentos do tipo \"text\" com menos que MIN_SEGMENT_LENGTH sÃ£o mesclados.\n * \n * Retorna um array de objetos: { type: \"text\" | \"audio\", content: string }.\n */\nfunction smartSegment(text) {\n  const sentences = text.split(/(?<=[.?!])\\s+/).map(s => s.trim()).filter(s => s);\n  const segments = [];\n  let audioBuffer = \"\";\n  \n  for (const sentence of sentences) {\n    if (/\\d/.test(sentence) || sentence.length < 120 || sentence.length > 800) {\n      if (audioBuffer) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = \"\";\n      }\n      segments.push({ type: \"text\", content: sentence });\n    } else {\n      if ((audioBuffer + \" \" + sentence).trim().length > DESIRED_AUDIO_SEGMENT_SIZE) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = sentence;\n      } else {\n        audioBuffer = (audioBuffer + \" \" + sentence).trim();\n      }\n    }\n  }\n  if (audioBuffer) {\n    segments.push({ type: \"audio\", content: audioBuffer.trim() });\n  }\n  \n  const mergedSegments = [];\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    if (seg.type === \"text\" && seg.content.length < MIN_SEGMENT_LENGTH) {\n      if (mergedSegments.length > 0 && mergedSegments[mergedSegments.length - 1].type === \"text\") {\n        mergedSegments[mergedSegments.length - 1].content += \" \" + seg.content;\n      } else if (i < segments.length - 1 && segments[i+1].type === \"text\") {\n        segments[i+1].content = seg.content + \" \" + segments[i+1].content;\n      } else {\n        mergedSegments.push(seg);\n      }\n    } else {\n      mergedSegments.push(seg);\n    }\n  }\n  \n  return mergedSegments;\n}\n\n// ------------------------------\n// FunÃ§Ã£o principal para segmentar e enviar a mensagem\n// ------------------------------\nasync function main() {\n  try {\n    logMessage(`[Main] Modo de saÃ­da selecionado: ${outputFormat}`);\n    \n    // VerificaÃ§Ã£o inicial de parÃ¢metros essenciais\n    if (!originalText || originalText.trim().length === 0) {\n      throw new Error(\"Texto original estÃ¡ vazio ou nÃ£o foi encontrado\");\n    }\n    \n    if (!chatwootService) {\n      throw new Error(\"chatwoot_service nÃ£o definido\");\n    }\n    \n    if (!accountId) {\n      throw new Error(\"account_id nÃ£o definido\");\n    }\n    \n    if (!conversationId) {\n      throw new Error(\"conversation_id nÃ£o definido\");\n    }\n    \n    if (!botToken) {\n      throw new Error(\"bot_token nÃ£o definido\");\n    }\n    \n    // Adicionando um delay inicial para garantir que o Chatwoot esteja pronto\n    await delay(1000);\n  \n    if (outputFormat === \"audio\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key nÃ£o definida para modo audio\");\n      }\n      \n      const segments = segmentForAudio(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para Ã¡udio.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de Ã¡udio: \"${segment.substring(0,50)}...\"`);\n        const audioBuffer = await convertTextToSpeech(segment);\n        await sendAudioMessage(audioBuffer);\n        logMessage(`[Main] Segmento de Ã¡udio enviado: \"${segment.substring(0,50)}...\"`);\n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do prÃ³ximo segmento de Ã¡udio.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem de Ã¡udio enviada com sucesso.\", logs: detailedLogs };\n    } else if (outputFormat === \"smart\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key nÃ£o definida para modo smart\");\n      }\n      \n      const segments = smartSegment(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} parte(s) (smart mode).`);\n      \n      for (const seg of segments) {\n        if (seg.type === \"audio\") {\n          logMessage(`[Main] Processando segmento de Ã¡udio smart: \"${seg.content.substring(0,50)}...\"`);\n          const audioBuffer = await convertTextToSpeech(seg.content);\n          await sendAudioMessage(audioBuffer);\n          logMessage(`[Main] Segmento de Ã¡udio enviado: \"${seg.content.substring(0,50)}...\"`);\n        } else {\n          logMessage(`[Main] Processando segmento de texto smart: \"${seg.content.substring(0,50)}...\"`);\n          await sendTextMessage(seg.content);\n          logMessage(`[Main] Segmento de texto enviado: \"${seg.content.substring(0,50)}...\"`);\n        }\n        \n        const delayTime = Math.ceil(seg.content.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do prÃ³ximo segmento.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem smart enviada com sucesso.\", logs: detailedLogs };\n    } else {\n      // Modo padrÃ£o: text\n      const segments = segmentForText(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para texto.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de texto: \"${segment.substring(0,50)}...\"`);\n        await sendTextMessage(segment);\n        logMessage(`[Main] Segmento de texto enviado: \"${segment.substring(0,50)}...\"`);\n        \n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do prÃ³ximo segmento de texto.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagens de texto enviadas com sucesso.\", logs: detailedLogs };\n    }\n  } catch (error) {\n    logError(`[Main] Erro: ${error.toString()}`);\n    return { error: error.toString(), logs: detailedLogs };\n  }\n}\n\nreturn main().then(result => [{ json: result }]);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        500,
        1300
      ],
      "id": "3aa4b08c-0994-4cb9-9118-8b32ff38d404",
      "name": "Chatwoot Output"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH last_conversation AS (\n  -- Encontra a Ãºltima conversa do usuÃ¡rio\n  SELECT id\n  FROM conversations\n  WHERE user_id = {{ $('Mapping').first().json.chatwoot.contact_id }}\n  ORDER BY date_created DESC\n  LIMIT 1\n),\nlast_two_chat_histories AS (\n  -- ObtÃ©m os dois Ãºltimos histÃ³ricos da conversa e define uma ordem para identificar o penÃºltimo\n  SELECT \n    id,\n    ROW_NUMBER() OVER (ORDER BY id DESC) AS rn\n  FROM core_chat_histories\n  WHERE session_id = (SELECT id FROM last_conversation)\n  ORDER BY id DESC\n  LIMIT 2\n),\nupdate_chat_histories AS (\n  UPDATE core_chat_histories c\n  SET \n    date_created = NOW(),\n    message = (\n      CASE \n        WHEN l.rn = 2 \n          THEN jsonb_set(c.message::jsonb, '{user_name}', to_jsonb('{{ $('Mapping').first().json.chatwoot.user_name }}'::text), true)\n        ELSE c.message::jsonb\n      END\n    )::json\n  FROM last_two_chat_histories l\n  WHERE c.id = l.id\n  RETURNING 1\n)\nUPDATE users u\nSET date_updated = NOW()\nWHERE u.id = {{ $('Mapping').first().json.chatwoot.contact_id }};",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        700,
        1300
      ],
      "id": "26d99333-8bcc-482d-b8c4-4e641412db17",
      "name": "Add Register",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "name": "set_timer",
        "description": "Invoque essa tool para configurar um timer que iniciarÃ¡ uma aÃ§Ã£o apÃ³s o tempo especificado. Apenas usuÃ¡rios admin podem usar essa tool. O tempo deve ser informado com valor e unidade (s, m, h). Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\nconst dayjs = require('dayjs');\nconst duration = require('dayjs/plugin/duration');\ndayjs.extend(duration);\n\n/**\n * Esta tool configura um timer via webhook.\n * Ela envia, para o endpoint, todo o objeto mapping (obtido em Core Input)\n * e o tempo em segundos calculado a partir dos parÃ¢metros \"timer_value\" e \"timer_unit\".\n * Apenas usuÃ¡rios admin podem utilizar esta tool.\n */\n\n// Converte o mapping recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usuÃ¡rio Ã© admin\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usuÃ¡rio nÃ£o autorizado.\" });\n}\n\n// ObtÃ©m os parÃ¢metros do timer a partir do input (query)\nconst timerValue = query.timer_value;  // NÃºmero (ex: 30)\nconst timerUnit = query.timer_unit;      // \"s\", \"m\" ou \"h\"\n\n// Calcula o tempo em segundos usando dayjs.duration\nconst timerSeconds = dayjs.duration(timerValue, timerUnit).asSeconds();\n\n// Prepara o payload para o webhook\nconst payload = {\n  mapping: mapping,\n  timer_seconds: timerSeconds\n};\n\n// URL do webhook substituindo 'n8n_webhook' pelo valor da variÃ¡vel no mapping\nconst url = `http://${mapping.system.n8n_webhook_service}:5678/webhook/timer`;\n\n/**\n * FunÃ§Ã£o para enviar a requisiÃ§Ã£o ao webhook.\n * Tenta enviar uma Ãºnica vez e retorna o resultado.\n */\nasync function sendTimerRequest() {\n  try {\n    console.log(`Enviando requisiÃ§Ã£o para configurar o timer para ${timerSeconds} segundos...`);\n    const response = await axios.post(url, payload, {\n      headers: { 'Content-Type': 'application/json' }\n    });\n    console.log(\"Timer configurado com sucesso.\");\n    return { success: true, message: `Timer configurado com sucesso. Ele serÃ¡ acionado em ${timerSeconds} segundos.` };\n  } catch (error) {\n    console.error(\"Erro ao configurar o timer:\", error.response ? error.response.data : error.message);\n    return { success: false, error: error.response ? error.response.data : error.message };\n  }\n}\n\nreturn sendTimerRequest().then(result => JSON.stringify(result));",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"timer_value\": {\n      \"type\": \"number\",\n      \"description\": \"Valor do timer. Exemplo: 30\"\n    },\n    \"timer_unit\": {\n      \"type\": \"string\",\n      \"description\": \"Unidade de tempo para o timer: 's' para segundos, 'm' para minutos, 'h' para horas.\",\n      \"enum\": [\"s\", \"m\", \"h\"]\n    }\n  },\n  \"required\": [\"timer_value\", \"timer_unit\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1460,
        1580
      ],
      "id": "3680376d-7af6-4818-b051-0aedb4da4bfa",
      "name": "Set Timer"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "tableName": {
          "__rl": true,
          "value": "knowledge",
          "mode": "list",
          "cachedResultName": "knowledge"
        },
        "additionalFields": {},
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTrigger",
      "typeVersion": 1,
      "position": [
        -1300,
        1860
      ],
      "id": "b7185a67-4bc6-4b45-a71a-c1de89231c0f",
      "name": "Knowledge Trigger",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  k.*,\n  n.value AS namespace,\n  ph.value AS pinecone_host,\n  (\n    SELECT json_agg(ku.url)\n    FROM knowledge_urls ku\n    WHERE ku.knowledge_id = k.id\n  ) AS urls,\n  (\n    SELECT json_agg(kf.directus_files_id)\n    FROM knowledge_files kf\n    WHERE kf.knowledge_id = k.id\n  ) AS files_id,\n  (\n    SELECT row_to_json(gv)\n    FROM global_vars gv\n    LIMIT 1\n  ) AS global_vars\nFROM knowledge k\nLEFT JOIN namespace n ON n.id = k.name_id\nLEFT JOIN pinecone_host ph ON ph.id = k.pinecone_host_id\nWHERE k.id = {{ $('Knowledge Trigger').first().json.payload.id }};\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1100,
        1860
      ],
      "id": "42909b41-9d9d-4e31-9968-b83ea887b063",
      "name": "Get Global Vars",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\n// Delay configurÃ¡vel\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Executa requisiÃ§Ã£o GET com retry, usando parÃ¢metros configurÃ¡veis.\nasync function axiosGetWithRetry(url, config, maxAttempts = 3, delayMs = 1000) {\n  let attempt = 1;\n  while (attempt <= maxAttempts) {\n    try {\n      return await axios.get(url, config);\n    } catch (err) {\n      console.error(`Tentativa ${attempt} para ${url} falhou:`, {\n        message: err.message,\n        status: err.response?.status,\n        data: err.response?.data,\n      });\n      if (attempt === maxAttempts) throw err;\n      attempt++;\n      await delay(delayMs);\n    }\n  }\n}\n\n// Prompt para gerar resumo de um bloco de texto\nconst SUMMARY_PROMPT = `Analise o texto a seguir e elabore um resumo conciso e direto, destacando os principais tÃ³picos e informaÃ§Ãµes essenciais. Esse resumo servirÃ¡ de base para compor a descriÃ§Ã£o geral do documento.\n\nTexto:\n{conteudo}\n\nResumo:`;\n\n// Prompt para criar a descriÃ§Ã£o diretamente a partir do texto completo\nconst DIRECT_DESCRIPTION_PROMPT = `Analise o texto a seguir e crie uma descriÃ§Ã£o clara e objetiva do conteÃºdo geral do documento. A resposta deve ser um Ãºnico parÃ¡grafo conciso de texto simples, sem formataÃ§Ã£o, com aproximadamente 300 caracteres.\n\nTexto:\n{conteudo}\n\nDescriÃ§Ã£o:`;\n\n// Prompt para gerar a descriÃ§Ã£o final a partir dos resumos\nconst FINAL_DESCRIPTION_PROMPT = `Com base nos resumos a seguir, elabore uma descriÃ§Ã£o clara e objetiva do conteÃºdo geral do documento. A resposta deve ser um Ãºnico parÃ¡grafo conciso de texto simples, sem formataÃ§Ã£o, com aproximadamente 300 caracteres.\n\nResumos:\n{conteudo}\n\nDescriÃ§Ã£o:`;\n\n// Cria chunks de forma orgÃ¢nica, sem misturar conteÃºdos de diferentes scrapings\nfunction createChunks(text, chunkLength, overlapPercentage) {\n  const overlapLength = Math.floor(chunkLength * (overlapPercentage / 100));\n  const chunks = [];\n  let currentPos = 0;\n  while (currentPos < text.length) {\n    let endPos = currentPos + chunkLength;\n    if (endPos >= text.length) {\n      endPos = text.length;\n    } else {\n      const searchStart = Math.max(currentPos, endPos - 100);\n      let breakPos = -1;\n      let pos = text.lastIndexOf(\"\\n\\n\", endPos);\n      if (pos >= searchStart) {\n        breakPos = pos + 2;\n      } else {\n        pos = text.lastIndexOf(\"\\n\", endPos);\n        if (pos >= searchStart) {\n          breakPos = pos + 1;\n        } else {\n          pos = text.lastIndexOf(\".\", endPos);\n          if (pos >= searchStart) {\n            breakPos = pos + 1;\n          } else {\n            pos = text.lastIndexOf(\"?\", endPos);\n            if (pos >= searchStart) {\n              breakPos = pos + 1;\n            } else {\n              pos = text.lastIndexOf(\"!\", endPos);\n              if (pos >= searchStart) {\n                breakPos = pos + 1;\n              }\n            }\n          }\n        }\n      }\n      if (breakPos > currentPos) {\n        endPos = breakPos;\n      }\n    }\n    const chunk = text.substring(currentPos, endPos).trim();\n    if (chunk.length > 0) chunks.push(chunk);\n    if (endPos === text.length) break;\n    currentPos = endPos - overlapLength;\n    if (currentPos < 0) currentPos = 0;\n  }\n  return chunks;\n}\n\n// FunÃ§Ã£o para atualizar o campo \"description\" da tabela \"knowledge\" no Directus\nasync function updateDirectusDescription(newDescription, globalVars, globalId) {\n  const patchUrl = `http://${globalVars.directus_service}:8055/items/knowledge/${globalId}`;\n  const patchPayload = { description: newDescription };\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": `Bearer ${globalVars.directus_token}`\n  };\n  let attempts = 0;\n  while (attempts < 3) {\n    try {\n      const response = await axios.patch(patchUrl, patchPayload, { headers });\n      console.log(`Directus update successful: ${JSON.stringify(response.data)}`);\n      return response.data;\n    } catch (error) {\n      attempts++;\n      console.error(`Directus update attempt ${attempts} failed: ${error.message}`);\n      if (attempts < 3) {\n        await delay(1000);\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n\nasync function processScraping() {\n  // Extrai dados do nÃ³ Get Global Vars\n  const globalData = $('Get Global Vars').first().json;\n  const globalVars = globalData.global_vars;\n  const filesIds = Array.isArray(globalData.files_id) ? globalData.files_id : [];\n  const originalUrls = Array.isArray(globalData.urls) ? globalData.urls : [];\n  // Usa s3_url definido em global_vars\n  const host = globalVars.s3_url;\n  const directusToken = globalVars.directus_token;\n  const jinaToken = globalVars.jina_ai_token;\n  const openrouterKey = globalVars.openrouter_key;\n  const directusService = globalVars.directus_service;\n  const n8nWebhookService = globalVars.n8n_webhook_service;\n  const chunkLength = globalData.chunks_length || 2000; // fallback default\n  const overlapPercentage = globalData.overlap || 0;      // fallback default\n  \n  // Extrai o valor de Knowledge Trigger\n  const knowledgeTriggerId = $('Knowledge Trigger').first().json.payload.id;\n\n  // Processa arquivos para obter finalUrl com retry (se existirem)\n  const fileResults = await Promise.all(\n    filesIds.map(async (fileId) => {\n      try {\n        const response = await axiosGetWithRetry(\n          `http://${directusService}:8055/files/${fileId}`,\n          { headers: { Authorization: `Bearer ${directusToken}` } }\n        );\n        const filename_disk = response.data.data.filename_disk;\n        // Retira o \"s3\" pois jÃ¡ estÃ¡ incluso na URL\n        const finalUrl = `${host}/directus/${filename_disk}`;\n        return { type: 'file', fileId, url: finalUrl };\n      } catch (err) {\n        return {\n          type: 'file',\n          fileId,\n          error: err.message,\n          status: err.response?.status,\n          responseData: err.response?.data,\n        };\n      }\n    })\n  );\n\n  // Prepara URLs para scraping (se existirem)\n  const originalUrlsToScrape = originalUrls.map(url => ({ type: 'original', url }));\n  const allUrlsToScrape = [\n    ...fileResults.filter(item => item.url),\n    ...originalUrlsToScrape\n  ];\n\n  // Executa scraping com retry para cada URL (se houver)\n  const scrapeResults = await Promise.all(\n    allUrlsToScrape.map(async (item) => {\n      try {\n        const scrapingUrl = `https://r.jina.ai/${item.url}`;\n        const response = await axiosGetWithRetry(\n          scrapingUrl,\n          { headers: { Authorization: `Bearer ${jinaToken}` } }\n        );\n        return { ...item, scrapeData: response.data };\n      } catch (err) {\n        return {\n          ...item,\n          scrapeError: err.message,\n          status: err.response?.status,\n          errorData: err.response?.data,\n        };\n      }\n    })\n  );\n\n  // Agrega e limpa conteÃºdo dos scrapings para gerar chunks e descriÃ§Ã£o\n  const scrapedTexts = scrapeResults.map(item => item.scrapeData ? JSON.stringify(item.scrapeData) : '');\n  const aggregatedContent = scrapedTexts.join(' ');\n  const cleanedContent = aggregatedContent.replace(/[^a-zA-Z0-9\\s]/g, ' ');\n\n  // Gera chunks dos scrapings (mantendo conteÃºdo orgÃ¢nico por scraping)\n  const chunks = [];\n  scrapeResults.forEach(item => {\n    if (item.scrapeData) {\n      const text = JSON.stringify(item.scrapeData);\n      const itemChunks = createChunks(text, chunkLength, overlapPercentage);\n      itemChunks.forEach(chunk => {\n        chunks.push({ chunk, source: item.url });\n      });\n    }\n  });\n\n  // GeraÃ§Ã£o da descriÃ§Ã£o do conteÃºdo\n  const blockSize = 200000;\n  let finalDescription;\n  async function enviarPrompt(promptContent) {\n    const response = await axios.post(\n      'https://openrouter.ai/api/v1/chat/completions',\n      {\n        model: 'google/gemini-2.5-pro-preview-03-25',\n        messages: [{ role: 'user', content: promptContent }]\n      },\n      { headers: { Authorization: `Bearer ${openrouterKey}` } }\n    );\n    return response.data;\n  }\n  if (cleanedContent.length > blockSize) {\n    const blocks = [];\n    for (let i = 0; i < cleanedContent.length; i += blockSize) {\n      blocks.push(cleanedContent.substring(i, i + blockSize));\n    }\n    const summaries = await Promise.all(\n      blocks.map(async (block) => {\n        const prompt = `<dados>${block}</dados>\\n` + SUMMARY_PROMPT.replace('{conteudo}', block);\n        try {\n          const summaryResponse = await enviarPrompt(prompt);\n          return (summaryResponse.choices && summaryResponse.choices[0].message.content) || '';\n        } catch (err) {\n          return '';\n        }\n      })\n    );\n    const aggregatedSummaries = summaries.join(' ');\n    const descriptionPrompt = `<dados>${aggregatedSummaries}</dados>\\n` + FINAL_DESCRIPTION_PROMPT.replace('{conteudo}', aggregatedSummaries);\n    try {\n      const descriptionResponse = await enviarPrompt(descriptionPrompt);\n      finalDescription = descriptionResponse;\n    } catch (err) {\n      finalDescription = { error: err.message, status: err.response?.status, errorData: err.response?.data };\n    }\n  } else {\n    const directPrompt = `<dados>${cleanedContent}</dados>\\n` + DIRECT_DESCRIPTION_PROMPT.replace('{conteudo}', cleanedContent);\n    try {\n      const descriptionResponse = await enviarPrompt(directPrompt);\n      finalDescription = descriptionResponse;\n    } catch (err) {\n      finalDescription = { error: err.message, status: err.response?.status, errorData: err.response?.data };\n    }\n  }\n  \n  // Extrai somente o conteÃºdo da descriÃ§Ã£o, se disponÃ­vel\n  if (finalDescription && finalDescription.choices && finalDescription.choices[0] && finalDescription.choices[0].message) {\n    finalDescription = finalDescription.choices[0].message.content;\n  }\n\n  // Atualiza o campo \"description\" na tabela \"knowledge\" no Directus\n  try {\n    const updateResponse = await updateDirectusDescription(finalDescription, globalVars, globalData.id);\n    console.log(\"Directus update response:\", updateResponse);\n  } catch (error) {\n    console.error(\"Falha ao atualizar o Directus apÃ³s 3 tentativas:\", error.message);\n  }\n\n  // GeraÃ§Ã£o dos vetores a partir dos chunks\n  for (const chunkItem of chunks) {\n    const vectorPromptBody = {\n      messages: [\n        {\n          role: \"user\",\n          content: `VocÃª Ã© um agente interno de um sistema especializado em extrair perguntas e respostas de documentos. Sua tarefa Ã© analisar o chunk fornecido, que representa um segmento de um documento completo, e gerar perguntas e respostas baseadas nas informaÃ§Ãµes contidas nele. \n\nContexto do documento: ${globalData.Instruction_Prompt}\n\nDiretrizes:\n1. Extraia informaÃ§Ãµes relevantes (respostas) do chunk fornecido. Essas informaÃ§Ãµes devem ser associadas a perguntas principais, mantendo sempre o tom e o estilo do texto original.\n2. Para cada resposta extraÃ­da:\n   - Crie uma pergunta principal (q) que tenha como resposta a informaÃ§Ã£o extraÃ­da (a).\n   - Identifique o trecho especÃ­fico do documento (t) de onde a resposta foi retirada.\n   - Formule perguntas alternativas (sq) que poderiam ser feitas para obter a mesma resposta (a).\n3. Sempre que encontrar mÃºltiplas informaÃ§Ãµes relevantes, crie mÃºltiplas perguntas e respostas.\n4. Mantenha a originalidade e fidelidade ao conteÃºdo fornecido.\n\nChunk:\n${chunkItem.chunk}`\n        }\n      ],\n      response_format: {\n        type: \"json_schema\",\n        json_schema: {\n          name: \"extracted_data\",\n          strict: true,\n          schema: {\n            type: \"object\",\n            properties: {\n              results: {\n                type: \"array\",\n                items: {\n                  type: \"object\",\n                  properties: {\n                    a: { type: \"string\", description: \"A resposta ou informaÃ§Ã£o extraÃ­da.\" },\n                    t: { type: \"string\", description: \"O trecho exato do documento de onde a resposta foi retirada.\" },\n                    q: { type: \"string\", description: \"A pergunta principal que leva Ã  resposta.\" },\n                    sq: { type: \"array\", items: { type: \"string\" }, description: \"Perguntas alternativas que poderiam obter a mesma resposta.\" }\n                  },\n                  required: [\"a\", \"t\", \"q\", \"sq\"],\n                  additionalProperties: false\n                }\n              }\n            },\n            required: [\"results\"],\n            additionalProperties: false\n          }\n        }\n      }\n    };\n    try {\n      const vectorResponse = await axios.post(\n        'https://openrouter.ai/api/v1/chat/completions',\n        vectorPromptBody,\n        { headers: { Authorization: `Bearer ${openrouterKey}` } }\n      );\n      // Envia a resposta para o webhook incluindo global_vars, knowledge_trigger_id, pinecone_host e namespace\n      await axios.post(\n        `http://${n8nWebhookService}:5678/webhook/vector`,\n        {\n          ...vectorResponse.data,\n          global_vars: globalVars,\n          knowledge_trigger_id: knowledgeTriggerId,\n          pinecone_host: globalData.pinecone_host,\n          namespace: globalData.namespace\n        }\n      );\n    } catch (err) {\n      console.error('Erro ao gerar vetor para chunk:', err.message);\n    }\n    // Aguarda 10 segundos antes da prÃ³xima requisiÃ§Ã£o\n    await delay(10000);\n  }\n\n  return { files: fileResults, scraping: scrapeResults, description: finalDescription, chunks };\n}\n\nreturn processScraping()\n  .then(result => [{ json: result }])\n  .catch(error => {\n    console.error('Erro geral:', { message: error.message, details: error });\n    return [{ json: { error: error.message, details: error } }];\n  });"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -900,
        1860
      ],
      "id": "c2119d41-b433-48e6-9ebf-8a8e3b14dc0e",
      "name": "Process Docs"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "vector",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -580,
        1860
      ],
      "id": "9409bd76-0209-4faf-b1c6-8366498d25f4",
      "name": "Vector Trigger",
      "webhookId": "31a23ccc-c8b7-4a93-980c-783c0490d567"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $('Vector Trigger').first().json.body.global_vars.openai_key }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "input",
              "value": "={{ `Context: ${$('Split Vectors').item.json.t} Question: ${$('Split Vectors').item.json.q} Answer: ${$('Split Vectors').item.json.a} Similar Questions: ${$('Split Vectors').item.json.sq.join(\", \")}` }}"
            },
            {
              "name": "model",
              "value": "text-embedding-3-small"
            },
            {
              "name": "dimensions",
              "value": "={{ 1536 }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        20,
        1860
      ],
      "id": "495d7b40-b13f-433f-84cf-f7b455df6cdf",
      "name": "Embeddings",
      "notesInFlow": true
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={{ $json.body.choices[0].message.content.parseJson() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -380,
        1860
      ],
      "id": "2ceeb8fc-b92f-40e2-8c70-e114a08fcbd1",
      "name": "Parse JSON 2"
    },
    {
      "parameters": {
        "fieldToSplitOut": "results",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -180,
        1860
      ],
      "id": "3c0916ed-56a7-4e32-9e9c-3e0b71c9ef09",
      "name": "Split Vectors"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH new_vector AS (\n  INSERT INTO vectors \n    (id, date_created, question, answer, context, similar_questions, knowledge_id)\n  VALUES \n    (\n      uuid_generate_v4(), \n      NOW(), \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].q }} $$, \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].a }} $$, \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].t }} $$, \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].sq.join(',') }} $$, \n      {{ $('Vector Trigger').item.json.body.knowledge_trigger_id }}\n    )\n  RETURNING id AS vector_id\n),\nnew_dimension AS (\n  INSERT INTO dimensions (values, date_created, vector_id)\n  SELECT $$ {{ $('Embeddings').item.json.data[0].embedding.join(',') }} $$, NOW(), vector_id\n  FROM new_vector\n  RETURNING vector_id\n)\nINSERT INTO vectors_status (vector_id, value)\nSELECT vector_id, '#2ECDA7'\nFROM new_vector\nRETURNING vector_id;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        220,
        1860
      ],
      "id": "4bbeb6e1-2bb9-455f-9383-4852ee74b9f9",
      "name": "Add Vectors",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rag",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1300,
        2180
      ],
      "id": "e564df0d-aad6-40d2-8d7a-018d6c709550",
      "name": "RAG Input",
      "webhookId": "d503e6f9-0989-42d5-a598-e268b20c3182"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Por favor, analise a entrada do usuÃ¡rio e o histÃ³rico recente. \n\nEntrada do usuÃ¡rio: \n<user_input>{{ $('RAG Input').first().json.body.content }}</user_input>\n\nHistÃ³rico das Ãºltimas 10 mensagens: \n<conversation_history>{{ $('Get History').first().json.chat_histories.map(item => item.message).slice(-10).toJsonString() }}</conversation_history>",
        "options": {
          "systemMessage": "=VocÃª Ã© um agente especializado em realizar buscas no banco vetorial para fornecer contexto adicional Ã  inteligÃªncia artificial principal.\n\nObjetivo:\nAnalisar a entrada do usuÃ¡rio e o histÃ³rico recente de mensagens para decidir se deve invocar a tool 'retriever' e, caso necessÃ¡rio, realizar buscas eficientes.\n\nDiretrizes:\nBusca desnecessÃ¡ria: Se a entrada do usuÃ¡rio nÃ£o contiver perguntas relevantes ou especÃ­ficas (ex.: saudaÃ§Ãµes, mensagens genÃ©ricas ou irrelevantes), retorne: \"Busca desnecessÃ¡ria.\"\nNenhuma informaÃ§Ã£o encontrada: Se, ao usar a tool 'retriever', nenhuma informaÃ§Ã£o relevante for encontrada, retorne: \"Nenhuma informaÃ§Ã£o relevante encontrada.\"\nForneÃ§a respostas precisas: Se encontrar informaÃ§Ãµes no banco vetorial, forneÃ§a apenas o conteÃºdo necessÃ¡rio para responder Ã  solicitaÃ§Ã£o do usuÃ¡rio, de forma objetiva e sem interpretaÃ§Ãµes adicionais.\nRegras para invocar a tool 'retriever':\nAnalise cuidadosamente a entrada do usuÃ¡rio e as descriÃ§Ãµes dos conhecimentos disponÃ­veis para identificar qualquer possibilidade de relaÃ§Ã£o com os temas abordados nos conhecimentos.\nConsidere como relevante qualquer pergunta do usuÃ¡rio que possa estar relacionada aos documentos descritos nos conhecimentos disponÃ­veis. Se houver uma chance de associaÃ§Ã£o, a busca deve ser realizada.\nUse as descriÃ§Ãµes dos conhecimentos disponÃ­veis para identificar o knowledge_id mais adequado:\n\n<knowledge_metadata>{{ $('Get History').first().json.knowledge.map(item => ({ knowledge_id: item.id, description: item.description })).toJsonString() }}</knowledge_metadata>\n\nUse mÃºltiplas queries, se necessÃ¡rio: Se a solicitaÃ§Ã£o do usuÃ¡rio for ampla ou ambÃ­gua, faÃ§a buscas utilizando palavras-chave diferentes para cobrir todas as possibilidades.\nCombine os resultados de forma precisa e concisa, retornando apenas o contexto essencial Ã  AI principal.\nInstruÃ§Ãµes adicionais:\nSe houver qualquer relaÃ§Ã£o potencial entre a solicitaÃ§Ã£o do usuÃ¡rio e os conhecimentos disponÃ­veis, realize a busca imediatamente.\nAo invocar a tool 'retriever', faÃ§a perguntas claras e precisas, alinhadas ao contexto da entrada do usuÃ¡rio e aos temas descritos nos conhecimentos disponÃ­veis.\nO foco Ã© fornecer contexto relevante e direto para a AI principal.",
          "passthroughBinaryImages": true
        }
      },
      "id": "a2ded5bf-177d-4a12-89b4-b8eab7ca769c",
      "name": "RAG Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        -900,
        2180
      ],
      "retryOnFail": false,
      "executeOnce": false
    },
    {
      "parameters": {
        "name": "retriever",
        "description": "=Invoque essa tool para buscar informaÃ§Ãµes no banco vetorial e fornecer respostas relevantes com base nos conhecimentos disponÃ­veis. Use-a somente quando necessÃ¡rio para complementar o contexto.",
        "jsCode": "const axios = require('axios');\n\nasync function runTool() {\n  let logs = \"\";\n  \n  try {\n    // Obter parÃ¢metros de entrada\n    logs += \"Obtendo parÃ¢metros de entrada...\\n\";\n    const searchQuery = query.query;\n    const knowledgeId = query.knowledge_id;\n    logs += `searchQuery: ${searchQuery}\\nknowledgeId: ${knowledgeId}\\n`;\n    \n    // Obter mapping a partir do nÃ³ \"RAG Input\"\n    let mappingInput = $('RAG Input').first().json.body.mapping;\n    if (typeof mappingInput === 'string') {\n      try {\n        mappingInput = JSON.parse(mappingInput);\n        logs += \"Mapping Input convertido de string para objeto.\\n\";\n      } catch (e) {\n        throw new Error(\"Falha ao converter mapping para objeto.\");\n      }\n    }\n    logs += \"Mapping Input obtido.\\n\";\n    \n    if (!mappingInput.system) {\n      throw new Error(\"mappingInput.system estÃ¡ indefinido.\");\n    }\n    \n    // Gerar embeddings usando a API do OpenAI\n    logs += \"Chamando endpoint de embeddings da OpenAI...\\n\";\n    const openaiKey = mappingInput.system.openai_key;\n    const embeddingResponse = await axios.post(\n      'https://api.openai.com/v1/embeddings',\n      {\n        input: searchQuery,\n        model: \"text-embedding-3-small\"\n      },\n      {\n        headers: {\n          \"Authorization\": `Bearer ${openaiKey}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    logs += \"Embeddings obtidos com sucesso.\\n\";\n    const embedding = embeddingResponse.data.data[0].embedding;\n    logs += `Embedding (primeiros 5 valores): ${embedding.slice(0,5).join(\", \")}...\\n`;\n    \n    // Obter pinecone_host e namespace do histÃ³rico\n    logs += \"Obtendo pinecone_host e namespace a partir do histÃ³rico...\\n\";\n    const historyKnowledge = $('Get History').first().json.knowledge;\n    const knowledgeItem = historyKnowledge.find(item => item.id === knowledgeId);\n    if (!knowledgeItem) {\n      throw new Error(`Conhecimento com id ${knowledgeId} nÃ£o encontrado.`);\n    }\n    const pineconeHostRaw = knowledgeItem.pinecone_host;\n    const namespace = knowledgeItem.namespace;\n    logs += `pineconeHostRaw: ${pineconeHostRaw}, namespace: ${namespace}\\n`;\n    \n    // Garantir que pinecone_host comece com \"https://\"\n    let pineconeHost = pineconeHostRaw;\n    if (!pineconeHost.startsWith(\"https://\")) {\n      pineconeHost = \"https://\" + pineconeHost;\n    }\n    logs += `pineconeHost final: ${pineconeHost}\\n`;\n    \n    // RequisiÃ§Ã£o para a API do Pinecone\n    logs += \"Chamando API do Pinecone...\\n\";\n    const pineconeKey = mappingInput.system.pinecone_key;\n    const pineconeQueryUrl = `${pineconeHost}/query`;\n    const pineconeResponse = await axios.post(\n      pineconeQueryUrl,\n      {\n        namespace: namespace,\n        vector: embedding,\n        topK: 3,\n        includeValues: false,\n        includeMetadata: true\n      },\n      {\n        headers: {\n          \"Api-Key\": pineconeKey,\n          \"X-Pinecone-API-Version\": \"2024-10\",\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    logs += \"Resposta do Pinecone obtida com sucesso.\\n\";\n    logs += `Pinecone response data: ${JSON.stringify(pineconeResponse.data)}\\n`;\n    \n    // Processar os resultados do Pinecone usando as chaves corretas dos metadados (\"a\", \"q\" e \"t\")\n    const matches = pineconeResponse.data.matches;\n    matches.forEach((m, idx) => {\n      logs += `Match ${idx + 1}: id=${m.id}, score=${m.score}, metadata=${JSON.stringify(m.metadata)}\\n`;\n    });\n    \n    const filteredMatches = matches.filter(item => item.score >= 0.0)\n      .map(item => ({\n        vector: item.id,\n        score: item.score,\n        answer: item.metadata ? item.metadata.a : null,\n        question: item.metadata ? item.metadata.q : null,\n        context: item.metadata ? item.metadata.t : null\n      }));\n    logs += `Matches filtrados: ${JSON.stringify(filteredMatches)}\\n`;\n    \n    const resultString = `Os vetores retornados foram: ${JSON.stringify(filteredMatches)}`;\n    logs += \"Processamento final concluÃ­do.\\n\";\n    \n    console.log(\"Logs:\", logs);\n    // Retorna apenas o resultado final (string) sem os logs.\n    return resultString;\n  } catch (error) {\n    logs += `Erro: ${error.message}\\n`;\n    console.error(\"Erro:\", error.message, \"Logs:\", logs);\n    return `Erro: ${error.message}`;\n  }\n}\n\nreturn runTool();\n",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"knowledge_id\": {\n      \"type\": \"integer\",\n      \"description\": \"O ID do conhecimento especÃ­fico no qual a busca serÃ¡ realizada.\"\n    },\n    \"query\": {\n      \"type\": \"string\",\n      \"description\": \"A pergunta ou consulta que serÃ¡ usada para realizar a busca no banco vetorial.\"\n    }\n  }\n}"
      },
      "id": "41fc08f8-545b-4630-aa13-8ec4b7b26c85",
      "name": "Retriever",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        -600,
        2460
      ]
    },
    {
      "parameters": {
        "content": "",
        "height": 660,
        "width": 1860,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1420,
        1740
      ],
      "typeVersion": 1,
      "id": "8cca0dfb-74e9-479b-85a4-daeb7626a164",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1100,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1400,
        2080
      ],
      "id": "be558bf9-3986-490d-97da-afe857ba3cd7",
      "name": "Sticky Note9"
    },
    {
      "parameters": {
        "content": "",
        "width": 300,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -780,
        2420
      ],
      "typeVersion": 1,
      "id": "bb80c8c5-a160-46fa-a53f-c0fbe1e83fe7",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "model": "={{ $('RAG Input').item.json.body.mapping.parseJson().system.model }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -720,
        2460
      ],
      "id": "d2ffb844-73bd-434b-82f3-a24f1961c2b0",
      "name": "OpenRouter ",
      "credentials": {
        "openRouterApi": {
          "id": "fbVI3oy00ZqZFPfH",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 700,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1400,
        1760
      ],
      "id": "b1c86e44-32d6-4db3-aea5-094e05d0e47f",
      "name": "Sticky Note10"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1100,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -680,
        1760
      ],
      "id": "1bfd9788-7df8-4dcb-aa39-e3d9e3c3bc3b",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"chatwoot\": {\n    \"account_id\": {{ $('Consumer').first().json.body.account.id }},\n    \"contact_id\": {{ $('Consumer').first().json.body.conversation.contact_inbox.contact_id }},\n\n    \"conversation_id\": {{ $('Consumer').first().json.body.conversation.messages[0].conversation_id }},\n    \"sender_type\": {{ JSON.stringify($('Consumer').first().json.body.conversation.messages[0].sender_type) }},\n    \"bot_token\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.bot_token) }},\n    \"conversation_status\": {{ JSON.stringify($json.current_status) }},\n    \"assignee\": {{ JSON.stringify($('Consumer').first().json.body.conversation?.meta?.assignee?.name || null ) }},\n    \n    \"content\": {{ JSON.stringify(\n      ($('Consumer').first().json.body?.content || '')\n        .replace(\n          /^\\*\\*(.*?)\\*\\*\\n\\n/,\n          $('Consumer').first().json.body.sender.identifier?.match(/@g\\.us$/) ? '' : '$&'\n        )\n        .replace(\n          new RegExp('@' + ($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, ''), 'g'),\n          '@YOU'\n        )\n        .trim()\n    ) }},\n    \n    \"data_url\": {{ JSON.stringify(\n        $('Consumer').first().json.body.conversation.messages?.[0]?.attachments?.[0]?.data_url || null\n      )\n    }},\n    \n    \"message_id\": {{ $('Consumer').first().json.body.id }},\n    \n    \"channel\": {{\n      JSON.stringify(\n        $('Consumer').first().json.body.conversation.channel === 'Channel::Api' \n        ? (\n            /@s\\.whatsapp\\.net$/.test($('Consumer').first().json.body.sender.identifier) \n            ? 'WhatsApp Web' \n            : /@g\\.us$/.test($('Consumer').first().json.body.sender.identifier) \n            ? 'WhatsApp Web Group' \n            : $('Consumer').first().json.body.conversation.channel.replace('Channel::', '')\n          ) \n        : $('Consumer').first().json.body.conversation.channel.replace('Channel::', '')\n      )\n    }},\n    \n    \"user_name\": {{ JSON.stringify(\n      $('Consumer').first().json.body.sender.identifier?.match(/@g\\.us$/)\n        ? (\n            $('Consumer').first().json.body?.content?.match(/^\\*\\*(.*?)\\*\\*/)?.[1] || ''\n          )\n        : $('Consumer').first().json.body.sender?.name || ''\n    ) }},\n\n    \"phone_number\": {{ JSON.stringify($('Consumer').first().json.body.sender.phone_number) || null }},\n\n    \"events\": {{ JSON.stringify($('Get Vars').first().json.events) }}\n  },\n  \n  \"system\": {\n    \"cooldown\": {{ $('Get Vars').first().json.ai_agents.cooldown }},\n    \"workflow_path\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.workflow_path) }},\n    \"model\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.model) }},\n    \"openai_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.openai_key) }},\n    \"directus_token\": {{ JSON.stringify($('Get Vars').first().json.global_vars.directus_token) }},\n    \"stirling_pdf_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.stirling_pdf_key) }},\n    \"elevenlabs_key\": \"{{ $('Get Vars').first().json.global_vars.elevenlabs_key }}\",\n    \"conversations_id\": {{ JSON.stringify($('Get Vars').first().json.conversations.id) }},\n    \"context_window\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.context_window) }},\n    \"enabled_condition\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.enabled_condition) }},\n    \"allow_whatsapp_groups\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.allow_whatsapp_groups) }},\n    \"allow_human_interruption\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.allow_human_interruption) }},\n    \"agent_phone_number\": {{ JSON.stringify(($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, '')) }},\n    \"agent_mentioned\": {{ JSON.stringify(($('Consumer').first().json.body?.content || '' ).includes('@' + ($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, ''))) }},\n    \"agent_name\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.name) }},\n    \"system_message\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.system_message) }},\n    \"user_type\": {{ JSON.stringify($('Get Vars').first().json.users.type) }},\n    \"output_format\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.output_format) }},\n    \"elevenlabs_model\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.elevenlabs_model) }},\n    \"elevenlabs_voice\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.elevenlabs_voice) }},\n    \"chatwoot_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.chatwoot_service) }},\n    \"n8n_webhook_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.n8n_webhook_service) }},\n    \"stirling_pdf_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.stirling_pdf_service) }},\n    \"directus_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.directus_service) }},\n    \"enabled_rag\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.enabled_rag) }},\n    \"ai_agent_id\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.id) }},\n    \"pinecone_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.pinecone_key) }},\n    \"downtime\": {{ new Date(\"1970-01-01T\" + $('Get Vars').first().json.ai_agents.downtime + \"Z\").getTime() / 1000 }},\n    \"clientId\": {{ JSON.stringify($('Get Vars').first().json.global_vars.clientId) }},\n    \"clientSecret\": {{ JSON.stringify($('Get Vars').first().json.global_vars.clientSecret) }},\n    \"refreshToken\": {{ JSON.stringify($('Get Vars').first().json.global_vars.refreshToken) }},\n    \"accessToken\": {{ JSON.stringify($('Get Vars').first().json.global_vars.accessToken) }},\n    \"core_chat_histories\": {{ JSON.stringify($('Get Vars').item.json.core_chat_histories, null, 2) }}\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -700,
        580
      ],
      "id": "cc1cc3ea-47e2-439b-9960-b775136dd90b",
      "name": "Mapping"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        300,
        1100
      ],
      "id": "1391b948-718b-45b7-a5aa-29bc0d8c009f",
      "name": "No Operation "
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\nasync function runTool() {\n  const logArray = [];\n  let currentStatus = \"\";\n  \n  try {\n    console.log(\"Obtendo data de Ãºltima interaÃ§Ã£o e downtime...\");\n    logArray.push(\"Obtendo data de Ãºltima interaÃ§Ã£o e downtime...\");\n    \n    const dateUpdatedStr = $('Get Vars').first().json.users.date_updated;\n    const downtimeStr = $('Get Vars').first().json.ai_agents.downtime;\n    console.log(`date_updated: ${dateUpdatedStr}`);\n    console.log(`downtime: ${downtimeStr}`);\n    logArray.push(`date_updated: ${dateUpdatedStr}`);\n    logArray.push(`downtime: ${downtimeStr}`);\n    \n    // Se downtime for \"00:00:00\", considere desativado e nÃ£o realizar a requisiÃ§Ã£o.\n    if (downtimeStr === \"00:00:00\") {\n      console.log(\"Downtime Ã© 00:00:00. Nenhuma aÃ§Ã£o serÃ¡ realizada.\");\n      logArray.push(\"Downtime Ã© 00:00:00. Nenhuma aÃ§Ã£o serÃ¡ realizada.\");\n      currentStatus = $('Consumer').first().json.body.conversation.status;\n      return [{ json: { current_status: currentStatus, logs: logArray } }];\n    }\n    \n    const lastUpdated = new Date(dateUpdatedStr);\n    const now = new Date();\n    const diffMs = now - lastUpdated;\n    const diffMinutes = (diffMs / 60000).toFixed(2);\n    \n    // Converter downtime (HH:MM:SS) para milissegundos e para minutos\n    const [hours, minutes, seconds] = downtimeStr.split(':').map(Number);\n    const downtimeMs = ((hours * 3600) + (minutes * 60) + seconds) * 1000;\n    const downtimeMinutes = (downtimeMs / 60000).toFixed(2);\n    \n    console.log(`diff: ${diffMinutes} minutes, downtime: ${downtimeMinutes} minutes`);\n    logArray.push(`diff: ${diffMinutes} minutes, downtime: ${downtimeMinutes} minutes`);\n    \n    // Obter conversation status e conversation_id do nÃ³ Consumer\n    const conversationStatus = $('Consumer').first().json.body.conversation.status;\n    const convId = $('Consumer').first().json.body.conversation.messages[0].conversation_id;\n    console.log(`conversation status: ${conversationStatus}`);\n    console.log(`conversation_id: ${convId}`);\n    logArray.push(`conversation status: ${conversationStatus}`);\n    logArray.push(`conversation_id: ${convId}`);\n    \n    // Inicialmente, currentStatus recebe o status atual\n    currentStatus = conversationStatus;\n    \n    // Verifica se o tempo de inatividade foi excedido e se conversation.status Ã© diferente de \"pending\"\n    if (diffMs >= downtimeMs && conversationStatus !== \"pending\") {\n      console.log(\"CondiÃ§Ãµes atendidas: tempo de inatividade excedido e conversation.status nÃ£o Ã© 'pending'.\");\n      logArray.push(\"CondiÃ§Ãµes atendidas: tempo de inatividade excedido e conversation.status nÃ£o Ã© 'pending'. Tentando abrir conversa no Chatwoot...\");\n      \n      const chatwootService = $('Get Vars').first().json.global_vars.chatwoot_service;\n      const accountId = $('Consumer').first().json.body.account.id;\n      const conversationId = convId;\n      const botToken = $('Get Vars').first().json.ai_agents.bot_token;\n      \n      const toggleUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/toggle_status`;\n      console.log(`Toggle URL: ${toggleUrl}`);\n      logArray.push(`Toggle URL: ${toggleUrl}`);\n      \n      try {\n        const response = await axios.post(\n          toggleUrl,\n          { status: \"pending\" },\n          { headers: { api_access_token: botToken } }\n        );\n        console.log(\"Conversa aberta com sucesso no Chatwoot.\");\n        logArray.push(\"Conversa aberta com sucesso no Chatwoot.\");\n        currentStatus = \"pending\";\n      } catch (err) {\n        console.error(\"Erro ao abrir conversa:\", err.message);\n        logArray.push(`Erro ao abrir conversa: ${err.message}`);\n      }\n    } else {\n      console.log(\"CondiÃ§Ãµes nÃ£o atendidas: tempo de inatividade nÃ£o excedido ou conversation.status Ã© 'pending'. Nenhuma aÃ§Ã£o realizada.\");\n      logArray.push(\"CondiÃ§Ãµes nÃ£o atendidas: tempo de inatividade nÃ£o excedido ou conversation.status Ã© 'pending'. Nenhuma aÃ§Ã£o realizada.\");\n    }\n    \n    return [{ json: { current_status: currentStatus, logs: logArray } }];\n  } catch (error) {\n    console.error(\"Erro geral:\", error.message);\n    logArray.push(`Erro geral: ${error.message}`);\n    return [{ json: { error: error.message, current_status: currentStatus, logs: logArray } }];\n  }\n}\n\nreturn runTool();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -900,
        580
      ],
      "id": "9990a106-8f3e-402f-8a23-6af38a90cf44",
      "name": "Downtime",
      "alwaysOutputData": false
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -100,
        1300
      ],
      "id": "8508753a-1eb9-4d07-9fc3-a171ba5a866f",
      "name": "No Operation 0"
    },
    {
      "parameters": {
        "triggerMode": "listenTrigger",
        "channelName": "specific_channel",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTrigger",
      "typeVersion": 1,
      "position": [
        -180,
        2180
      ],
      "id": "14a66f3e-937f-4bfc-9c10-4772492baffb",
      "name": "Postgres Trigger",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "async function main() {\n  // FunÃ§Ã£o auxiliar para limitar o tamanho dos logs\n  const trimLog = (msg, limit = 100) =>\n    (typeof msg === 'string' && msg.length > limit ? msg.substring(0, limit) + '...' : msg);\n\n  // Array para armazenar os logs de debug\n  let logs = [];\n\n  try {\n    // ObtÃ©m o payload do nÃ³ \"Postgres Trigger\"\n    const payload = $('Postgres Trigger').first().json.payload;\n    logs.push(\"Payload carregado.\");\n    console.log(\"Payload:\", trimLog(JSON.stringify(payload)));\n\n    // Determina a operaÃ§Ã£o\n    const op = payload.operation;\n    logs.push(\"OperaÃ§Ã£o: \" + op);\n    console.log(\"OperaÃ§Ã£o:\", op);\n\n    // Garante que pinecone_host comece com \"https://\"\n    let pineconeHost = payload.data.pinecone_host;\n    if (!pineconeHost.startsWith(\"https://\")) {\n      pineconeHost = \"https://\" + pineconeHost;\n      logs.push(\"Prefixo 'https://' adicionado.\");\n      console.log(\"pinecone_host modificado:\", pineconeHost);\n    }\n\n    // Configura os headers para o Pinecone\n    const pineconeHeaders = {\n      \"Api-Key\": payload.global_vars.pinecone_key,\n      \"X-Pinecone-API-Version\": \"2024-10\",\n      \"Content-Type\": \"application/json\"\n    };\n    logs.push(\"Headers Pinecone configurados.\");\n    console.log(\"Headers Pinecone:\", pineconeHeaders);\n\n    let endpoint, options, response, mainResponse;\n\n    // Branch para deleÃ§Ã£o: DISABLED ou DELETE\n    if (op === \"DISABLED\" || op === \"DELETE\") {\n      endpoint = pineconeHost + \"/vectors/delete\";\n      logs.push(\"Endpoint para deleÃ§Ã£o: \" + endpoint);\n      console.log(\"Endpoint de deleÃ§Ã£o:\", endpoint);\n\n      const deleteBody = {\n        ids: [payload.data.id],\n        namespace: payload.data.namespace\n      };\n      logs.push(\"Body para deleÃ§Ã£o: \" + trimLog(JSON.stringify(deleteBody)));\n      console.log(\"Body de deleÃ§Ã£o:\", deleteBody);\n\n      options = {\n        method: \"POST\",\n        uri: endpoint,\n        headers: pineconeHeaders,\n        body: deleteBody,\n        json: true\n      };\n\n      response = await this.helpers.request(options);\n      logs.push(\"Resposta da deleÃ§Ã£o recebida.\");\n      console.log(\"Resposta da deleÃ§Ã£o:\", trimLog(JSON.stringify(response)));\n\n      mainResponse = response;\n\n    // Branch para upsert via OpenAI (para UPDATE ou INSERT com enabled true)\n    } else if ((op === \"UPDATE\" || op === \"INSERT\") && payload.data.enabled === true) {\n      let embedding; // Para o upsert no Pinecone\n\n      // Se for INSERT, verifica se jÃ¡ existe embedding em Directus (tabela dimensions)\n      if (op === \"INSERT\") {\n        const directusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\n        const directusEndpoint = directusHost + \"/items/dimensions\";\n        const directusHeaders = {\n          \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n          \"Content-Type\": \"application/json\"\n        };\n        logs.push(\"Consultando Directus (dimensions) para vector_id: \" + payload.data.id);\n        console.log(\"Directus endpoint (dimensions):\", directusEndpoint);\n\n        const directusQueryOptions = {\n          method: \"GET\",\n          uri: directusEndpoint,\n          qs: { \"filter[vector_id][_eq]\": payload.data.id },\n          headers: directusHeaders,\n          json: true\n        };\n\n        let directusRecord = await this.helpers.request(directusQueryOptions);\n        logs.push(\"Resposta Directus (dimensions): \" + trimLog(JSON.stringify(directusRecord)));\n        console.log(\"Directus GET response (dimensions):\", trimLog(JSON.stringify(directusRecord)));\n\n        if (\n          directusRecord &&\n          directusRecord.data &&\n          directusRecord.data.length > 0 &&\n          directusRecord.data[0].values\n        ) {\n          let directusValues = directusRecord.data[0].values;\n          // Se for string, converte para array de floats; se jÃ¡ for array, utiliza diretamente.\n          if (typeof directusValues === \"string\") {\n            embedding = directusValues.split(\",\").map(item => parseFloat(item.trim()));\n          } else if (Array.isArray(directusValues)) {\n            embedding = directusValues;\n          }\n          logs.push(\"Embedding reutilizado do Directus (dimensions).\");\n          console.log(\"Embedding reutilizado:\", trimLog(JSON.stringify(embedding)));\n        }\n      }\n\n      // Se embedding nÃ£o foi obtido (ou para UPDATE), gere via OpenAI\n      if (!embedding) {\n        const openAIEndpoint = \"https://api.openai.com/v1/embeddings\";\n        const openAIHeaders = {\n          \"Authorization\": \"Bearer \" + payload.global_vars.openai_key,\n          \"Content-Type\": \"application/json\"\n        };\n        logs.push(\"Endpoint OpenAI: \" + openAIEndpoint);\n        console.log(\"Endpoint OpenAI:\", openAIEndpoint);\n        logs.push(\"Headers OpenAI configurados.\");\n        console.log(\"Headers OpenAI:\", openAIHeaders);\n\n        // ConstrÃ³i o input para OpenAI (adiciona espaÃ§o apÃ³s cada vÃ­rgula em similar_questions)\n        const similarQuestionsInput = payload.data.similar_questions\n          ? payload.data.similar_questions.replace(/,/g, ', ')\n          : \"\";\n        const openAIInput = `Context: ${payload.data.context} Question: ${payload.data.question} Answer: ${payload.data.answer} Similar Questions: ${similarQuestionsInput}`;\n        logs.push(\"Input para OpenAI: \" + trimLog(openAIInput));\n        console.log(\"Input OpenAI:\", openAIInput);\n\n        const openAIBody = {\n          input: openAIInput,\n          model: \"text-embedding-3-small\",\n          dimensions: 1536\n        };\n        logs.push(\"Body para OpenAI: \" + trimLog(JSON.stringify(openAIBody)));\n        console.log(\"Body OpenAI:\", openAIBody);\n\n        options = {\n          method: \"POST\",\n          uri: openAIEndpoint,\n          headers: openAIHeaders,\n          body: openAIBody,\n          json: true\n        };\n\n        let openAIResponse = await this.helpers.request(options);\n        logs.push(\"Resposta do OpenAI recebida.\");\n        console.log(\"Resposta OpenAI:\", trimLog(JSON.stringify(openAIResponse)));\n\n        if (openAIResponse && openAIResponse.data && openAIResponse.data.length > 0) {\n          embedding = openAIResponse.data[0].embedding;\n          logs.push(\"Embedding extraÃ­do do OpenAI.\");\n          console.log(\"Embedding:\", trimLog(JSON.stringify(embedding)));\n        } else {\n          throw new Error(\"Embedding nÃ£o retornado pelo OpenAI.\");\n        }\n      }\n\n      // Converte similar_questions CSV para array\n      let similarQuestionsArray = [];\n      if (payload.data.similar_questions) {\n        similarQuestionsArray = payload.data.similar_questions.split(\",\").map(s => s.trim());\n      }\n      logs.push(\"similar_questions convertido para array: \" + trimLog(JSON.stringify(similarQuestionsArray)));\n      console.log(\"similar_questions array:\", similarQuestionsArray);\n\n      // Upsert no Pinecone usando o embedding obtido\n      endpoint = pineconeHost + \"/vectors/upsert\";\n      logs.push(\"Endpoint para upsert (Pinecone): \" + endpoint);\n      console.log(\"Endpoint de upsert:\", endpoint);\n\n      const upsertBody = {\n        vectors: [\n          {\n            id: payload.data.id,\n            values: embedding, // embedding Ã© um array de floats\n            metadata: {\n              a: payload.data.answer,\n              t: payload.data.context,\n              q: payload.data.question,\n              sq: similarQuestionsArray\n            }\n          }\n        ],\n        namespace: payload.data.namespace\n      };\n      logs.push(\"Body para upsert (Pinecone): \" + trimLog(JSON.stringify(upsertBody)));\n      console.log(\"Body de upsert:\", upsertBody);\n\n      options = {\n        method: \"POST\",\n        uri: endpoint,\n        headers: pineconeHeaders,\n        body: upsertBody,\n        json: true\n      };\n\n      response = await this.helpers.request(options);\n      logs.push(\"Resposta do upsert Pinecone recebida.\");\n      console.log(\"Resposta do upsert:\", trimLog(JSON.stringify(response)));\n\n      mainResponse = response;\n\n      // Atualiza ou cria o registro na tabela dimensions do Directus (como jÃ¡ estava implementado)\n      const directusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\n      const directusDimensionsEndpoint = directusHost + \"/items/dimensions\";\n      const directusHeaders = {\n        \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n        \"Content-Type\": \"application/json\"\n      };\n      logs.push(\"Directus dimensions endpoint: \" + directusDimensionsEndpoint);\n      console.log(\"Directus dimensions endpoint:\", directusDimensionsEndpoint);\n\n      const directusQueryOptions = {\n        method: \"GET\",\n        uri: directusDimensionsEndpoint,\n        qs: { \"filter[vector_id][_eq]\": payload.data.id },\n        headers: directusHeaders,\n        json: true\n      };\n\n      let directusRecord = await this.helpers.request(directusQueryOptions);\n      logs.push(\"Resposta Directus (dimensions): \" + trimLog(JSON.stringify(directusRecord)));\n      console.log(\"Directus GET response (dimensions):\", trimLog(JSON.stringify(directusRecord)));\n\n      const currentTimestamp = new Date().toISOString();\n      // Converte o embedding para string sem colchetes\n      const directusValues = Array.isArray(embedding) ? embedding.join(\",\") : embedding;\n      const dimensionsBody = {\n        values: directusValues,\n        vector_id: payload.data.id,\n        date_created: currentTimestamp,\n        date_updated: currentTimestamp\n      };\n\n      if (directusRecord && directusRecord.data && directusRecord.data.length > 0) {\n        const recordId = directusRecord.data[0].id;\n        const directusUpdateEndpoint = directusDimensionsEndpoint + \"/\" + recordId;\n        logs.push(\"Atualizando registro dimensions Directus com id: \" + recordId);\n        console.log(\"Atualizando Directus dimensions em:\", directusUpdateEndpoint);\n\n        const directusUpdateOptions = {\n          method: \"PATCH\",\n          uri: directusUpdateEndpoint,\n          headers: directusHeaders,\n          body: dimensionsBody,\n          json: true\n        };\n\n        const directusUpdateResponse = await this.helpers.request(directusUpdateOptions);\n        logs.push(\"Resposta atualizaÃ§Ã£o Directus dimensions: \" + trimLog(JSON.stringify(directusUpdateResponse)));\n        console.log(\"Directus dimensions update response:\", trimLog(JSON.stringify(directusUpdateResponse)));\n      } else {\n        logs.push(\"Nenhum registro Dimensions Directus encontrado, criando novo.\");\n        console.log(\"Criando novo registro Dimensions Directus.\");\n\n        const directusCreateOptions = {\n          method: \"POST\",\n          uri: directusDimensionsEndpoint,\n          headers: directusHeaders,\n          body: dimensionsBody,\n          json: true\n        };\n\n        const directusCreateResponse = await this.helpers.request(directusCreateOptions);\n        logs.push(\"Resposta criaÃ§Ã£o Directus dimensions: \" + trimLog(JSON.stringify(directusCreateResponse)));\n        console.log(\"Directus dimensions create response:\", trimLog(JSON.stringify(directusCreateResponse)));\n      }\n\n    // Branch para upsert usando valores do \"Get Dimensions\" (caso op seja ENABLED)\n    } else if (op === \"ENABLED\") {\n      endpoint = pineconeHost + \"/vectors/upsert\";\n      logs.push(\"Endpoint para upsert (Get Dimensions): \" + endpoint);\n      console.log(\"Endpoint de upsert:\", endpoint);\n\n      let similarQuestionsArray = [];\n      if (payload.data.similar_questions) {\n        similarQuestionsArray = payload.data.similar_questions.split(\",\").map(s => s.trim());\n      }\n      logs.push(\"similar_questions convertido para array: \" + trimLog(JSON.stringify(similarQuestionsArray)));\n      console.log(\"similar_questions array:\", similarQuestionsArray);\n\n      let values = $('Get Dimensions').first().json.values;\n      if (typeof values === \"string\") {\n        values = values.split(\",\").map(item => parseFloat(item.trim()));\n        logs.push(\"Valores convertidos de string para array: \" + trimLog(JSON.stringify(values)));\n        console.log(\"Valores convertidos:\", values);\n      } else if (Array.isArray(values)) {\n        if (values.length > 0 && typeof values[0] === \"string\") {\n          values = values.map(item => parseFloat(item.trim()));\n          logs.push(\"Valores convertidos de array de strings para floats: \" + trimLog(JSON.stringify(values)));\n          console.log(\"Valores convertidos:\", values);\n        }\n      } else {\n        values = [values];\n        logs.push(\"Valores encapsulados em array: \" + trimLog(JSON.stringify(values)));\n        console.log(\"Valores encapsulados:\", values);\n      }\n\n      const upsertBody = {\n        vectors: [\n          {\n            id: payload.data.id,\n            values: values,\n            metadata: {\n              a: payload.data.answer,\n              t: payload.data.context,\n              q: payload.data.question,\n              sq: similarQuestionsArray\n            }\n          }\n        ],\n        namespace: payload.data.namespace\n      };\n      logs.push(\"Body para upsert (Get Dimensions): \" + trimLog(JSON.stringify(upsertBody)));\n      console.log(\"Body de upsert:\", upsertBody);\n\n      options = {\n        method: \"POST\",\n        uri: endpoint,\n        headers: pineconeHeaders,\n        body: upsertBody,\n        json: true\n      };\n\n      response = await this.helpers.request(options);\n      logs.push(\"Resposta do upsert recebida.\");\n      console.log(\"Resposta do upsert:\", trimLog(JSON.stringify(response)));\n\n      mainResponse = response;\n    } else {\n      logs.push(\"OperaÃ§Ã£o nÃ£o compatÃ­vel. Nenhuma requisiÃ§Ã£o enviada.\");\n      console.log(\"OperaÃ§Ã£o nÃ£o compatÃ­vel.\");\n      mainResponse = { message: \"OperaÃ§Ã£o nÃ£o compatÃ­vel.\" };\n    }\n\n    // Atualiza a tabela vectors_status para os casos ENABLED, DISABLED, INSERT ou UPDATE (ou DELETE)\n    if ([\"ENABLED\", \"DISABLED\", \"INSERT\", \"UPDATE\", \"DELETE\"].includes(op)) {\n      const statusValue = payload.data.enabled === true ? \"#2ECDA7\" : \"#E35169\";\n      const directusStatusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\n      const directusStatusEndpoint = directusStatusHost + \"/items/vectors_status\";\n      const directusHeaders = {\n        \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n        \"Content-Type\": \"application/json\"\n      };\n      logs.push(\"Atualizando tabela vectors_status em: \" + directusStatusEndpoint);\n      console.log(\"Directus vectors_status endpoint:\", directusStatusEndpoint);\n\n      const statusQueryOptions = {\n        method: \"GET\",\n        uri: directusStatusEndpoint,\n        qs: { \"filter[vector_id][_eq]\": payload.data.id },\n        headers: directusHeaders,\n        json: true\n      };\n\n      let statusRecord = await this.helpers.request(statusQueryOptions);\n      logs.push(\"Resposta da consulta vectors_status: \" + trimLog(JSON.stringify(statusRecord)));\n      console.log(\"Directus vectors_status GET response:\", trimLog(JSON.stringify(statusRecord)));\n\n      const currentTimestamp = new Date().toISOString();\n      const statusBody = {\n        value: statusValue,\n        vector_id: payload.data.id,\n        date_created: currentTimestamp,\n        date_updated: currentTimestamp\n      };\n\n      if (statusRecord && statusRecord.data && statusRecord.data.length > 0) {\n        const recordId = statusRecord.data[0].id;\n        const statusUpdateEndpoint = directusStatusEndpoint + \"/\" + recordId;\n        logs.push(\"Atualizando registro vectors_status com id: \" + recordId);\n        console.log(\"Atualizando vectors_status em:\", statusUpdateEndpoint);\n\n        const statusUpdateOptions = {\n          method: \"PATCH\",\n          uri: statusUpdateEndpoint,\n          headers: directusHeaders,\n          body: statusBody,\n          json: true\n        };\n\n        var statusResponse = await this.helpers.request(statusUpdateOptions);\n        logs.push(\"Resposta atualizaÃ§Ã£o vectors_status: \" + trimLog(JSON.stringify(statusResponse)));\n        console.log(\"Directus vectors_status update response:\", trimLog(JSON.stringify(statusResponse)));\n      } else {\n        logs.push(\"Nenhum registro vectors_status encontrado, criando novo.\");\n        console.log(\"Criando novo registro vectors_status.\");\n\n        const statusCreateOptions = {\n          method: \"POST\",\n          uri: directusStatusEndpoint,\n          headers: directusHeaders,\n          body: statusBody,\n          json: true\n        };\n\n        var statusResponse = await this.helpers.request(statusCreateOptions);\n        logs.push(\"Resposta criaÃ§Ã£o vectors_status: \" + trimLog(JSON.stringify(statusResponse)));\n        console.log(\"Directus vectors_status create response:\", trimLog(JSON.stringify(statusResponse)));\n      }\n    }\n\n    return [{\n      json: {\n        mainResponse,\n        logs\n      }\n    }];\n  } catch (error) {\n    console.error(\"Erro:\", error);\n    logs.push(\"Erro: \" + error.message);\n    return [{\n      json: {\n        error: error.message,\n        logs\n      }\n    }];\n  }\n}\n\nreturn main();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        2180
      ],
      "id": "d31c7c9a-a837-4f69-b5c7-9fa5e5a792d1",
      "name": "Update Vectors"
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "dimensions",
          "mode": "list",
          "cachedResultName": "dimensions"
        },
        "returnAll": true,
        "where": {
          "values": [
            {
              "column": "vector_id",
              "value": "={{ $json.payload.data.id }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        20,
        2180
      ],
      "id": "f62eaf07-9275-4845-bbf7-3a49cf42160c",
      "name": "Get Dimensions",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 700,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -280,
        2080
      ],
      "id": "4a2caf6e-ee2d-4767-9774-092cd7bff5cb",
      "name": "Sticky Note15"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -540,
        2180
      ],
      "id": "83b2bc4b-d2a1-4e10-adf2-86e70eb07f2e",
      "name": "No Operation 3"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH knowledge_descriptions AS (\n  SELECT json_agg(\n    json_build_object(\n      'id', k.id,\n      'description', k.description,\n      'pinecone_host', ph.value,\n      'namespace', ns.value\n    )\n  ) AS knowledge_data\n  FROM knowledge_ai_agents kaa\n  JOIN knowledge k ON k.id = kaa.knowledge_id\n  LEFT JOIN pinecone_host ph ON ph.id = k.pinecone_host_id\n  LEFT JOIN namespace ns ON ns.id = k.name_id\n  WHERE kaa.ai_agents_id = {{ $('RAG Input').item.json.body.mapping.parseJson().system.ai_agent_id }}\n),\nchat_histories AS (\n  SELECT json_agg(ch.*) AS chat_items\n  FROM core_chat_histories ch\n  WHERE ch.session_id = '{{ $('RAG Input').item.json.body.mapping.parseJson().system.conversations_id }}'\n)\nSELECT\n  (SELECT knowledge_data FROM knowledge_descriptions) AS knowledge,\n  (SELECT chat_items FROM chat_histories) AS chat_histories;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1100,
        2180
      ],
      "id": "fac17f0f-52f1-46a1-8978-93ff90435f7f",
      "name": "Get History",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "name": "scheduling",
        "description": "Ferramenta para gerenciar agendamentos e compromissos atravÃ©s do n8n. Processa solicitaÃ§Ãµes relacionadas a criaÃ§Ã£o, atualizaÃ§Ã£o, consulta e cancelamento de eventos agendados.\n",
        "jsCode": "// SchedulingAssistant tool for n8n\nconst axios = require('axios');\n\n// Parse the incoming query and mapping data\ntry {\n  // Access the operation from the input query\n  const params = query;\n  \n  // Get the mapping data\n  const mapping = JSON.parse($('Core Input').item.json.body.mapping);\n  \n  // Define the webhook URL using the mapping\n  const url = `http://${mapping.system.n8n_webhook_service}:5678/webhook/scheduling`;\n  \n  // Prepare payload with operation details\n  const payload = {\n    params: { \n      ...params \n    },\n    mapping: mapping\n  };\n  \n  // Send request to webhook endpoint\n  const response = await axios.post(url, payload);\n  \n  // Return webhook response as string\n  return JSON.stringify(response.data);\n  \n} catch (error) {\n  // Handle errors\n  return `Error processing request: ${error.message}`;\n}",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"operation\": {\n      \"type\": \"string\",\n      \"description\": \"The scheduling operation\",\n      \"enum\": [\"create\", \"update\", \"query\", \"delete\", \"query-slots\"]\n    },\n    \"dateTime\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"description\": \"Data e hora do agendamento (horÃ¡rio de BrasÃ­lia)\"\n    },\n    \"newDateTime\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"description\": \"Nova data e hora para o agendamento quando estiver atualizando (horÃ¡rio de BrasÃ­lia)\"\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"description\": \"TÃ­tulo do agendamento\",\n      \"default\": \"compromisso\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"DescriÃ§Ã£o do agendamento\",\n      \"default\": \"nenhuma\"\n    },\n    \"calendarId\": {\n      \"type\": \"string\",\n      \"description\": \"Identificador do calendÃ¡rio\",\n      \"default\": \"primary\"\n    }\n  },\n  \"required\": [\"operation\", \"dateTime\"],\n  \"dependencies\": {\n    \"operation\": {\n      \"oneOf\": [\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"update\"]\n            }\n          },\n          \"required\": [\"newDateTime\"]\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"create\", \"query\", \"query-slots\"]\n            }\n          }\n        }\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1580,
        1580
      ],
      "id": "7a796314-1f8a-4efc-8e3f-799cd66e7ae4",
      "name": "Scheduling"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 500,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        960,
        840
      ],
      "id": "cb3cf431-dbba-4669-9caa-a6f4d62b54d7",
      "name": "Sticky Note12"
    },
    {
      "parameters": {
        "content": "",
        "height": 340,
        "width": 540,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        940,
        820
      ],
      "typeVersion": 1,
      "id": "0b5dee9e-9557-43a3-a6ab-106176749969",
      "name": "Sticky Note16"
    },
    {
      "parameters": {
        "content": "Modulo de agendamento",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1000,
        800
      ],
      "id": "768376fe-f7a1-46b1-9cac-9830236e35e8",
      "name": "Sticky Note17"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "scheduling",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        1060,
        940
      ],
      "id": "d7234d25-ff53-4156-8ec0-cb2d151ba181",
      "name": "Scheduling Trigger",
      "webhookId": "e5ac896b-72e2-4095-a781-3ce17a36b792"
    },
    {
      "parameters": {
        "jsCode": "const CONFIG = {\n  timezone: 'America/Sao_Paulo',  // Fuso horÃ¡rio padrÃ£o\n  maxCommitmentsPerClient: -1,    // -1 para desativar, 1 para um agendamento por email\n  saveToDirectus: true,           // Habilitar salvamento no Directus\n  validateBeforeBooking: true,    // Habilitar validaÃ§Ã£o de horario antes do agendamento\n  startHour: 9,                   // ParÃ¢metros de inicio do horÃ¡rio comercial \n  endHour: 18,                    // ParÃ¢metros de fim do horÃ¡rio comercial \n  defaultDuration: 60             // DuraÃ§Ã£o padrÃ£o em minutos\n};\n\nconst inputData = $('Scheduling Trigger').first().json.body.params\nconst inputMapping = $('Scheduling Trigger').first().json.body.mapping;\nconst systemData = inputMapping.system;\nconst chatwootData = inputMapping.chatwoot;\nconst eventData = chatwootData.events\n      .filter(calendar => calendar.calendar_id == inputData.calendarId);\nconst { contact_id } = chatwootData;\nconst logs = [];\n\nconst credentials = {\n  accessToken: systemData.accessToken,\n  refreshToken: systemData.refreshToken,\n  clientId: systemData.clientId,\n  clientSecret: systemData.clientSecret,\n  directusToken: systemData.directus_token,\n  directusService: systemData.directus_service\n};\n\nconst dayjs = require('dayjs');\nconst utc = require('dayjs/plugin/utc');\nconst timezone = require('dayjs/plugin/timezone');\nconst isSameOrAfter = require('dayjs/plugin/isSameOrAfter');\nconst isSameOrBefore = require('dayjs/plugin/isSameOrBefore');\n\n// Configurar os plugins do dayjs logo no inÃ­cio\ndayjs.extend(utc);\ndayjs.extend(timezone);\ndayjs.extend(isSameOrAfter);\ndayjs.extend(isSameOrBefore);\n\n// Definir timezone padrÃ£o para todas as operaÃ§Ãµes\ndayjs.tz.setDefault(CONFIG.timezone);\n\n// =========================================================\n// FUNÃ‡Ã•ES AUXILIARES PARA MANIPULAÃ‡ÃƒO DE DATAS\n// =========================================================\n\n// Converte uma data para o formato UTC (para salvar no Directus)\nfunction formatToUTC(dateTime) {\n  // Garantir que estamos tratando a data no timezone local primeiro\n  const localDate = dayjs(dateTime).tz(CONFIG.timezone);\n  // Converter para UTC\n  return localDate.utc().format();\n}\n\n// Converte uma data de UTC para o fuso horÃ¡rio local (para exibiÃ§Ã£o)\nfunction formatFromUTC(dateTime, format = null) {\n  const localDate = dayjs(dateTime).tz(CONFIG.timezone);\n  return format ? localDate.format(format) : localDate;\n}\n\n// Extrai componentes de data e hora de uma string ISO\nfunction extractDateTimeComponents(dateTimeStr) {\n  // Garantir que estamos lidando com a data no fuso horÃ¡rio correto\n  const dateTime = dayjs(dateTimeStr).tz(CONFIG.timezone);\n  \n  return {\n    date: dateTime.format('YYYY-MM-DD'),\n    time: dateTime.format('HH:mm'),\n    dateTime: dateTime.format(), // ISO string completo\n    formattedDate: dateTime.format('DD/MM/YYYY'), // Formato brasileiro\n    formattedTime: dateTime.format('HH:mm')\n  };\n}\n\n// =========================================================\n// FUNÃ‡Ã•ES AUXILIARES\n// =========================================================\n\nfunction log(message, data = null) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    message\n  };\n  \n  if (data) {\n    if (typeof data === 'string' && data.length > 200) {\n      entry.data = data.substring(0, 200) + '... (truncado)';\n    } else if (typeof data === 'object') {\n      const stringified = JSON.stringify(data);\n      entry.data = stringified.length > 200 \n        ? JSON.stringify(data).substring(0, 200) + '... (truncado)' \n        : data;\n    } else {\n      entry.data = data;\n    }\n  }\n  \n  logs.push(entry);\n}\n\nfunction calculateDateTime() {\n  if (!inputData.dateTime) {\n    throw new Error(\"Para criar um evento, forneÃ§a uma data e hora.\");\n  }\n\n  // Garantir que as datas estÃ£o no fuso horÃ¡rio local\n  const startTime = formatFromUTC(inputData.dateTime);\n  const endTime = startTime.add(CONFIG.defaultDuration, 'minute');\n\n  return {\n    startTime,\n    endTime\n  };\n}\n\nfunction createClient(token) {\n  const axios = require('axios');\n  return {\n    get: (url, params = {}) => axios({\n      method: 'get',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` },\n      params\n    }),\n    post: (url, data) => axios({\n      method: 'post',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    put: (url, data) => axios({\n      method: 'put',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    delete: (url) => axios({\n      method: 'delete',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` }\n    })\n  };\n};\n\nasync function validateAvailability(token, calendarId, dateTime, duration) {\n  log('Validando disponibilidade para agendamento', { calendarId, dateTime, duration });\n  \n  try {\n    // Calcular horÃ¡rio de inÃ­cio e fim no fuso horÃ¡rio local\n    const startTime = formatFromUTC(dateTime);\n    const endTime = startTime.add(duration, 'minute');\n    \n    log('PerÃ­odo para validaÃ§Ã£o:', {\n      start: startTime.format('YYYY-MM-DD HH:mm'),\n      end: endTime.format('YYYY-MM-DD HH:mm')\n    });\n    \n    // Para o Google Calendar, precisamos enviar em UTC ISO\n    // O Google Calendar vai interpretar corretamente baseado no timezone especificado no evento\n    const timeMin = startTime.subtract(1, 'minute').toISOString();\n    const timeMax = endTime.add(1, 'minute').toISOString();\n    \n    const client = createClient(token);\n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n      {\n        timeMin,\n        timeMax,\n        singleEvents: true,\n        orderBy: 'startTime'\n      }\n    );\n    \n    // Filtrar apenas eventos que se sobrepÃµem ao perÃ­odo desejado\n    const conflictingEvents = (response.data.items || []).filter(event => {\n      // Pular eventos cancelados\n      if (event.status === 'cancelled') return false;\n      \n      // Converter horÃ¡rios do evento para o mesmo fuso horÃ¡rio local\n      const eventStart = event.start.dateTime \n        ? formatFromUTC(event.start.dateTime)\n        : formatFromUTC(event.start.date).startOf('day');\n        \n      const eventEnd = event.end.dateTime \n        ? formatFromUTC(event.end.dateTime)\n        : formatFromUTC(event.end.date).endOf('day');\n        \n      // Verificar sobreposiÃ§Ã£o\n      // Caso 1: Evento comeÃ§a durante o perÃ­odo desejado\n      const startsInPeriod = eventStart.isAfter(startTime) && eventStart.isBefore(endTime);\n      \n      // Caso 2: Evento termina durante o perÃ­odo desejado\n      const endsInPeriod = eventEnd.isAfter(startTime) && eventEnd.isBefore(endTime);\n      \n      // Caso 3: Evento engloba completamente o perÃ­odo desejado\n      const surroundsPeriod = eventStart.isSameOrBefore(startTime) && eventEnd.isSameOrAfter(endTime);\n      \n      // Caso 4: Exata correspondÃªncia de inÃ­cio ou fim\n      const exactMatchStart = eventStart.isSame(startTime);\n      const exactMatchEnd = eventEnd.isSame(endTime);\n      \n      return startsInPeriod || endsInPeriod || surroundsPeriod || exactMatchStart || exactMatchEnd;\n    });\n    \n    const isAvailable = conflictingEvents.length === 0;\n    \n    if (isAvailable) {\n      log('HorÃ¡rio disponÃ­vel para agendamento');\n    } else {\n      log('Conflito de agendamento detectado', \n        conflictingEvents.map(e => ({\n          title: e.summary, \n          start: e.start.dateTime || e.start.date,\n          end: e.end.dateTime || e.end.date\n        }))\n      );\n    }\n    \n    return {\n      available: isAvailable,\n      conflictingEvents: isAvailable ? [] : conflictingEvents.map(e => ({\n        title: e.summary || 'Sem tÃ­tulo',\n        start: e.start.dateTime || e.start.date,\n        end: e.end.dateTime || e.end.date,\n        id: e.id\n      }))\n    };\n  } catch (error) {\n    // Verificar se Ã© erro de token expirado - se for, deixe propagar para executeWithToken tratar\n    if (error.response && error.response.status === 401) {\n      log('Token expirado durante validaÃ§Ã£o de disponibilidade, propagando erro');\n      throw error; // Propagar o erro para executeWithToken tratar\n    }\n    \n    // Para outros erros, continuamos com o comportamento atual\n    log('Erro ao validar disponibilidade', error.message);\n    return {\n      available: false,\n      error: error.message,\n      errorType: 'validation_error'\n    };\n  }\n}\n\nasync function getCalendarName(token, calendarId) {\n  log(`Buscando informaÃ§Ãµes do calendÃ¡rio: ${calendarId}`);\n  \n  try {\n    const client = createClient(token);\n    let response;\n    \n    try {\n      response = await client.get(\n        `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}`\n      );\n      log('Resposta da API Google:', response.data);\n    } catch (error) {\n      // Se for erro de token expirado, tenta renovar e fazer nova requisiÃ§Ã£o\n      if (error.response && error.response.status === 401) {\n        log('Token expirado durante busca de calendÃ¡rio, renovando');\n        try {\n          const newToken = await refreshGoogleToken();\n          credentials.accessToken = newToken; // Atualizar o token localmente\n          const newClient = createClient(newToken);\n          \n          try {\n            response = await newClient.get(\n              `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}`\n            );\n            log('Resposta da API Google apÃ³s renovaÃ§Ã£o de token:', response.data);\n          } catch (secondError) {\n            // Se falhar novamente, usamos o ID como nome\n            log('Falha na segunda tentativa de buscar nome do calendÃ¡rio', secondError.message);\n            return calendarId;\n          }\n        } catch (renewError) {\n          log('Erro ao renovar token', renewError.message);\n          return calendarId; // Fallback para ID em caso de erro na renovaÃ§Ã£o\n        }\n      } else {\n        // Outros erros\n        log('Erro nÃ£o relacionado a token expirado:', error.message);\n        throw error;\n      }\n    }\n\n    // O nome do calendÃ¡rio estÃ¡ no campo \"summary\"\n    const calendarName = response.data.summary || 'CalendÃ¡rio sem nome';\n    log(`Nome do calendÃ¡rio obtido: ${calendarName}`);\n    return calendarName;\n  } catch (error) {\n    log('Erro ao buscar nome do calendÃ¡rio', error.message);\n    \n    // Para calendÃ¡rios especiais como \"primary\", podemos definir nomes amigÃ¡veis\n    if (calendarId === 'primary') {\n      return 'CalendÃ¡rio Principal';\n    }\n    \n    // Em caso de erro, retorna o prÃ³prio ID como nome\n    return calendarId;\n  }\n}\n\nasync function ensureSchedulingRelation(calendarId) {\n  if (!CONFIG.saveToDirectus) return { calendarId, calendarName: calendarId };\n  \n  log('Verificando/criando relaÃ§Ã£o na tabela scheduling para calendar_id', calendarId);\n  \n  try {\n    const client = createClient(credentials.directusToken);\n    \n    // Obter o nome do calendÃ¡rio (com tratamento de erros aprimorado)\n    const token = credentials.accessToken;\n    let calendarName;\n    \n    try {\n      calendarName = await getCalendarName(token, calendarId);\n    } catch (error) {\n      // Se falhar ao obter o nome, usa o ID como fallback\n      log('Falha ao obter nome do calendÃ¡rio, usando ID como fallback', error.message);\n      calendarName = calendarId;\n    }\n    \n    // Verificar se o calendÃ¡rio jÃ¡ existe na tabela scheduling\n    const searchResponse = await client.get(\n      `http://${credentials.directusService}:8055/items/event_history_user`\n    );\n\n    const calendars = searchResponse.data.data;\n    const calendarCurrent = calendars.find(calendar => calendar.calendar_id === calendarId && calendar.user_id === contact_id);\n    let newCalendarId = null;\n\n    // Se nÃ£o existir, criar o registro\n    if (!calendarCurrent) {\n      log('Criando novo registro na tabela scheduling', { calendarId, calendarName, contact_id });\n      \n      const response = await client.post(\n        `http://${credentials.directusService}:8055/items/event_history_user`,\n        {\n          name: calendarName,\n          calendar_id: calendarId,\n          user_id: contact_id\n        }\n      );\n\n      newCalendarId = response.data.data.id;\n      \n      log('RelaÃ§Ã£o na tabela scheduling criada com sucesso');\n    } else {\n      // Verificar se precisamos atualizar o nome do calendÃ¡rio\n      if (calendarCurrent.name !== calendarName && calendarName !== calendarId) {\n        // SÃ³ atualiza se tivermos um nome real (diferente do ID)\n        log('Atualizando nome do calendÃ¡rio na tabela scheduling', { \n          oldName: calendarCurrent.name, \n          newName: calendarName \n        });\n        const axios = require('axios');\n\n        await axios({\n          method: 'patch',\n          url: `http://${credentials.directusService}:8055/items/event_history_user/${calendarCurrent.id}`,\n          headers: {\n            'Authorization': `Bearer ${credentials.directusToken}`,\n            'Content-Type': 'application/json'\n          },\n          data: {\n            name: calendarName\n          }\n        });\n        \n        log('Nome do calendÃ¡rio atualizado com sucesso');\n      } else {\n        log('RelaÃ§Ã£o na tabela scheduling jÃ¡ existe');\n      }\n    }\n    \n    return {\n      id: newCalendarId || calendarCurrent.id,\n      calendarId,\n      calendarName\n    };\n  } catch (error) {\n    // Log detalhado para ajudar no debug\n    if (error.response) {\n      log('Detalhes do erro ao criar relaÃ§Ã£o scheduling', {\n        status: error.response.status,\n        data: error.response.data,\n        headers: error.response.headers\n      });\n    } else if (error.request) {\n      log('Erro na resposta do Directus', error.request);\n    }\n    \n    log('Erro ao verificar/criar relaÃ§Ã£o na tabela scheduling', error.message);\n    return {\n      calendarId,\n      calendarName: calendarId // Fallback para o ID em caso de erro\n    };\n  }\n}\n\nasync function saveToDirectus(eventData) {\n  if (!CONFIG.saveToDirectus) return true;\n  \n  log('Salvando agendamento no Directus', eventData);\n  \n  try {\n    \n    // Primeiro, verificar/criar a relaÃ§Ã£o na tabela scheduling\n    const calendarId = inputData.calendarId || 'primary';\n    const scheduling = await ensureSchedulingRelation(calendarId);\n\n    // Converter a data para UTC antes de salvar no Directus\n    const dateInUTC = formatToUTC(eventData.startTime);\n    log('Data convertida para UTC para salvar no Directus:', dateInUTC);\n    \n    // Preparar dados para envio\n    const directusData = {\n      title: eventData.title,\n      description: eventData.description || '',\n      date: dateInUTC,  // Aqui garantimos que estamos salvando em UTC\n      event_id: eventData.eventId,\n      session_id: scheduling.id, \n      calendar_id: calendarId\n    };\n    \n    log('Payload para Directus', directusData);\n    \n    // Realizar a requisiÃ§Ã£o\n    const client = createClient(credentials.directusToken);\n    await client.post(\n      `http://${credentials.directusService}:8055/items/event_history`,\n      directusData\n    );\n    \n    log('Agendamento salvo com sucesso no Directus');\n    return true;\n  } catch (error) {\n    if (error.response) {\n      log('Detalhes do erro do Directus', {\n        status: error.response.status,\n        data: error.response.data,\n        headers: error.response.headers\n      });\n    } else if (error.request) {\n      log('Erro na resposta do Directus', error.request);\n    }\n    log('Erro ao salvar agendamento no Directus', error.message);\n    return false;\n  }\n}\n\nasync function refreshGoogleToken() {\n  log('Renovando token do Google');\n\n  try {\n    const axios = require('axios');\n    const qs = require('querystring');\n\n    const response = await axios({\n      method: 'post',\n      url: 'https://oauth2.googleapis.com/token',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      data: qs.stringify({\n        client_id: credentials.clientId,\n        client_secret: credentials.clientSecret,\n        refresh_token: credentials.refreshToken,\n        grant_type: 'refresh_token'\n      })\n    });\n    \n    const newToken = response.data.access_token;\n    \n    // Atualizar token no Directus\n    await axios({\n      method: 'patch',\n      url: `http://${credentials.directusService}:8055/items/global_vars`,\n      headers: {\n        'Authorization': `Bearer ${credentials.directusToken}`,\n        'Content-Type': 'application/json'\n      },\n      data: { accessToken: newToken }\n    });\n    \n    log('Token renovado e atualizado com sucesso');\n    return newToken;\n  } catch (error) {\n    log('Erro ao renovar token', error.message);\n    throw error;\n  }\n}\n\nasync function executeWithToken(operation) {\n  try {\n    return await operation(credentials.accessToken);\n  } catch (error) {\n    // Se for erro de token expirado, renovar e tentar novamente\n    if (error.response && error.response.status === 401) {\n      log('Token expirado, renovando e tentando novamente');\n      try {\n        const newToken = await refreshGoogleToken();\n        credentials.accessToken = newToken; // Atualizar o token localmente tambÃ©m\n        const result = await operation(newToken);\n        return {\n          ...result,\n          message: result.message + \" (apÃ³s renovaÃ§Ã£o do token)\"\n        };\n      } catch (renewError) {\n        log('Erro ao renovar token durante executeWithToken', renewError.message);\n        throw { message: 'Falha ao renovar token: ' + renewError.message, errorType: 'token_refresh_failed' };\n      }\n    }\n    \n    // Outros erros\n    const errorMsg = error.message || 'Erro desconhecido';\n    let errorType = \"general_error\";\n    \n    if (errorMsg.includes(\"Limite mÃ¡ximo\")) errorType = \"appointment_limit_exceeded\";\n    if (errorMsg.includes(\"Acesso negado\") || errorMsg.includes(\"Email obrigatÃ³rio\")) errorType = \"access_denied\";\n    \n    throw { message: errorMsg, errorType };\n  }\n}\n\n// =========================================================\n// FUNÃ‡Ã•ES BASE\n// =========================================================\n\nasync function createEvent(token) {\n  const calendarId = inputData.calendarId ? inputData.calendarId : \"primary\";\n  let { title, description } = inputData;\n\n  if (!title) {\n    throw new Error(\"Para criar um evento, forneÃ§a um tÃ­tulo\");\n  }\n\n  const { startTime, endTime } = calculateDateTime();\n  \n  // Validar disponibilidade se a opÃ§Ã£o estiver ativada\n  if (CONFIG.validateBeforeBooking) {\n    log('Validando disponibilidade antes de agendar');\n    \n    // Usamos executeWithToken para garantir a renovaÃ§Ã£o de token se necessÃ¡rio\n    const validateWithToken = async (currentToken) => {\n      return await validateAvailability(\n        currentToken,\n        calendarId,\n        startTime.format(),\n        CONFIG.defaultDuration\n      );\n    };\n    \n    const validationResult = await executeWithToken(validateWithToken);\n    \n    if (!validationResult.available) {\n      // HorÃ¡rio nÃ£o disponÃ­vel, retornar erro com detalhes\n      const errorMsg = \"O horÃ¡rio solicitado jÃ¡ estÃ¡ ocupado.\";\n      log(errorMsg, validationResult.conflictingEvents);\n      \n      throw {\n        message: errorMsg,\n        errorType: \"scheduling_conflict\",\n        conflictingEvents: validationResult.conflictingEvents\n      };\n    }\n  }\n\n  // Verificar limite de agendamentos\n  if (CONFIG.maxCommitmentsPerClient != -1) {\n    if (eventData.length >= CONFIG.maxCommitmentsPerClient) {\n      throw new Error(`Limite mÃ¡ximo de ${CONFIG.maxCommitmentsPerClient} agendamento(s) excedido.`);\n    }\n  }\n\n  const event = {\n    summary: title,\n    description: description || '',\n    start: {\n      dateTime: startTime.toISOString(),\n      timeZone: CONFIG.timezone\n    },\n    end: {\n      dateTime: endTime.toISOString(),\n      timeZone: CONFIG.timezone\n    }\n  };\n\n  log('Criando evento', { title, calendarId });\n  \n  let client = createClient(token);\n  const response = await client.post(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n    event\n  );\n\n  // Formatar os horÃ¡rios no fuso horÃ¡rio local para exibiÃ§Ã£o\n  const formattedStartTime = startTime.format();\n  const formattedEndTime = endTime.format();\n\n  let savedToDirectus = false;\n  if(CONFIG.saveToDirectus){\n    // Dados para salvar no Directus\n    const eventData = {\n      title,\n      description: description || '',\n      startTime: formattedStartTime,\n      endTime: formattedEndTime,\n      eventId: response.data.id\n    };\n    savedToDirectus = await saveToDirectus(eventData);\n  }\n\n  return {\n    success: true,\n    message: \"Evento criado com sucesso\" + (savedToDirectus ? \" e registrado no event_history\" : \"\"),\n    eventId: response.data.id,\n    eventLink: response.data.htmlLink,\n    startTime: formattedStartTime,\n    endTime: formattedEndTime,\n    savedToDirectus\n  };\n}\n\nasync function updateEvent(token) {\n  log('Iniciando processo de atualizaÃ§Ã£o de evento');\n  \n  try {\n    // Verificar parÃ¢metros obrigatÃ³rios\n    const calendarId = inputData.calendarId || 'primary';\n    \n    if (!inputData.dateTime) {\n      throw new Error(\"Para atualizar um evento, forneÃ§a a data e hora original do agendamento.\");\n    }\n    \n    if (!inputData.newDateTime && !inputData.title && !inputData.description) {\n      throw new Error(\"Para atualizar um evento, forneÃ§a pelo menos um novo valor (data/hora, tÃ­tulo ou descriÃ§Ã£o).\");\n    }\n    \n    log('Tentando atualizar evento no calendÃ¡rio:', calendarId);\n    log('Data/hora original:', inputData.dateTime);\n    \n    if (inputData.newDateTime) {\n      log('Nova data/hora:', inputData.newDateTime);\n    }\n    \n    // Extrair data e hora original para buscar o evento - usando nossa funÃ§Ã£o auxiliar\n    const originalDateTime = formatFromUTC(inputData.dateTime);\n    const originalDateTimeComponents = extractDateTimeComponents(originalDateTime.format());\n    \n    log('Buscando evento com data:', originalDateTimeComponents.date, 'e hora:', originalDateTimeComponents.time);\n    \n    // Verificar se hÃ¡ eventos disponÃ­veis\n    if (!eventData || !Array.isArray(eventData) || eventData.length === 0) {\n      log('Nenhum evento encontrado para este calendÃ¡rio');\n      return {\n        message: \"Nenhum evento encontrado para atualizar neste calendÃ¡rio.\",\n        success: false\n      };\n    }\n    \n    // Filtrar eventos do calendÃ¡rio especificado\n    const calendarEvents = eventData.filter(event => event.calendar_id === calendarId);\n    \n    if (calendarEvents.length === 0) {\n      log('Nenhum evento encontrado para este calendÃ¡rio especÃ­fico');\n      return {\n        message: \"Nenhum evento encontrado para este calendÃ¡rio.\",\n        success: false\n      };\n    }\n    \n    // Buscar evento que corresponda Ã  data e hora original\n    const eventToUpdate = calendarEvents.find(event => {\n      // Converter data/hora do evento do Directus para local usando nossa funÃ§Ã£o auxiliar\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n      \n      // Verificar correspondÃªncia de data e hora\n      const dateMatches = eventDateTimeComponents.date === originalDateTimeComponents.date;\n      const timeMatches = eventDateTimeComponents.time === originalDateTimeComponents.time;\n      \n      log(`Comparando evento: ${event.title}, data: ${eventDateTimeComponents.date} (match: ${dateMatches}), hora: ${eventDateTimeComponents.time} (match: ${timeMatches})`);\n      \n      return dateMatches && timeMatches;\n    });\n    \n    if (!eventToUpdate) {\n      // Se nÃ£o encontrar o evento exato, retornar todos os eventos disponÃ­veis\n      const allEvents = calendarEvents.map(event => {\n        // Converter data/hora do evento do Directus para local\n        const eventDateTime = formatFromUTC(event.date);\n        const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n        \n        return {\n          id: event.id,\n          title: event.title,\n          description: event.description || '',\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          dateTime: eventDateTime.format(),\n          eventId: event.event_id\n        };\n      });\n      \n      // Ordenar por data/hora\n      allEvents.sort((a, b) => {\n        if (a.date !== b.date) return a.date.localeCompare(b.date);\n        return a.time.localeCompare(b.time);\n      });\n      \n      log('Evento nÃ£o encontrado, retornando lista de eventos disponÃ­veis');\n      \n      return {\n        message: `Nenhum evento encontrado na data e hora especificadas. VocÃª possui ${allEvents.length} eventos neste calendÃ¡rio.`,\n        success: false,\n        events: allEvents\n      };\n    }\n    \n    log('Evento encontrado para atualizaÃ§Ã£o:', {\n      id: eventToUpdate.id,\n      eventId: eventToUpdate.event_id,\n      title: eventToUpdate.title,\n      date: formatFromUTC(eventToUpdate.date).format('YYYY-MM-DD HH:mm')\n    });\n    \n    // Se vai atualizar a data/hora, validar disponibilidade\n    if (inputData.newDateTime && CONFIG.validateBeforeBooking) {\n      log('Validando disponibilidade para a nova data/hora');\n      \n      // Usar executeWithToken para garantir renovaÃ§Ã£o do token se necessÃ¡rio\n      const validateWithToken = async (currentToken) => {\n        return await validateAvailability(\n          currentToken,\n          calendarId,\n          inputData.newDateTime,\n          CONFIG.defaultDuration\n        );\n      };\n      \n      const validationResult = await executeWithToken(validateWithToken);\n      \n      // Verificar se o resultado encontrou conflitos alÃ©m do prÃ³prio evento\n      if (!validationResult.available) {\n        // Filtrar o prÃ³prio evento da lista de conflitos\n        const otherConflicts = validationResult.conflictingEvents.filter(\n          conflict => conflict.id !== eventToUpdate.event_id\n        );\n        \n        if (otherConflicts.length > 0) {\n          // HorÃ¡rio nÃ£o disponÃ­vel, retornar erro com detalhes\n          const errorMsg = \"O novo horÃ¡rio solicitado estÃ¡ ocupado por outro evento.\";\n          log(errorMsg, otherConflicts);\n          \n          throw {\n            message: errorMsg,\n            errorType: \"scheduling_conflict\",\n            conflictingEvents: otherConflicts\n          };\n        }\n      }\n    }\n    \n    // Preparar dados para a atualizaÃ§Ã£o no Google Calendar\n    const { startTime, endTime } = inputData.newDateTime \n      ? {\n          startTime: formatFromUTC(inputData.newDateTime),\n          endTime: formatFromUTC(inputData.newDateTime).add(CONFIG.defaultDuration, 'minute')\n        }\n      : {\n          startTime: formatFromUTC(inputData.dateTime),\n          endTime: formatFromUTC(inputData.dateTime).add(CONFIG.defaultDuration, 'minute')\n        };\n    \n    // Construir o objeto de atualizaÃ§Ã£o\n    const updatedEvent = {\n      summary: inputData.title || eventToUpdate.title,\n      description: inputData.description !== undefined ? inputData.description : eventToUpdate.description || '',\n      start: {\n        dateTime: startTime.toISOString(),\n        timeZone: CONFIG.timezone\n      },\n      end: {\n        dateTime: endTime.toISOString(),\n        timeZone: CONFIG.timezone\n      }\n    };\n    \n    log('Enviando atualizaÃ§Ã£o para o Google Calendar', updatedEvent);\n    \n    // Executar a atualizaÃ§Ã£o no Google Calendar\n    const updateGoogleCalendar = async (currentToken) => {\n      const client = createClient(currentToken);\n      return await client.put(\n        `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventToUpdate.event_id)}`,\n        updatedEvent\n      );\n    };\n    \n    // Usar executeWithToken para garantir renovaÃ§Ã£o do token se necessÃ¡rio\n    const response = await executeWithToken(updateGoogleCalendar);\n    \n    log('Evento atualizado no Google Calendar com sucesso');\n    \n    // Atualizar no Directus se necessÃ¡rio\n    if (CONFIG.saveToDirectus) {\n      try {\n        // Preparar dados para atualizaÃ§Ã£o no Directus\n        const directusData = {\n          title: inputData.title || eventToUpdate.title,\n          description: inputData.description !== undefined ? inputData.description : eventToUpdate.description || ''\n        };\n        \n        // Se a data foi alterada, atualizar tambÃ©m - sempre salvando em UTC\n        if (inputData.newDateTime) {\n          const dateInUTC = formatToUTC(startTime);\n          directusData.date = dateInUTC;\n          log('Nova data em UTC para o Directus:', dateInUTC);\n        }\n        \n        log('Atualizando evento no Directus', directusData);\n\n        // Atualizar no Directus - Usando PATCH em vez de PUT\n        const axios = require('axios');\n        \n        // Atualizar no Directus\n        await axios({\n          method: 'patch',\n          url: `http://${credentials.directusService}:8055/items/event_history/${eventToUpdate.id}`,\n          headers: {\n            'Authorization': `Bearer ${credentials.directusToken}`,\n            'Content-Type': 'application/json'\n          },\n          data: directusData\n        });\n        \n        log('Evento atualizado no Directus com sucesso');\n      } catch (directusError) {\n        log('Erro ao atualizar evento no Directus', directusError.message);\n        // Continuar mesmo com erro no Directus\n      }\n    }\n    \n    // Formatar resultado - retornando no fuso horÃ¡rio local\n    const formattedStartTime = startTime.format();\n    const formattedEndTime = endTime.format();\n    \n    return {\n      success: true,\n      message: \"Evento atualizado com sucesso\",\n      eventId: eventToUpdate.event_id,\n      eventLink: response.data.htmlLink,\n      startTime: formattedStartTime,\n      endTime: formattedEndTime,\n      title: updatedEvent.summary,\n      description: updatedEvent.description\n    };\n    \n  } catch (error) {\n    log('Erro ao atualizar evento', error.message);\n    \n    // Verificar se o erro Ã© especÃ­fico de conflito de agendamento\n    if (error.errorType === \"scheduling_conflict\") {\n      return {\n        success: false,\n        message: error.message,\n        errorType: error.errorType,\n        conflictingEvents: error.conflictingEvents\n      };\n    }\n    \n    throw { \n      message: `Erro ao atualizar evento: ${error.message}`, \n      errorType: \"update_failed\" \n    };\n  }\n}\n\nasync function deleteEvent(token) {\n  log('Iniciando processo de cancelamento de agendamento');\n  \n  try {\n    const calendarId = inputData.calendarId || 'primary';\n    log('Verificando eventos no calendÃ¡rio:', calendarId);\n    \n    // Verificar se temos a data e hora para cancelamento\n    if (!inputData.dateTime) {\n      throw new Error(\"Para cancelar um evento, forneÃ§a a data e hora do agendamento.\");\n    }\n    \n    // Converter a data/hora de entrada para o fuso horÃ¡rio local\n    const inputDateTime = formatFromUTC(inputData.dateTime);\n    const inputDateTimeComponents = extractDateTimeComponents(inputDateTime.format());\n    \n    log('Data alvo para cancelamento:', inputDateTimeComponents.date);\n    log('Hora alvo para cancelamento:', inputDateTimeComponents.time);\n    \n    // Verificar se hÃ¡ eventos disponÃ­veis\n    if (!eventData || !Array.isArray(eventData) || eventData.length === 0) {\n      log('Nenhum evento encontrado para este calendÃ¡rio');\n      return {\n        message: \"Nenhum agendamento encontrado para cancelar. NÃ£o hÃ¡ eventos marcados neste calendÃ¡rio.\",\n        success: false,\n        events: []\n      };\n    }\n    \n    // Filtrar apenas eventos do calendÃ¡rio especificado\n    const calendarEvents = eventData.filter(event => event.calendar_id === calendarId);\n    \n    if (calendarEvents.length === 0) {\n      log('Nenhum evento encontrado para este calendÃ¡rio especÃ­fico');\n      return {\n        message: \"Nenhum agendamento encontrado para este calendÃ¡rio.\",\n        success: false,\n        events: []\n      };\n    }\n    \n    log('Eventos disponÃ­veis no calendÃ¡rio:', calendarEvents.length);\n    \n    // Buscar eventos que correspondam Ã  data/hora especificada\n    const matchingEvents = calendarEvents.filter(event => {\n      // Converter data/hora do evento do Directus para o fuso horÃ¡rio local\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n      \n      // Verificar correspondÃªncia direta de data, hora e calendÃ¡rio\n      const dateMatches = eventDateTimeComponents.date === inputDateTimeComponents.date;\n      const timeMatches = eventDateTimeComponents.time === inputDateTimeComponents.time;\n      \n      log(`Analisando evento ${event.id}: data=${dateMatches} (${eventDateTimeComponents.date}), hora=${timeMatches} (${eventDateTimeComponents.time})`);\n      \n      return dateMatches && timeMatches;\n    });\n    \n    log('Eventos correspondentes encontrados:', matchingEvents.length);\n    \n    if (matchingEvents.length === 0) {\n      // Se nÃ£o encontrar eventos correspondentes, retornar todos os eventos disponÃ­veis\n      const allEvents = calendarEvents.map(event => {\n        // Converter data/hora do evento do Directus para o fuso horÃ¡rio local\n        const eventDateTime = formatFromUTC(event.date);\n        const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n        \n        return {\n          id: event.id,\n          title: event.title,\n          description: event.description || '',\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          dateTime: eventDateTime.format(),\n          eventId: event.event_id\n        };\n      });\n      \n      // Ordenar por data/hora\n      allEvents.sort((a, b) => {\n        if (a.date !== b.date) return a.date.localeCompare(b.date);\n        return a.time.localeCompare(b.time);\n      });\n      \n      log('Nenhum evento correspondente, retornando lista de eventos disponÃ­veis:', allEvents.length);\n      \n      return {\n        message: `Nenhum agendamento encontrado para a data/hora especificada. VocÃª possui ${allEvents.length} agendamentos neste calendÃ¡rio.`,\n        success: false,\n        events: allEvents\n      };\n    }\n    \n    // Processar o cancelamento de cada evento correspondente\n    const results = [];\n    for (const event of matchingEvents) {\n      // Converter data/hora do evento do Directus para o fuso horÃ¡rio local para logging\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n      \n      log('Cancelando evento:', { \n        id: event.id, \n        eventId: event.event_id, \n        title: event.title, \n        date: eventDateTimeComponents.date,\n        time: eventDateTimeComponents.time\n      });\n      \n      try {\n        // FunÃ§Ã£o para executar a exclusÃ£o com tratamento de token\n        const deleteFromGoogleCalendar = async (currentToken) => {\n          const client = createClient(currentToken);\n          return await client.delete(\n            `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(event.event_id)}`\n          );\n        };\n        \n        // Usar executeWithToken para garantir que o token seja renovado se necessÃ¡rio\n        await executeWithToken(deleteFromGoogleCalendar);\n        \n        log('Evento cancelado no Google Calendar com sucesso');\n        \n        // 2. Se o evento foi cancelado com sucesso no Google, remover do Directus\n        if (CONFIG.saveToDirectus) {\n          try {\n            const directusClient = createClient(credentials.directusToken);\n            await directusClient.delete(\n              `http://${credentials.directusService}:8055/items/event_history/${event.id}`\n            );\n            log('Evento removido do Directus com sucesso');\n          } catch (directusError) {\n            log('Erro ao remover evento do Directus', directusError.message);\n            // Continuar mesmo com erro no Directus\n          }\n        }\n        \n        // Adicionar ao resultado\n        results.push({\n          eventId: event.event_id,\n          title: event.title,\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          status: 'canceled'\n        });\n      } catch (error) {\n        log('Erro ao cancelar evento no Google Calendar', error.message);\n        \n        results.push({\n          eventId: event.event_id,\n          title: event.title,\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          status: 'error',\n          error: error.message\n        });\n      }\n    }\n    \n    // Determinar mensagem baseada nos resultados\n    const successCount = results.filter(r => r.status === 'canceled').length;\n    const errorCount = results.filter(r => r.status === 'error').length;\n    \n    let message;\n    if (successCount > 0 && errorCount === 0) {\n      message = `${successCount} agendamento(s) cancelado(s) com sucesso.`;\n    } else if (successCount > 0 && errorCount > 0) {\n      message = `${successCount} agendamento(s) cancelado(s) com sucesso. ${errorCount} apresentaram erro.`;\n    } else {\n      message = `Falha ao cancelar os agendamentos. Todos os ${errorCount} eventos apresentaram erro.`;\n    }\n    \n    return {\n      message,\n      success: successCount > 0,\n      canceledCount: successCount,\n      errorCount,\n      results\n    };\n    \n  } catch (error) {\n    log('Erro ao processar cancelamento de evento', error.message);\n    \n    // Se o erro for \"Nenhum evento encontrado\", tentar retornar a lista de eventos\n    if (error.message.includes(\"Nenhum evento encontrado\")) {\n      try {\n        const calendarId = inputData.calendarId || 'primary';\n        const calendarEvents = eventData.filter(event => event.session_id === calendarId);\n        \n        if (calendarEvents && calendarEvents.length > 0) {\n          const allEvents = calendarEvents.map(event => {\n            // Converter data/hora do evento do Directus para o fuso horÃ¡rio local\n            const eventDateTime = formatFromUTC(event.date);\n            const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n            \n            return {\n              id: event.id,\n              title: event.title,\n              description: event.description || '',\n              date: eventDateTimeComponents.date,\n              time: eventDateTimeComponents.time,\n              eventId: event.event_id\n            };\n          }).sort((a, b) => {\n            if (a.date !== b.date) return a.date.localeCompare(b.date);\n            return a.time.localeCompare(b.time);\n          });\n          \n          return {\n            message: `Nenhum agendamento encontrado na data e hora especificadas. VocÃª possui ${allEvents.length} agendamentos neste calendÃ¡rio.`,\n            success: false,\n            events: allEvents\n          };\n        }\n      } catch (secondError) {\n        log('Erro ao tentar recuperar lista de eventos', secondError.message);\n      }\n    }\n    \n    throw { message: error.message, errorType: \"general_error\" };\n  }\n}\n\nasync function queryEvents(token) {\n  log('Consultando eventos do calendÃ¡rio');\n  \n  try {\n    const calendarId = inputData.calendarId || 'primary';\n    log('ID do calendÃ¡rio para consulta:', calendarId);\n\n    // Verificar se hÃ¡ eventos disponÃ­veis\n    if (!eventData || !Array.isArray(eventData) || eventData.length === 0) {\n      log('Nenhum evento encontrado para este calendÃ¡rio');\n      return {\n        message: \"Nenhum evento encontrado para este calendÃ¡rio\",\n        eventsToday: [],\n        upcomingEvents: []\n      };\n    }\n    \n    // Obter a data atual no fuso horÃ¡rio local\n    const today = dayjs().tz(CONFIG.timezone).startOf('day');\n    log('Data de referÃªncia para consulta:', today.format('YYYY-MM-DD'));\n    \n    // Separar eventos de hoje e prÃ³ximos eventos\n    const eventsToday = [];\n    const upcomingEvents = [];\n    \n    eventData.forEach(event => {\n      // Converter a data do evento de UTC para o fuso horÃ¡rio local\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDate = eventDateTime.startOf('day');\n      \n      // Extrair componentes para criar objeto de resultado\n      const components = extractDateTimeComponents(eventDateTime.format());\n      \n      // Criar objeto base para o evento\n      const eventObject = {\n        id: event.id,\n        title: event.title,\n        description: event.description || '',\n        date: components.date,\n        time: components.time,\n        formattedDate: components.formattedDate,\n        dateTime: eventDateTime.format(),\n        eventId: event.event_id\n      };\n      \n      // Verificar se o evento Ã© de hoje\n      if (eventDate.isSame(today, 'day')) {\n        eventsToday.push(eventObject);\n      } \n      // Verificar se o evento Ã© futuro (apÃ³s hoje)\n      else if (eventDate.isAfter(today, 'day')) {\n        upcomingEvents.push(eventObject);\n      }\n    });\n    \n    // Ordenar eventos por data/hora\n    eventsToday.sort((a, b) => dayjs(a.dateTime).diff(dayjs(b.dateTime)));\n    upcomingEvents.sort((a, b) => dayjs(a.dateTime).diff(dayjs(b.dateTime)));\n    \n    log('Eventos encontrados para hoje:', eventsToday.length);\n    log('Eventos futuros encontrados:', upcomingEvents.length);\n    \n    return {\n      message: `Encontrados ${eventsToday.length} eventos para hoje e ${upcomingEvents.length} eventos futuros`,\n      eventsToday,\n      upcomingEvents\n    };\n  } catch (error) {\n    log('Erro ao consultar eventos', error.message);\n    throw new Error(`Erro ao consultar eventos: ${error.message}`);\n  }\n}\n\nasync function queryAvailableSlots(token) {\n  log('Iniciando busca por slots disponÃ­veis');\n  \n  try {\n    // Definir timezone padrÃ£o para todas as operaÃ§Ãµes\n    dayjs.tz.setDefault(CONFIG.timezone);\n    \n    const calendarId = inputData.calendarId || 'primary';\n    log('CalendÃ¡rio selecionado:', calendarId);\n    \n    // Determinar a data alvo - sempre convertendo para o timezone local\n    let targetDate;\n    \n    if (inputData.dateTime) {\n      // Se tiver dateTime (como usado em createEvent), extrair a data\n      targetDate = formatFromUTC(inputData.dateTime).startOf('day');\n      log('Usando data de dateTime:', targetDate.format('YYYY-MM-DD'));\n    } else if (inputData.date) {\n      // Se tiver date especÃ­fico\n      targetDate = formatFromUTC(inputData.date).startOf('day');\n      log('Usando data fornecida:', targetDate.format('YYYY-MM-DD'));\n    } else {\n      // Default para a data atual em fuso horÃ¡rio local\n      targetDate = dayjs().tz(CONFIG.timezone).startOf('day');\n      log('Nenhuma data fornecida, usando data atual:', targetDate.format('YYYY-MM-DD'));\n    }\n    \n    const targetDateStr = targetDate.format('YYYY-MM-DD');\n    \n    // ParÃ¢metros de horÃ¡rio comercial (padrÃµes caso nÃ£o sejam fornecidos)\n    const startHour = CONFIG.startHour;  \n    const endHour = CONFIG.endHour;\n    const slotDuration = inputData.slotDuration || CONFIG.defaultDuration; // DuraÃ§Ã£o em minutos (padrÃ£o: 60 min)\n    \n    log('HorÃ¡rio comercial configurado:', `${startHour}:00 - ${endHour}:00, slots de ${slotDuration} minutos`);\n    log('Data alvo para consulta:', targetDateStr);\n    \n    // FunÃ§Ã£o para buscar eventos no Google Calendar para a data selecionada\n    const fetchGoogleCalendarEvents = async (authToken) => {\n      const client = createClient(authToken);\n      \n      // Definir inÃ­cio e fim do dia na timezone configurada (BrasÃ­lia)\n      const startOfDay = targetDate;\n      const endOfDay = targetDate.add(1, 'day');\n      \n      // Converter para ISO para a API do Google\n      const timeMin = startOfDay.toISOString();\n      const timeMax = endOfDay.toISOString();\n      \n      log('Buscando eventos no perÃ­odo (ISO):', { timeMin, timeMax });\n      \n      const response = await client.get(\n        `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n        {\n          timeMin,\n          timeMax,\n          singleEvents: true,\n          orderBy: 'startTime'\n        }\n      );\n      \n      return response.data.items || [];\n    };\n    \n    // Buscar eventos no Google Calendar\n    const googleEvents = await executeWithToken(fetchGoogleCalendarEvents);\n    log('Eventos encontrados no Google Calendar:', googleEvents.length);\n    \n    // Combinar com os eventos do Directus (se disponÃ­veis)\n    let allEvents = [];\n    \n    // Adicionar eventos do Google Calendar, convertendo para timezone local\n    if(googleEvents.length)\n      googleEvents.forEach(event => {\n        if (event.status !== 'cancelled') {\n          // Converter datas para o fuso horÃ¡rio local\n          const startTime = event.start.dateTime \n            ? formatFromUTC(event.start.dateTime)\n            : formatFromUTC(event.start.date).startOf('day');\n            \n          const endTime = event.end.dateTime \n            ? formatFromUTC(event.end.dateTime)\n            : formatFromUTC(event.end.date).endOf('day');\n          \n          log(`Evento do Google: ${event.summary}, InÃ­cio: ${startTime.format('YYYY-MM-DD HH:mm')}, Fim: ${endTime.format('YYYY-MM-DD HH:mm')}`);\n          \n          allEvents.push({\n            id: event.id,\n            title: event.summary || 'Sem tÃ­tulo',\n            start: startTime,\n            end: endTime,\n            source: 'google'\n          });\n        }\n      });\n    \n    // Adicionar eventos do Directus (se existirem), convertendo de UTC para o fuso horÃ¡rio local\n    if (eventData && Array.isArray(eventData)) {\n      const directusEvents = eventData.filter(event => {\n        // Converter para o fuso horÃ¡rio local para comparaÃ§Ã£o\n        const eventDateTime = formatFromUTC(event.date);\n        return eventDateTime.format('YYYY-MM-DD') === targetDateStr && \n               event.session_id === calendarId;\n      });\n      \n      directusEvents.forEach(event => {\n        // Converter de UTC para o fuso horÃ¡rio local\n        const eventStart = formatFromUTC(event.date);\n        const eventEnd = eventStart.add(slotDuration, 'minutes');\n        \n        log(`Evento do Directus: ${event.title}, InÃ­cio: ${eventStart.format('YYYY-MM-DD HH:mm')}, Fim: ${eventEnd.format('YYYY-MM-DD HH:mm')}`);\n        \n        // Verificar se jÃ¡ existe um evento do Google com o mesmo ID\n        const exists = allEvents.some(e => e.id === event.event_id && e.source === 'google');\n        \n        if (!exists) {\n          allEvents.push({\n            id: event.id,\n            title: event.title || 'Sem tÃ­tulo',\n            start: eventStart,\n            end: eventEnd,\n            source: 'directus'\n          });\n        }\n      });\n    }\n    \n    log('Total de eventos apÃ³s combinaÃ§Ã£o:', allEvents.length);\n    \n    // Gerar todos os slots possÃ­veis para o horÃ¡rio comercial\n    const availableSlots = [];\n    const busySlots = [];\n    \n    // Criar horÃ¡rio comercial no fuso horÃ¡rio local\n    const businessStart = targetDate.hour(startHour).minute(0).second(0);\n    const businessEnd = targetDate.hour(endHour).minute(0).second(0);\n    \n    log(`HorÃ¡rio comercial: ${businessStart.format('YYYY-MM-DD HH:mm')} atÃ© ${businessEnd.format('YYYY-MM-DD HH:mm')}`);\n    \n    // Formatar data para exibiÃ§Ã£o no padrÃ£o brasileiro\n    const formattedDate = targetDate.format('DD/MM/YYYY');\n    \n    // Iterar sobre os slots do horÃ¡rio comercial\n    let currentSlotStart = businessStart;\n    \n    while (currentSlotStart.isBefore(businessEnd)) {\n      const currentSlotEnd = currentSlotStart.add(slotDuration, 'minutes');\n      \n      log(`Analisando slot: ${currentSlotStart.format('HH:mm')} - ${currentSlotEnd.format('HH:mm')}`);\n      \n      // Verificar se este slot estÃ¡ ocupado por algum evento\n      const isSlotBusy = allEvents.some(event => {\n        // Verificar sobreposiÃ§Ã£o com o horÃ¡rio no fuso horÃ¡rio local\n        const eventStart = event.start;\n        const eventEnd = event.end;\n        \n        // Log de debug para verificar comparaÃ§Ã£o de horÃ¡rios\n        log(`  Comparando com evento: ${event.title}`);\n        log(`    Evento: ${eventStart.format('HH:mm')} - ${eventEnd.format('HH:mm')}`);\n        \n        // Verificar sobreposiÃ§Ã£o utilizando mÃ©todos bÃ¡sicos do dayjs\n        const startsInSlot = eventStart.isAfter(currentSlotStart) && eventStart.isBefore(currentSlotEnd);\n        const endsInSlot = eventEnd.isAfter(currentSlotStart) && eventEnd.isBefore(currentSlotEnd);\n        const coversSlot = eventStart.isSameOrBefore(currentSlotStart) && eventEnd.isSameOrAfter(currentSlotEnd);\n        const exactMatchStart = eventStart.isSame(currentSlotStart);\n        const exactMatchEnd = eventEnd.isSame(currentSlotEnd);\n        \n        // VerificaÃ§Ã£o combinada\n        const overlaps = startsInSlot || endsInSlot || coversSlot || exactMatchStart || exactMatchEnd;\n        \n        if (overlaps) {\n          log(`    SOBREPOSIÃ‡ÃƒO ENCONTRADA`);\n        }\n        \n        return overlaps;\n      });\n      \n      const slotInfo = {\n        start: currentSlotStart.format('HH:mm'),\n        end: currentSlotEnd.format('HH:mm'),\n        startISO: currentSlotStart.format(),\n        endISO: currentSlotEnd.format(),\n        formattedDateTime: `${formattedDate} ${currentSlotStart.format('HH:mm')}` // Formato brasileiro\n      };\n      \n      if (isSlotBusy) {\n        busySlots.push(slotInfo);\n        log(`Slot ocupado: ${slotInfo.start} - ${slotInfo.end}`);\n      } else {\n        availableSlots.push(slotInfo);\n        log(`Slot disponÃ­vel: ${slotInfo.start} - ${slotInfo.end}`);\n      }\n      \n      // AvanÃ§ar para o prÃ³ximo slot\n      currentSlotStart = dayjs(currentSlotEnd);  // Criar nova instÃ¢ncia para evitar problemas de referÃªncia\n    }\n    \n    log('Slots disponÃ­veis encontrados:', availableSlots.length);\n    log('Slots ocupados encontrados:', busySlots.length);\n    \n    // InformaÃ§Ãµes do dia para o resultado\n    const dayInfo = {\n      date: targetDateStr,\n      formattedDate: formattedDate, // Formato brasileiro DD/MM/YYYY\n      dayOfWeek: targetDate.format('dddd'),\n      isToday: targetDate.isSame(dayjs().tz(CONFIG.timezone), 'day'),\n      businessHours: `${startHour}:00 - ${endHour}:00`\n    };\n    \n    return {\n      success: true,\n      message: `Encontrados ${availableSlots.length} horÃ¡rios disponÃ­veis para ${formattedDate}`,\n      day: dayInfo,\n      availableSlots,\n      busySlots,\n      slotDuration\n    };\n    \n  } catch (error) {\n    log('Erro ao consultar slots disponÃ­veis', error.message);\n    if (error.response) {\n      log('Detalhes do erro da API', {\n        status: error.response.status,\n        data: error.response.data\n      });\n    } else if (error.stack) {\n      log('Stack trace do erro', error.stack);\n    }\n    \n    throw { \n      message: `Erro ao consultar horÃ¡rios disponÃ­veis: ${error.message}`, \n      errorType: \"general_error\" \n    };\n  }\n}\n\n// =========================================================\n// FUNÃ‡Ã€O PRINCIPAL\n// =========================================================\n\nasync function main() {\n  try {\n    const operations = {\n      'create': createEvent,\n      'update': updateEvent,\n      'delete': deleteEvent,\n      'query': queryEvents,\n      'query-slots': queryAvailableSlots\n    };\n    \n    if (!inputData.operation || !operations[inputData.operation]) {\n      throw new Error(\"OperaÃ§Ã£o invÃ¡lida. Use 'create', 'update', 'delete', 'query' ou 'query_slots'\");\n    }\n    \n    const operation = inputData.operation;\n    const result = await executeWithToken(operations[operation]);\n    \n    return {\n      success: true,\n      ...result,\n      logs\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error.message || \"Erro desconhecido\",\n      errorType: error.errorType || \"general_error\",\n      logs\n    };\n  }\n}\n\n// Iniciar execuÃ§Ã£o\nreturn [{\n  json: await main()\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        940
      ],
      "id": "dd167075-48c7-406b-82bd-7c213443c3b4",
      "name": "Calendar Manager"
    },
    {
      "parameters": {
        "name": "clickup",
        "description": "Ferramenta para gerenciar tarefas no ClickUp. Permite criar, listar, atualizar ou remover tarefas. Para criar, forneÃ§a pelo menos o tÃ­tulo. Para atualizar ou remover, vocÃª precisa fornecer o ID da tarefa. Para listar, vocÃª pode aplicar filtros opcionais.",
        "jsCode": "const workspaceId = '9011917991';\nconst listId = '901109860036';\nconst apiKey = 'pk_44163283_ZIFREHZQNJWKZ5YSD0XVV45B272AOARG';\nconst https = require('https');\n\nconst logs = [];\n\nfunction log(message) {\n  logs.push({ time: new Date().toISOString(), message });\n}\n\nfunction request(path, method, body = null) {\n  log(`RequisiÃ§Ã£o: ${method} ${path}`);\n  \n  return new Promise((resolve, reject) => {\n    const options = {\n      hostname: 'api.clickup.com',\n      path,\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': apiKey\n      }\n    };\n    \n    const req = https.request(options, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        try {\n          log(`Resposta: status ${res.statusCode}`);\n          \n          // Tratamento de respostas vazias (comum em DELETEs)\n          if (!data || data.trim() === '') {\n            return res.statusCode < 300 \n              ? resolve({ success: true }) \n              : reject({ \n                  success: false, \n                  message: `Erro: ${res.statusMessage}`, \n                  statusCode: res.statusCode \n                });\n          }\n          \n          const responseData = JSON.parse(data);\n          \n          if (res.statusCode < 300) {\n            resolve(responseData);\n          } else {\n            reject({\n              success: false,\n              message: `Erro: ${responseData.err || res.statusMessage}`,\n              statusCode: res.statusCode\n            });\n          }\n        } catch (error) {\n          log(`Erro ao processar resposta: ${error.message}`);\n          reject({\n            success: false,\n            message: `Erro ao processar resposta: ${error.message}`,\n            data\n          });\n        }\n      });\n    });\n\n    req.on('error', (error) => {\n      log(`Erro na requisiÃ§Ã£o: ${error.message}`);\n      reject({ success: false, message: `Erro na requisiÃ§Ã£o: ${error.message}` });\n    });\n\n    if (body) {\n      const data = typeof body === 'string' ? body : JSON.stringify(body);\n      log(`Enviando dados: ${data.substring(0, 100)}${data.length > 100 ? '...' : ''}`);\n      req.write(data);\n    }\n    \n    req.end();\n  });\n}\n\nconst operations = {\n  async list(query) {\n    log('OperaÃ§Ã£o: listar tarefas');\n    \n    try {\n      // Construir parÃ¢metros de consulta\n      const params = [];\n      \n      if (query.status) params.push(`statuses[]=${encodeURIComponent(query.status)}`);\n      if (query.assignee) params.push(`assignees[]=${encodeURIComponent(query.assignee)}`);\n      if (query.due_date_gt) params.push(`due_date_gt=${encodeURIComponent(query.due_date_gt)}`);\n      if (query.due_date_lt) params.push(`due_date_lt=${encodeURIComponent(query.due_date_lt)}`);\n      \n      // PaginaÃ§Ã£o\n      params.push(`page=${query.page || 0}`);\n      const limit = Math.min(query.limit || 20, 100);\n      params.push(`limit=${limit}`);\n      \n      log(`ParÃ¢metros: ${params.join('&')}`);\n      \n      // Fazer requisiÃ§Ã£o\n      const data = await request(\n        `/api/v2/list/${listId}/task?${params.join('&')}`, \n        'GET'\n      );\n      \n      log(`Tarefas encontradas: ${data.tasks.length}`);\n      \n      return {\n        success: true,\n        tasks: data.tasks,\n        total_count: data.tasks.length,\n        has_more: data.tasks.length === limit\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n\n  async create(query) {\n    log('OperaÃ§Ã£o: criar tarefa');\n    \n    if (!query.title) {\n      log('Erro: TÃ­tulo da tarefa nÃ£o fornecido');\n      return { success: false, message: \"TÃ­tulo da tarefa Ã© obrigatÃ³rio para criaÃ§Ã£o\" };\n    }\n    \n    const body = {\n      name: query.title,\n      description: query.description || '',\n      due_date: query.due_date || null,\n      priority: query.priority || 3,\n      assignees: query.assignees || []\n    };\n    \n    try {\n      log(`Criando tarefa: \"${query.title}\"`);\n      const data = await request(`/api/v2/list/${listId}/task`, 'POST', body);\n      log(`Tarefa criada com sucesso, ID: ${data.id}`);\n      \n      return {\n        success: true,\n        message: \"Tarefa criada com sucesso\",\n        taskId: data.id,\n        taskUrl: data.url\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n  \n  async delete(query) {\n    log('OperaÃ§Ã£o: remover tarefa');\n    \n    if (!query.task_id) {\n      log('Erro: ID da tarefa nÃ£o fornecido');\n      return { success: false, message: \"ID da tarefa Ã© obrigatÃ³rio para remoÃ§Ã£o\" };\n    }\n    \n    try {\n      log(`Removendo tarefa: ${query.task_id}`);\n      await request(`/api/v2/task/${query.task_id}`, 'DELETE');\n      log('Tarefa removida com sucesso');\n      \n      return {\n        success: true,\n        message: \"Tarefa removida com sucesso\",\n        taskId: query.task_id\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n  \n  async update(query) {\n    log('OperaÃ§Ã£o: atualizar tarefa');\n    \n    if (!query.task_id) {\n      log('Erro: ID da tarefa nÃ£o fornecido');\n      return { success: false, message: \"ID da tarefa Ã© obrigatÃ³rio para atualizaÃ§Ã£o\" };\n    }\n    \n    // Mapear campos\n    const fields = {\n      title: 'name',\n      description: 'description',\n      due_date: 'due_date',\n      priority: 'priority',\n      status: 'status',\n      assignees: 'assignees'\n    };\n    \n    const body = {};\n    \n    // Filtrar campos fornecidos\n    Object.entries(fields).forEach(([src, dest]) => {\n      if (query[src] !== undefined) body[dest] = query[src];\n    });\n    \n    if (Object.keys(body).length === 0) {\n      log('Erro: Nenhum campo fornecido para atualizaÃ§Ã£o');\n      return { success: false, message: \"Nenhum campo fornecido para atualizaÃ§Ã£o\" };\n    }\n    \n    try {\n      log(`Atualizando tarefa: ${query.task_id}`);\n      await request(`/api/v2/task/${query.task_id}`, 'PUT', body);\n      log('Tarefa atualizada com sucesso');\n      \n      return {\n        success: true,\n        message: \"Tarefa atualizada com sucesso\",\n        taskId: query.task_id\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  }\n};\n\ntry {\n  log(`Iniciando processamento: ${JSON.stringify(query)}`);\n  \n  const operation = query.operation || 'create';\n  \n  const result = await operations[operation](query);\n  \n  return JSON.stringify({\n    success: true,\n    ...result,\n    logs: logs\n  });\n} catch (error) {\n  log(`Erro nÃ£o tratado: ${error.message || JSON.stringify(error)}`);\n  return JSON.stringify({ \n    success: false, \n    message: `Erro nÃ£o tratado: ${error.message || 'Erro desconhecido'}`,\n    logs \n  });\n}",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"operation\": {\n      \"type\": \"string\",\n      \"description\": \"OperaÃ§Ã£o a ser realizada: criar, listar, atualizar ou remover tarefas\",\n      \"enum\": [\"create\", \"list\", \"update\", \"delete\"],\n      \"default\": \"create\"\n    },\n    \"task_id\": {\n      \"type\": \"string\",\n      \"description\": \"ID da tarefa (obrigatÃ³rio para atualizar ou remover)\"\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"description\": \"TÃ­tulo da tarefa (obrigatÃ³rio para criar, opcional para atualizar)\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"DescriÃ§Ã£o detalhada da tarefa (opcional)\"\n    },\n    \"due_date\": {\n      \"type\": \"string\",\n      \"description\": \"Data de vencimento no formato timestamp ou ISO 8601 (opcional)\"\n    },\n    \"priority\": {\n      \"type\": \"integer\",\n      \"description\": \"Prioridade da tarefa (1: Urgente, 2: Alta, 3: Normal, 4: Baixa) (opcional)\",\n      \"enum\": [1, 2, 3, 4]\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"description\": \"Status da tarefa (para atualizar ou filtrar na listagem)\"\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"integer\"\n      },\n      \"description\": \"Lista de IDs dos usuÃ¡rios atribuÃ­dos Ã  tarefa (opcional)\"\n    },\n    \"assignee\": {\n      \"type\": \"integer\",\n      \"description\": \"Filtrar por ID do usuÃ¡rio atribuÃ­do (para listar)\"\n    },\n    \"due_date_gt\": {\n      \"type\": \"string\",\n      \"description\": \"Filtrar tarefas com data de vencimento posterior (para listar)\"\n    },\n    \"due_date_lt\": {\n      \"type\": \"string\",\n      \"description\": \"Filtrar tarefas com data de vencimento anterior (para listar)\"\n    },\n    \"page\": {\n      \"type\": \"integer\",\n      \"description\": \"NÃºmero da pÃ¡gina para paginaÃ§Ã£o (para listar)\",\n      \"default\": 0\n    },\n    \"limit\": {\n      \"type\": \"integer\",\n      \"description\": \"NÃºmero de tarefas por pÃ¡gina (mÃ¡ximo 100, para listar)\",\n      \"default\": 20\n    }\n  },\n  \"required\": [\"operation\"],\n  \"dependencies\": {\n    \"operation\": {\n      \"oneOf\": [\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"create\"]\n            }\n          },\n          \"required\": [\"title\"]\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"list\"]\n            }\n          }\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"update\"]\n            }\n          },\n          \"required\": [\"task_id\"]\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"delete\"]\n            }\n          },\n          \"required\": [\"task_id\"]\n        }\n      ]\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1700,
        1580
      ],
      "id": "6a06dfcc-eb35-41cb-b35b-313783de7027",
      "name": "Clickup"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -940,
        2460
      ],
      "id": "828e3074-8af6-4072-8085-b0e91dc613f6",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "3raLgi1Pp00Yk6mH",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1000,
        1580
      ],
      "id": "fbae12cb-887e-4604-ad27-2fb16a50746e",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "3raLgi1Pp00Yk6mH",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "description": "Ferramenta para transferir conversas para atendimento humano especializado. Use quando: cliente pedir para falar com gerente/supervisor, demonstrar insatisfaÃ§Ã£o grave ou reclamaÃ§Ã£o, relatar problemas com compras anteriores, solicitar reembolso/estorno, ou quando a questÃ£o fugir do escopo do Beauty Show. Envia mensagem ao cliente, cria nota interna para o agente e altera status da conversa.",
        "jsCode": "const axios = require('axios');\n\ntry {\n  // Obter dados do mapping\n  const mapping = JSON.parse($('Core Input').item.json.body.mapping);\n  const { chatwoot, system } = mapping;\n\n  // ðŸ”§ CORREÃ‡ÃƒO: Usar a variÃ¡vel global 'query' como no exemplo do ClickUp\n  // O n8n jÃ¡ parseia os parÃ¢metros da tool function e disponibiliza em 'query'\n  const reason = query.reason && query.reason.trim()\n    ? query.reason\n    : 'Cliente solicitou atendimento humano';\n\n  const summary = query.summary && query.summary.trim()\n    ? query.summary\n    : `Transbordo solicitado por ${chatwoot?.user_name || 'cliente'} â€” sem resumo detalhado`;\n\n  \n  // ðŸ” DEBUG: Log dos parÃ¢metros recebidos\n  console.log(`[TRANSFER] === PARÃ‚METROS RECEBIDOS ===`);\n  console.log(`[TRANSFER] Reason recebido: \"${query.reason}\"`);\n  console.log(`[TRANSFER] Summary recebido: \"${query.summary}\"`);\n  console.log(`[TRANSFER] Reason final: \"${reason}\"`);\n  console.log(`[TRANSFER] Summary final: \"${summary}\"`);\n  console.log(`[TRANSFER] === FIM DOS PARÃ‚METROS ===`);\n  \n  // Log de execuÃ§Ã£o para debug\n  console.log(`[TRANSFER] Iniciando transbordo - ${new Date().toISOString()}`);\n  console.log(`[TRANSFER] Reason: ${reason}`);\n  console.log(`[TRANSFER] Summary: ${summary}`);\n  console.log(`[TRANSFER] Conversation: ${chatwoot.conversation_id}`);\n  console.log(`[TRANSFER] Customer: ${chatwoot.user_name}`);\n  \n  // ðŸ”’ PROTEÃ‡ÃƒO MELHORADA CONTRA DUPLICAÃ‡ÃƒO\n  const conversationId = chatwoot.conversation_id;\n  const currentTime = Date.now();\n  const executionId = `${currentTime}_${Math.random().toString(36).substr(2, 9)}`;\n  console.log(`[TRANSFER] Execution ID: ${executionId}`);\n  \n  // URLs do Chatwoot\n  const chatwootUrl = `https://chat.spsystems.pro/api/v1/accounts/${chatwoot.account_id}/conversations/${chatwoot.conversation_id}`;\n  const statusUrl = `${chatwootUrl}/toggle_status`;\n  const messagesUrl = `${chatwootUrl}/messages`;\n  \n  const chatwootHeaders = {\n    'api_access_token': chatwoot.bot_token,\n    'Content-Type': 'application/json'\n  };\n  \n  // 1. VERIFICAR STATUS ATUAL VIA API (nÃ£o do input inicial)\n  console.log(`[TRANSFER] Verificando status atual da conversa via API...`);\n  \n  try {\n    const statusCheck = await axios.get(`${chatwootUrl}`, { \n      headers: chatwootHeaders \n    });\n    \n    const currentStatus = statusCheck.data.status;\n    console.log(`[TRANSFER] Status atual da conversa: ${currentStatus}`);\n    \n    if (currentStatus === 'open') {\n      console.log(`[TRANSFER] Conversa jÃ¡ estÃ¡ em status \"open\" - evitando duplicaÃ§Ã£o`);\n      return JSON.stringify({\n        success: true,\n        message: \"Esta conversa jÃ¡ foi transferida para um atendente! Em breve vocÃª serÃ¡ atendido. ðŸ˜Š\"\n      });\n    }\n    \n  } catch (statusError) {\n    console.log(`[TRANSFER] Erro ao verificar status (continuando): ${statusError.message}`);\n    // Continua a execuÃ§Ã£o mesmo se nÃ£o conseguir verificar o status\n  }\n  \n  // 2. VERIFICAR SE HÃ EXECUÃ‡Ã•ES RECENTES (proteÃ§Ã£o extra)\n  // Criar um identificador Ãºnico baseado na conversa e timestamp\n  const transferWindow = 30000; // 30 segundos\n  const lastTransferTime = global[`last_transfer_${conversationId}`] || 0;\n  \n  if (currentTime - lastTransferTime < transferWindow) {\n    console.log(`[TRANSFER] TransferÃªncia recente detectada (${currentTime - lastTransferTime}ms atrÃ¡s) - evitando duplicaÃ§Ã£o`);\n    return JSON.stringify({\n      success: true,\n      message: \"TransferÃªncia jÃ¡ em andamento! Um atendente te ajudarÃ¡ em breve. ðŸ˜Š\"\n    });\n  }\n  \n  // Marcar o timestamp desta transferÃªncia\n  global[`last_transfer_${conversationId}`] = currentTime;\n  \n  // 3. Enviar nota interna com informaÃ§Ãµes completas\n  const noteContent = `ðŸ“‹ TRANSBORDO AUTOMÃTICO - Bella (IA)\n\nðŸ”¹ Execution ID: ${executionId}\nðŸ”¹ Motivo: ${reason}\nðŸ”¹ Resumo: ${summary}\nðŸ”¹ Cliente: ${chatwoot.user_name}\nðŸ”¹ Conversa ID: ${conversationId}\nðŸ”¹ Data/Hora: ${new Date().toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'})}\n\nConversa transferida automaticamente pela IA para atendimento humano especializado.`;\n\n  console.log(`[TRANSFER] Enviando nota interna...`);\n  \n  await axios.post(messagesUrl, {\n    content: noteContent,\n    message_type: \"outgoing\",\n    private: true\n  }, { headers: chatwootHeaders });\n  \n  console.log(`[TRANSFER] Nota interna enviada com sucesso`);\n  \n  // 4. Aguardar um momento antes de mudar o status\n  await new Promise(resolve => setTimeout(resolve, 2000));\n  \n  // 5. VERIFICAR NOVAMENTE O STATUS antes de alterar (proteÃ§Ã£o final)\n  try {\n    const finalStatusCheck = await axios.get(`${chatwootUrl}`, { \n      headers: chatwootHeaders \n    });\n    \n    if (finalStatusCheck.data.status === 'open') {\n      console.log(`[TRANSFER] Status jÃ¡ foi alterado por outra execuÃ§Ã£o - finalizando sem duplicar`);\n      return JSON.stringify({\n        success: true,\n        message: \"Conversa jÃ¡ transferida! Um atendente te ajudarÃ¡ em breve. ðŸ˜Š\"\n      });\n    }\n  } catch (finalCheckError) {\n    console.log(`[TRANSFER] NÃ£o foi possÃ­vel fazer verificaÃ§Ã£o final: ${finalCheckError.message}`);\n  }\n  \n  // 6. Mudar status para \"open\"\n  console.log(`[TRANSFER] Mudando status para open...`);\n  const statusResponse = await axios.post(statusUrl, {\n    status: \"open\"\n  }, { headers: chatwootHeaders });\n  \n  console.log(`[TRANSFER] Status alterado com sucesso: HTTP ${statusResponse.status}`);\n  \n  // 7. Log de finalizaÃ§Ã£o\n  console.log(`[TRANSFER] Transbordo concluÃ­do com sucesso - Execution ID: ${executionId}`);\n  \n  // 8. Retornar mensagem para o cliente\n  return JSON.stringify({\n    success: true,\n    message: \"Perfeito! Transferi vocÃª para um de nossos atendentes especializados que te ajudarÃ¡ em breve! ðŸ˜Š\"\n  });\n  \n} catch (error) {\n  console.error(`[TRANSFER] Erro no transbordo:`, error.message);\n  console.error(`[TRANSFER] Stack trace:`, error.stack);\n  \n  return JSON.stringify({\n    success: false,\n    message: \"Houve um problema na transferÃªncia, mas vou te conectar com nossa equipe. Um momento...\",\n    error: `Erro no transbordo: ${error.message}`\n  });\n}",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"reason\": {\n      \"type\": \"string\",\n      \"description\": \"Motivo especÃ­fico do transbordo (ex: 'Cliente pediu para falar com atendente', 'Cliente com dÃºvidas sobre cancelamento')\"\n    },\n    \"summary\": {\n      \"type\": \"string\", \n      \"description\": \"Resumo breve da conversa atÃ© agora (ex: 'Cliente interessado no Beauty Show Make BH, mas quer falar com atendente sobre formas de pagamento')\"\n    }\n  },\n  \"required\": [\"reason\", \"summary\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.2,
      "position": [
        1820,
        1580
      ],
      "id": "0cb49082-2fbc-4eb9-84b4-5581f4565252",
      "name": "transfer_to_human"
    }
  ],
  "connections": {
    "Memory": {
      "ai_memory": [
        [
          {
            "node": "Main Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Main Agent": {
      "main": [
        [
          {
            "node": "No Operation 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add to List": {
      "main": [
        [
          {
            "node": "Get List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get List": {
      "main": [
        [
          {
            "node": "Switch 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON": {
      "main": [
        [
          {
            "node": "Split Itens",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop": {
      "main": [
        [
          {
            "node": "Execute Core",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Itens": {
      "main": [
        [
          {
            "node": "Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Media": {
      "main": [
        [
          {
            "node": "Switch 02",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 02": {
      "main": [
        [
          {
            "node": "Transcription",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Convert PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset List": {
      "main": [
        [
          {
            "node": "Chatwoot Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Final List 2": {
      "main": [
        [
          {
            "node": "Switch 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Final List 1": {
      "main": [
        [
          {
            "node": "Parse JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cooldown": {
      "main": [
        [
          {
            "node": "Get List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation 2": {
      "main": [
        []
      ]
    },
    "Consumer": {
      "main": [
        [
          {
            "node": "Get Vars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 3": {
      "main": [
        [
          {
            "node": "No Operation ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Reset List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Input": {
      "main": [
        [
          {
            "node": "Main Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter": {
      "ai_languageModel": [
        []
      ]
    },
    "Get Vars": {
      "main": [
        [
          {
            "node": "Downtime",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert PDF": {
      "main": [
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transcription": {
      "main": [
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Core": {
      "main": [
        [
          {
            "node": "Get Final List 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear History": {
      "main": [
        [
          {
            "node": "Parse JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restart History": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Switch 2": {
      "main": [
        [
          {
            "node": "Download Media",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Keep Loop",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Switch 1": {
      "main": [
        [
          {
            "node": "No Operation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Final List 1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Cooldown",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 0": {
      "main": [
        [
          {
            "node": "Update History",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Add to List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Keep Loop": {
      "main": [
        [
          {
            "node": "Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update History": {
      "main": [
        [
          {
            "node": "Open Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chatwoot Output": {
      "main": [
        [
          {
            "node": "Add Register",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Register": {
      "main": [
        []
      ]
    },
    "Set Timer": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Knowledge Trigger": {
      "main": [
        [
          {
            "node": "Get Global Vars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Global Vars": {
      "main": [
        [
          {
            "node": "Process Docs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Docs": {
      "main": [
        []
      ]
    },
    "Vector Trigger": {
      "main": [
        [
          {
            "node": "Parse JSON 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON 2": {
      "main": [
        [
          {
            "node": "Split Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Vectors": {
      "main": [
        [
          {
            "node": "Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings": {
      "main": [
        [
          {
            "node": "Add Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Vectors": {
      "main": [
        []
      ]
    },
    "RAG Input": {
      "main": [
        [
          {
            "node": "Get History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retriever": {
      "ai_tool": [
        [
          {
            "node": "RAG Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter ": {
      "ai_languageModel": [
        []
      ]
    },
    "Mapping": {
      "main": [
        [
          {
            "node": "Switch 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation ": {
      "main": [
        [
          {
            "node": "Clear History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Downtime": {
      "main": [
        [
          {
            "node": "Mapping",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation 0": {
      "main": [
        [
          {
            "node": "Keep Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Trigger": {
      "main": [
        [
          {
            "node": "Get Dimensions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Dimensions": {
      "main": [
        [
          {
            "node": "Update Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG Agent": {
      "main": [
        [
          {
            "node": "No Operation 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get History": {
      "main": [
        [
          {
            "node": "RAG Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scheduling": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Scheduling Trigger": {
      "main": [
        [
          {
            "node": "Calendar Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clickup": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "RAG Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Main Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "transfer_to_human": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {},
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "57d67c80-b16d-451f-9bad-610e0893e53e",
  "triggerCount": 7,
  "tags": []
}