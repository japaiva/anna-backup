{
  "createdAt": "2025-04-26T20:38:17.301Z",
  "updatedAt": "2025-04-29T18:06:58.569Z",
  "id": "LQ19C52Nja6cCqe5",
  "name": "[Anna] v2",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Core Input').item.json.body.mapping.parseJson().system.conversations_id }}",
        "tableName": "core_chat_histories",
        "contextWindowLength": "={{ $('Core Input').item.json.body.mapping.parseJson().system.context_window }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        1140,
        1580
      ],
      "id": "eba64d47-8f88-48d6-8b6a-bca4629deb8b",
      "name": "Memory",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "width": 780,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        960,
        1540
      ],
      "typeVersion": 1,
      "id": "d2a433ce-9c89-4fe2-9fbf-662169e66a0d",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.body.content || ' ' }}",
        "options": {
          "systemMessage": "=Voce é a Anna, uma assistente da Beauty Show.  Diga seu nome e pergunte o nome de quem está chamando e guarde em {{nomecliente}} Não pergunte como posso te ajudar hoje!  Em seguida pergunte de onde a pesssoa é. \n\nNunca use hiperlinks\n\n<system_information>\n1. Data e hora atuais: {{ $now.format(\"EEE, MMM dd, yyyy, HH:mm\") }}\n</system_information>\n\n<retrieval_augmented_generation_result>\n{{ $json.body.rag_return }}\n</retrieval_augmented_generation_result>\n\n<prompt>\n  {{ $json.body.mapping.parseJson().system.system_message }}\n</prompt>\n\n",
          "passthroughBinaryImages": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        1260,
        1320
      ],
      "id": "caa20e44-11ed-4bd9-84d0-6babe8bf6317",
      "name": "Main Agent"
    },
    {
      "parameters": {
        "operation": "push",
        "list": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "messageData": "={{ JSON.stringify({\n    'content': $('Mapping').first().json.chatwoot.content,\n    'data_url': $('Mapping').first().json.chatwoot.data_url,\n    'timestamp': $now,\n    'message_id': $('Mapping').first().json.chatwoot.message_id\n}) }}",
        "tail": true
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -300,
        680
      ],
      "id": "f38efd9f-18ce-4c0c-98b4-7983a19e7de0",
      "name": "Add to List",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -100,
        680
      ],
      "id": "2b512577-c712-425a-b6bd-1b0d6841e09f",
      "name": "Get List",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        300,
        480
      ],
      "id": "31dc41d2-ba03-4e7a-b3d8-0251d3df8e8a",
      "name": "No Operation"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"data\": {{ \n    (() => {\n      const sourceNodeName = $('Get Final List 2').isExecuted ? 'Get Final List 2' : $prevNode.name;\n      const data = $(sourceNodeName).first().json.data;\n      const uniqueIds = new Set();\n      const messages = [];\n\n      data.reduce((_, buffer) => {\n        const parsed = JSON.parse(buffer);\n        if (!uniqueIds.has(parsed.message_id)) {\n          uniqueIds.add(parsed.message_id);\n\n          let index = messages.findIndex(msg => msg.message_id > parsed.message_id);\n          if (index === -1) index = messages.length;\n          messages.splice(index, 0, parsed);\n        }\n      }, []);\n\n      return messages.reduce((acc, msg) => {\n        delete msg.message_id;\n        acc.push({ content: msg, loop_reset: true });\n        return acc;\n      }, []);\n\n    })()\n  }}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        700,
        780
      ],
      "id": "56c62db7-ba58-43d5-a741-90a3f788e2fb",
      "name": "Parse JSON"
    },
    {
      "parameters": {
        "fieldToSplitOut": "data",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -1300,
        1300
      ],
      "id": "f6938961-3079-4917-9a71-afa7cdee37c9",
      "name": "Split Itens"
    },
    {
      "parameters": {
        "options": {
          "reset": "={{ $json.loop_reset }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -1100,
        1300
      ],
      "id": "2557f44f-a46d-4be9-9fbb-54445cd3adc5",
      "name": "Loop"
    },
    {
      "parameters": {
        "url": "={{ $json.content.data_url }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -700,
        1300
      ],
      "id": "287e6687-337c-4e05-bc09-c3c3a5708a3e",
      "name": "Download Media"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{\n  $binary.data?.fileExtension === 'oga' \n    ? 0 \n    : !$binary.data || ['png', 'jpg', 'jpeg'].includes($binary.data.fileExtension)\n      ? 1 \n      : $binary.data.fileExtension === 'pdf' \n        ? 2 \n        : 3\n}}"
      },
      "id": "fafc6665-bdb2-4bc8-8e73-3e97fd6ecee7",
      "name": "Switch 02",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -500,
        1300
      ]
    },
    {
      "parameters": {
        "content": "",
        "height": 600,
        "width": 2300,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1400,
        380
      ],
      "typeVersion": 1,
      "id": "3890e33b-6500-44d7-8045-200c46b52135",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "",
        "height": 1360,
        "width": 2340,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1420,
        360
      ],
      "typeVersion": 1,
      "id": "235863e6-541c-44bf-a7a1-6487b692c76e",
      "name": "Sticky Note2"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1620,
        1320
      ],
      "id": "e58ddba9-7d2d-426a-a322-9e4d7de3c2df",
      "name": "No Operation 2"
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}"
      },
      "id": "384e7cbb-da65-4ed7-b144-3fd3b80f402b",
      "name": "Reset List",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        300,
        1300
      ],
      "notesInFlow": false,
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -100,
        1100
      ],
      "id": "a58746f8-dcd6-4e0d-afb9-76120bdd9e61",
      "name": "Get Final List 2",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        500,
        580
      ],
      "id": "68f9ccba-54cc-45d3-b489-e83cdde81ec8",
      "name": "Get Final List 1",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "=41"
      },
      "id": "90e3fce7-6625-46c9-9b27-4cf2ced01be5",
      "name": "Reset List 2",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        700,
        580
      ],
      "notesInFlow": false,
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "amount": "={{ \n  $('Mapping').first().json.system.cooldown - $now.diffTo(\n    JSON.parse($('Get List').item.json.data.last()).timestamp,\n    'seconds'\n  )\n}}"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        300,
        680
      ],
      "id": "4b699b17-228b-4dd1-ad1f-f1ce74a09ea4",
      "name": "Cooldown",
      "webhookId": "816f562a-62f9-4197-b5da-004f01f371fe"
    },
    {
      "parameters": {
        "queue": "main-n8n",
        "options": {
          "acknowledge": "executionFinishesSuccessfully",
          "jsonParseBody": true,
          "onlyContent": true
        }
      },
      "type": "n8n-nodes-base.rabbitmqTrigger",
      "typeVersion": 1,
      "position": [
        -1300,
        580
      ],
      "id": "bf8a1e4f-8f98-41dc-8d9a-d286086c9630",
      "name": "Consumer",
      "credentials": {
        "rabbitmq": {
          "id": "zbqB1qaBGZEpzbgR",
          "name": "RabbitMQ account"
        }
      }
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{ \n  $node[\"Get Final List 2\"].runIndex === 0\n    ? (\n        JSON.parse($('Get Final List 1').first().json.data.last()).timestamp ===\n        JSON.parse($('Get Final List 2').first().json.data.last()).timestamp\n      ) ? 1 : 0\n    : (\n          JSON.parse($('Get Final List 2').all(0, $runIndex - 0).first().json.data.last()).timestamp ===\n          JSON.parse($('Get Final List 2').all(0, $runIndex - 1).first().json.data.last()).timestamp\n      ) ? 1 : 0\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        100,
        1200
      ],
      "id": "a2a6018c-f2d1-4e0d-89d9-189183c39b8d",
      "name": "Switch 3"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "main",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        1060,
        1320
      ],
      "id": "a84bdb0a-c2f0-4ad2-919a-cd2a8f39c74b",
      "name": "Core Input",
      "webhookId": "d503e6f9-0989-42d5-a598-e268b20c3182"
    },
    {
      "parameters": {
        "model": "={{ $json.body.mapping.parseJson().system.model }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        1020,
        1580
      ],
      "id": "25612fc6-0adb-47ea-8f4f-5c8e1f106a9d",
      "name": "OpenRouter",
      "credentials": {
        "openRouterApi": {
          "id": "fbVI3oy00ZqZFPfH",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 860,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        960,
        1220
      ],
      "id": "79cb0a5a-0fda-4787-bd59-a7a8817af68c",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "",
        "height": 520,
        "width": 900,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        940,
        1200
      ],
      "typeVersion": 1,
      "id": "325c8cd9-46f0-4a59-9542-0a71c02c3ced",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "content": "",
        "height": 700,
        "width": 2300,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1400,
        1000
      ],
      "typeVersion": 1,
      "id": "3aecf5ab-87b5-4291-9d18-5eebbc1928d8",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=DO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 \n    FROM ai_agents\n    WHERE account_id = {{ $json.body.account.id }}\n      AND {{ $json.body.inbox.id }} = ANY(string_to_array(inboxes_ids, ',')::int[])\n  ) THEN\n    RAISE EXCEPTION 'Nenhum AI Agent encontrado para a conta % e inbox %', {{ $json.body.account.id }}, {{ $json.body.inbox.id }};\n  END IF;\nEND $$;\nWITH\n-- 1) Seleciona o AI Agent associado à conta e à caixa de entrada\nselected_ai AS (\n    SELECT ai.*\n    FROM ai_agents ai\n    WHERE ai.account_id = {{ $json.body.account.id }}\n      AND {{ $json.body.inbox.id }} = ANY(string_to_array(ai.inboxes_ids, ',')::int[])\n    LIMIT 1\n),\n-- 2) Seleciona as variáveis globais (assume-se que seja um singleton)\nselected_gv AS (\n    SELECT *\n    FROM global_vars\n    LIMIT 1\n),\n-- 3) Faz o upsert do usuário: insere se não existir, caso contrário, ignora\nupsert_user AS (\n    INSERT INTO users (id, date_created, picture_url, username, phone, ai_agent)\n    SELECT {{ $json.body.sender.id }}, NOW(), '{{ $json.body.sender.avatar }}', '{{ $json.body.sender.name }}', '{{ $json.body.sender.phone_number }}', ai.id\n    FROM selected_ai ai\n    WHERE ai.id IS NOT NULL\n    ON CONFLICT (id) DO NOTHING\n    RETURNING *\n),\n-- 4) Seleciona o usuário (recém-inserido ou existente)\nfinal_user AS (\n    SELECT * FROM upsert_user\n    UNION\n    SELECT * FROM users\n    WHERE id = {{ $json.body.sender.id }}\n),\n-- 5) Cria uma nova conversa apenas se não existir nenhuma para esse usuário\nmaybe_new_conversation AS (\n    INSERT INTO conversations (id, user_id, date_created)\n    SELECT gen_random_uuid(), final_user.id, NOW()\n    FROM final_user\n    WHERE NOT EXISTS (\n        SELECT 1\n        FROM conversations\n        WHERE user_id = final_user.id\n    )\n    RETURNING *\n),\n-- 6) Seleciona a última conversa do usuário (nova ou existente)\nlast_conversation AS (\n    SELECT * FROM maybe_new_conversation\n    UNION\n    SELECT * FROM conversations\n    WHERE user_id = (SELECT id FROM final_user)\n    ORDER BY date_created DESC\n    LIMIT 1\n),\n-- 7) Seleciona os históricos de chat (simplificado)\nchat_histories AS (\n    SELECT ch.*\n    FROM core_chat_histories ch\n    JOIN last_conversation lc ON ch.session_id = lc.id\n    ORDER BY ch.date_created DESC\n    LIMIT (SELECT context_window FROM selected_ai)\n),\n-- 8) Seleciona os calendários (scheduling) associados ao usuário\nuser_calendars AS (\n    SELECT sch.*\n    FROM event_history_user sch\n    WHERE sch.user_id = (SELECT id FROM final_user)\n),\n-- 9) Seleciona os eventos do usuário a partir da data atual\nuser_events AS (\n    SELECT eh.*\n    FROM event_history eh\n    JOIN user_calendars uc ON eh.session_id = uc.id\n    WHERE eh.date >= CURRENT_DATE\n    ORDER BY eh.date ASC  -- Ordenando cronologicamente a partir de hoje\n)\n-- 10) Retorna os resultados no formato JSON\nSELECT\n    (SELECT row_to_json(ai) FROM selected_ai ai) AS ai_agents,\n    (SELECT row_to_json(gv) FROM selected_gv gv) AS global_vars,\n    (SELECT row_to_json(final_user) FROM final_user) AS users,\n    (SELECT row_to_json(last_conversation) FROM last_conversation) AS conversations,\n    (SELECT json_agg(row_to_json(ch)) FROM chat_histories ch) AS core_chat_histories,\n    (SELECT COALESCE(json_agg(evt), '[]'::json) FROM user_events evt) AS events;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1100,
        580
      ],
      "id": "5dc52430-9223-4274-8491-de1754c40d62",
      "name": "Get Vars",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://{{ $('Mapping').item.json.system.stirling_pdf_service }}:8080/api/v1/convert/pdf/img",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-KEY",
              "value": "={{ $('Mapping').first().json.system.stirling_pdf_key }}"
            },
            {
              "name": "accept",
              "value": "*/*"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "imageFormat",
              "value": "jpg"
            },
            {
              "name": "singleOrMultiple",
              "value": "single"
            },
            {
              "name": "colorType",
              "value": "color"
            },
            {
              "name": "dpi",
              "value": "80"
            },
            {
              "parameterType": "formBinaryData",
              "name": "fileInput",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "f1ebf6a5-de30-4492-8e13-943761e79db6",
      "name": "Convert PDF",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -300,
        1400
      ],
      "notesInFlow": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/audio/transcriptions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $('Mapping').first().json.system.openai_key }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "whisper-1"
            },
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "d3c25024-7b73-4ab9-8880-981c27068ba9",
      "name": "Transcription",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -300,
        1200
      ],
      "notesInFlow": true
    },
    {
      "parameters": {
        "content": "Fluxo de processamento principal",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1380,
        400
      ],
      "id": "a6d3c581-b365-4c04-bbba-74261115544a",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\nconst mappingData = $('Mapping').first().json; // Obtém todo o conteúdo de 'Mapping'\nconsole.log(\"Mapping Data:\", mappingData);\n\nconst baseWebhookUrl = `http://${mappingData.system.n8n_webhook_service}:5678/webhook/`;\nconst finalWorkflowPath = mappingData.system.workflow_path;\nconst defaultFinalUrl = `${baseWebhookUrl}${finalWorkflowPath}`;\n\nconst formData = new FormData();\n\n// Unifica os valores de \"content\" com quebra de linha dupla\nconst unifiedContent = items\n  .map(item => item.json.content)\n  .filter(content => content) // Remove itens vazios ou undefined\n  .join('\\n\\n');\nconsole.log(\"Unified Content:\", unifiedContent);\n\n// Monta o JSON separado para o corpo da requisição\nconst jsonData = {\n  content: unifiedContent,\n  mapping: mappingData\n};\n\n// Adiciona os dados JSON ao FormData\nformData.append('content', jsonData.content);\nformData.append('mapping', JSON.stringify(jsonData.mapping));\n\n// Adiciona arquivos binários mantendo os nomes originais\nitems.forEach((item) => {\n  if (item.binary) {\n    Object.keys(item.binary).forEach((key) => {\n      const file = item.binary[key];\n      formData.append(key, Buffer.from(file.data, 'base64'), {\n        filename: file.fileName || key,\n        contentType: file.mimeType,\n      });\n    });\n  }\n});\n\nif (mappingData.system.enabled_rag === true || mappingData.system.enabled_rag === 'true') {\n  console.log(\"RAG is enabled. Sending request to the RAG endpoint first.\");\n  const ragUrl = `${baseWebhookUrl}rag`;\n  console.log(`Sending RAG request to: ${ragUrl}`);\n\n  return axios.post(ragUrl, formData, { headers: formData.getHeaders() })\n    .then(ragResponse => {\n      console.log(\"RAG Response received:\", ragResponse.data);\n      // Ajuste: obter o valor de \"output\" em vez de \"rag_return\"\n      const rag_return = ragResponse.data.output;\n      jsonData.rag_return = rag_return; // Inclui o retorno do RAG no JSON\n\n      // Reconstroi o FormData com os dados atualizados (incluindo rag_return)\n      const finalFormData = new FormData();\n      finalFormData.append('content', jsonData.content);\n      finalFormData.append('mapping', JSON.stringify(jsonData.mapping));\n      finalFormData.append('rag_return', rag_return);\n      items.forEach((item) => {\n        if (item.binary) {\n          Object.keys(item.binary).forEach((key) => {\n            const file = item.binary[key];\n            finalFormData.append(key, Buffer.from(file.data, 'base64'), {\n              filename: file.fileName || key,\n              contentType: file.mimeType,\n            });\n          });\n        }\n      });\n      \n      // Recupera a URL final do mapping; se não existir, usa a URL padrão\n      let finalUrl = mappingData.system.rag_return;\n      if (!finalUrl) {\n        console.error(\"mappingData.system.rag_return is undefined. Using default final URL instead.\");\n        finalUrl = defaultFinalUrl;\n      }\n      console.log(`Mapping system.rag_return value: \"${finalUrl}\"`);\n      console.log(\"Sending final request to the RAG final endpoint...\");\n\n      return axios.post(finalUrl, finalFormData, { headers: finalFormData.getHeaders() })\n        .then(finalResponse => {\n          console.log(\"Final Response received:\", finalResponse.data);\n          return [{\n            json: {\n              rag: ragResponse.data,\n              final: finalResponse.data,\n              logs: [\n                `RAG request sent to: ${ragUrl}`,\n                `RAG response received with output: ${rag_return}`,\n                `Final request sent to: ${finalUrl}`,\n                `Final response received successfully.`\n              ]\n            }\n          }];\n        })\n        .catch(finalError => {\n          console.error(`Final request error for URL (${finalUrl}):`, finalError.message);\n          return [{\n            json: {\n              error: finalError.message,\n              rag: ragResponse.data,\n              logs: [\n                `RAG request sent to: ${ragUrl}`,\n                `RAG response received with output: ${rag_return}`,\n                `Attempted final request to: ${finalUrl}`,\n                `Final request error: ${finalError.message}`\n              ]\n            }\n          }];\n        });\n    })\n    .catch(ragError => {\n      console.error(\"RAG request error:\", ragError.message);\n      return [{\n        json: {\n          error: ragError.message,\n          logs: [\n            `RAG request sent to: ${baseWebhookUrl}rag`,\n            `RAG request error: ${ragError.message}`\n          ]\n        }\n      }];\n    });\n} else {\n  console.log(\"RAG is not enabled. Sending request directly to the default final URL:\", defaultFinalUrl);\n  return axios.post(defaultFinalUrl, formData, { headers: formData.getHeaders() })\n    .then(response => {\n      console.log(\"Final Response received:\", response.data);\n      return [{\n        json: {\n          final: response.data,\n          logs: [\n            `Final request sent to: ${defaultFinalUrl}`,\n            `Final response received successfully.`\n          ]\n        }\n      }];\n    })\n    .catch(error => {\n      console.error(\"Final request error:\", error.message);\n      return [{\n        json: {\n          error: error.message,\n          logs: [\n            `Final request error for URL (${defaultFinalUrl}): ${error.message}`\n          ]\n        }\n      }];\n    });\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -900,
        1100
      ],
      "id": "c554b7b7-9e86-4318-8c13-b220a7bb8b46",
      "name": "Execute Core"
    },
    {
      "parameters": {
        "content": "Fluxo Core, responsável pelo processamento da AI",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1000,
        1180
      ],
      "id": "ca510ab9-7adf-4bb7-ba22-1710dc1295f9",
      "name": "Sticky Note14"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Obtém o último item da tabela conversations com base no campo 'date_created'\nWITH last_conversation AS (\n    SELECT id \n    FROM conversations\n    WHERE user_id = {{ $('Mapping').first().json.chatwoot.contact_id }}\n    ORDER BY date_created DESC\n    LIMIT 1\n),\n\n-- Obtém os últimos dois registros da tabela core_chat_histories com base no session_id\nlast_two_chat_histories AS (\n    SELECT id \n    FROM core_chat_histories\n    WHERE session_id = (SELECT id FROM last_conversation)\n    ORDER BY id DESC\n    LIMIT 2\n)\n\n-- Deleta os últimos dois registros encontrados\nDELETE FROM core_chat_histories\nWHERE id IN (SELECT id FROM last_two_chat_histories);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        500,
        1100
      ],
      "id": "b39ad79d-99b1-48ce-8fde-ee081dd48322",
      "name": "Clear History",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "name": "restart_history",
        "description": "=Invoque essa tool para iniciar uma nova conversa para o user, assim ignorando o histórico passado. Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\n\n// Converte o mapeamento recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usuário é admin; caso contrário, retorna erro\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usuário não autorizado.\" });\n}\n\n/**\n * Função que espera pelo tempo especificado.\n * @param {number} ms - Milissegundos a aguardar.\n * @returns {Promise<void>}\n */\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Função para enviar a requisição para criar uma conversa no Directus.\n * Tenta até 3 vezes em caso de falha, com delay de 1 segundo entre as tentativas.\n * @returns {Promise<object>} - Objeto com sucesso ou erro.\n */\nasync function sendRequest() {\n  const url = `http://${mapping.system.directus_service}:8055/items/conversations`;\n  const data = {\n    user_id: mapping.chatwoot.contact_id,\n    date_created: new Date().toISOString()\n  };\n  const headers = {\n    Authorization: `Bearer ${mapping.system.directus_token}`,\n    'Content-Type': 'application/json'\n  };\n\n  let attempt = 0;\n  let lastError = null;\n\n  while (attempt < 3) {\n    try {\n      const response = await axios.post(url, data, { headers });\n      console.log(`Requisição realizada com sucesso na tentativa ${attempt + 1}.`);\n      return { success: true, data: response.data };\n    } catch (error) {\n      attempt++;\n      lastError = error;\n      console.error(`Tentativa ${attempt} falhou:`, error.response ? error.response.data : error.message);\n      if (attempt < 3) {\n        console.log(\"Aguardando 1 segundo antes da nova tentativa...\");\n        await delay(1000);\n      }\n    }\n  }\n  \n  return { success: false, error: lastError.response ? lastError.response.data : lastError.message };\n}\n\nreturn sendRequest().then(result => JSON.stringify(result));"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1260,
        1580
      ],
      "id": "2c8d4091-4798-44a3-89e5-d44ee314d784",
      "name": "Restart History"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{\n  $json.content.data_url?.match(/\\.(oga|png|jpg|jpeg|txt|pdf)$/i) !== null \n  && !!$json.content.data_url \n    ? 0 \n    : !!$json.content.content \n      ? 1\n      : 2\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -900,
        1500
      ],
      "id": "d7a5fbdf-6e60-4d93-8d49-6c16ce8f5965",
      "name": "Switch 2"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{ \n  $('Add to List').item.json.chatwoot.message_id !==\n  JSON.parse($('Get List').item.json.data.first()).message_id\n    ? 0\n    : $now.minus($('Mapping').first().json.system.cooldown, 'seconds').diffTo(\n        JSON.parse($('Get List').item.json.data.last()).timestamp,\n        'seconds'\n      ) >= 0\n      ? 1\n      : 2\n}}\n\n\n\n"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        100,
        580
      ],
      "id": "be373b6a-08f3-45d3-b4b5-4bcaacf1f5fe",
      "name": "Switch 1"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{\n  (\n    $('Mapping').first().json.chatwoot.channel !== 'WhatsApp Web Group' ||\n    (\n      $('Mapping').first().json.system.allow_whatsapp_groups === 'always_enabled' ||\n      (\n        $('Mapping').first().json.system.allow_whatsapp_groups === 'enabled_when_mentioned' &&\n        $('Mapping').first().json.system.agent_mentioned\n      )\n    )\n  )\n  &&\n  {\n    'pending_status': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact' &&\n      $('Mapping').first().json.chatwoot.conversation_status === 'pending',\n\n    'all_status': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact',\n\n    'not_assigned': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact' &&\n      !$('Mapping').first().json.chatwoot.assignee\n  }[$('Mapping').first().json.system.enabled_condition]\n    ? 1\n    : 0\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -500,
        580
      ],
      "id": "fa7fce13-38d7-435a-bc81-1e7aa9471bf9",
      "name": "Switch 0"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7cade77f-2498-4515-991a-cbe2d5ffe67a",
              "name": "content",
              "value": "={{\n  $json.content?.content \n  || $json.text \n  || (\n    $('Switch 2').item.json.content.data_url.endsWith('.txt') \n      ? $json.data + '\\n\\n' + $('Switch 2').item.json.content?.content \n      : null\n  )\n}}",
              "type": "string"
            },
            {
              "id": "e8da4202-58a2-4990-9e36-9a56f18c7263",
              "name": "loop_reset",
              "value": false,
              "type": "boolean"
            }
          ]
        },
        "includeOtherFields": true,
        "include": "selected",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        100,
        1500
      ],
      "id": "8e0bfa01-3df5-4f79-a805-9cada188d368",
      "name": "Keep Loop"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "core_chat_histories",
          "mode": "list",
          "cachedResultName": "core_chat_histories"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "date_created": "={{ $now }}",
            "session_id": "={{ $json.system.conversations_id }}",
            "message": "={{ JSON.parse(JSON.stringify({\n  \"type\": \"human\",\n  \"content\": $json.chatwoot.content,\n  \"user_name\": $json.chatwoot.user_name\n})) }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "message",
              "displayName": "message",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "date_created",
              "displayName": "date_created",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -300,
        480
      ],
      "id": "995200dd-f24d-4c62-86cf-459a81b1805b",
      "name": "Update History",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\nconst mapping = $('Mapping').first().json;\nconst { system, chatwoot } = mapping;\n\nif (\n  system.allow_human_interruption &&\n  system.enabled_condition === 'pending_status' &&\n  chatwoot.sender_type === 'User' &&\n  chatwoot.conversation_status !== 'open'\n) {\n  const chatwootService = system.chatwoot_service;\n  return axios.post(\n    `http://${chatwootService}:3000/api/v1/accounts/${chatwoot.account_id}/conversations/${chatwoot.conversation_id}/toggle_status`,\n    { status: \"open\" },\n    { headers: { api_access_token: chatwoot.bot_token } }\n  )\n  .then(res => [{ json: res.data }])\n  .catch(err => [{ json: { error: err.response?.data || err.message } }]);\n}\n\nreturn [{ json: { message: \"Nenhuma ação realizada\" } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -100,
        480
      ],
      "id": "75d385e0-847d-406c-b433-32be456f9bbd",
      "name": "Open Conversation"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\n// Array para armazenar logs detalhados\nconst detailedLogs = [];\n\n// Funções de log aprimoradas\nfunction logMessage(msg) {\n  console.log(msg);\n  detailedLogs.push({ type: 'info', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logError(msg) {\n  console.error(msg);\n  detailedLogs.push({ type: 'error', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logRequest(method, url, headers, payload) {\n  detailedLogs.push({\n    type: 'request',\n    method,\n    url,\n    headers,\n    payload,\n    timestamp: new Date().toISOString()\n  });\n}\n\nfunction logResponse(status, data) {\n  detailedLogs.push({\n    type: 'response',\n    status,\n    data,\n    timestamp: new Date().toISOString()\n  });\n}\n\n// ------------------------------\n// Configurações Gerais\n// ------------------------------\nconst MIN_TOTAL_LENGTH = 50;               // Texto menor que 50 caracteres: enviar inteiro.\nconst MIN_SEGMENT_LENGTH = 20;             // Segmentos menores que 20 caracteres serão mesclados.\nconst DESIRED_TEXT_SEGMENT_SIZE = 200;       // Tamanho ideal para segmentos no modo \"text\".\nconst DESIRED_AUDIO_SEGMENT_SIZE = 450;      // Tamanho ideal para segmentos no modo \"audio\" (~30s).\nconst DELAY_FACTOR = 2000;                  // Delay: 200ms por 100 caracteres.\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// ------------------------------\n// Parâmetros obtidos dos nós\n// ------------------------------\nconst mapping = $('Mapping').first().json;\nconst chatwootData = mapping.chatwoot;\nconst accountId = chatwootData.account_id;\nconst conversationId = chatwootData.conversation_id;\nconst botToken = chatwootData.bot_token;\n\nconst system = mapping.system;\nconst outputFormat = system.output_format.toLowerCase(); // \"text\", \"audio\" ou \"smart\"\nconst elevenlabsKey = system.elevenlabs_key;\nconst elevenlabsVoice = system.elevenlabs_voice || \"JBFqnCBsd6RMkjVDRZzb\";\nconst elevenlabsModel = system.elevenlabs_model || \"eleven_multilingual_v2\";\nconst chatwootService = system.chatwoot_service; // Valor para a URL do Chatwoot\n\n// Texto original (ajustado para acessar o payload final corretamente)\nconst originalText = $('Execute Core').first().json.final.output;\nlogMessage(`[Main] Texto original possui ${originalText.length} caracteres.`);\nlogMessage(`[Main] Modo de saída: ${outputFormat}`);\n\n// Endpoint do Chatwoot (ajustado para usar chatwootService)\n//const chatwootUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\n//logMessage(`[Main] Chatwoot URL: ${chatwootUrl}`);\n\nconst chatwootUrl = `https://chat.spsystems.pro/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\nlogMessage(`[Main] Chatwoot URL: ${chatwootUrl}`);\n\n\n\n// Log dos parâmetros de entrada\nlogMessage(`[Main] Parâmetros: accountId=${accountId}, conversationId=${conversationId}`);\nlogMessage(`[Main] Chatwoot Service: ${chatwootService}`);\nlogMessage(`[Main] Token (primeiros 5 caracteres): ${botToken.substring(0, 5)}...`);\n\n// ------------------------------\n// Função para enviar mensagem de texto\n// ------------------------------\nasync function sendTextMessage(content) {\n  const payload = { content, message_type: \"outgoing\" };\n  const headers = {\n    \"api_access_token\": botToken,\n    \"Content-Type\": \"application/json\"\n  };\n  \n  logMessage(`[sendTextMessage] Enviando mensagem de texto.`);\n  logMessage(`[sendTextMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendTextMessage] Payload: ${JSON.stringify(payload)}`);\n  logMessage(`[sendTextMessage] Headers: ${JSON.stringify(headers)}`);\n  \n  logRequest('POST', chatwootUrl, headers, payload);\n  \n  try {\n    const response = await axios.post(chatwootUrl, payload, { headers });\n    logMessage(`[sendTextMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendTextMessage] Erro ao enviar mensagem de texto: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendTextMessage] Status: ${error.response.status}`);\n      logError(`[sendTextMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendTextMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendTextMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para enviar mensagem de áudio\n// ------------------------------\nasync function sendAudioMessage(audioBuffer) {\n  const form = new FormData();\n  form.append(\"attachments[]\", audioBuffer, { filename: \"audio.mp3\", contentType: \"audio/mpeg\" });\n  form.append(\"message_type\", \"outgoing\");\n  \n  const headers = {\n    \"api_access_token\": botToken,\n    ...form.getHeaders()\n  };\n  \n  logMessage(`[sendAudioMessage] Enviando mensagem de áudio.`);\n  logMessage(`[sendAudioMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendAudioMessage] Headers: ${JSON.stringify(headers)}`);\n  logMessage(`[sendAudioMessage] Tamanho do áudio: ${audioBuffer.length} bytes`);\n  \n  logRequest('POST', chatwootUrl, headers, \"Form Data com áudio\");\n  \n  try {\n    const response = await axios.post(chatwootUrl, form, { headers });\n    logMessage(`[sendAudioMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendAudioMessage] Erro ao enviar mensagem de áudio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendAudioMessage] Status: ${error.response.status}`);\n      logError(`[sendAudioMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendAudioMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendAudioMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para converter texto em áudio via Elevenlabs\n// ------------------------------\nasync function convertTextToSpeech(text) {\n  const url = `https://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(elevenlabsVoice)}?output_format=mp3_44100_128`;\n  const headers = {\n    \"xi-api-key\": elevenlabsKey,\n    \"Content-Type\": \"application/json\"\n  };\n  const payload = {\n    text: text,\n    model_id: elevenlabsModel\n  };\n  \n  logMessage(`[convertTextToSpeech] Convertendo texto para áudio (primeiros 50 caracteres): \"${text.substring(0,50)}...\"`);\n  logMessage(`[convertTextToSpeech] URL da API Elevenlabs: ${url}`);\n  logMessage(`[convertTextToSpeech] Modelo utilizado: ${elevenlabsModel}`);\n  \n  logRequest('POST', url, headers, payload);\n  \n  try {\n    const response = await axios.post(url, payload, { headers, responseType: 'arraybuffer' });\n    logMessage(`[convertTextToSpeech] Conversão realizada com sucesso. Status: ${response.status}`);\n    logResponse(response.status, \"Binary Audio Data\");\n    return response.data;\n  } catch (error) {\n    logError(`[convertTextToSpeech] Erro ao converter texto para áudio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[convertTextToSpeech] Status: ${error.response.status}`);\n      logError(`[convertTextToSpeech] Headers: ${JSON.stringify(error.response.headers)}`);\n      // Para arraybuffer, precisamos converter para texto para ver o erro\n      if (error.response.data) {\n        try {\n          const errorText = Buffer.from(error.response.data).toString('utf8');\n          logError(`[convertTextToSpeech] Erro Response: ${errorText}`);\n          logResponse(error.response.status, errorText);\n        } catch (e) {\n          logError(`[convertTextToSpeech] Não foi possível converter resposta de erro: ${e.toString()}`);\n        }\n      }\n    } else if (error.request) {\n      logError(`[convertTextToSpeech] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para mesclar segmentos curtos (para modos text e audio)\n// ------------------------------\nfunction mergeShortSegments(segments, minLength) {\n  const merged = [];\n  let buffer = \"\";\n  for (const seg of segments) {\n    if ((buffer + \" \" + seg).trim().length < minLength) {\n      buffer = (buffer + \" \" + seg).trim();\n    } else {\n      if (buffer) {\n        merged.push(buffer);\n        buffer = \"\";\n      }\n      merged.push(seg);\n    }\n  }\n  if (buffer) {\n    if (merged.length > 0) {\n      merged[merged.length - 1] += \" \" + buffer;\n    } else {\n      merged.push(buffer);\n    }\n  }\n  return merged;\n}\n\n// ------------------------------\n// Função de segmentação genérica (evita quebrar palavras)\n// ------------------------------\nfunction segmentTextGeneric(text, desiredMaxLength) {\n  if (text.length <= desiredMaxLength) return [text];\n  \n  let segments = [];\n  // Tenta dividir por quebra de linha dupla\n  if (text.includes(\"\\n\\n\")) {\n    segments = text.split(/\\n\\s*\\n/).map(seg => seg.trim()) // .filter(seg => seg.length > 0);\n  }\n  // Se não houver, ou se não gerar resultados, dividir por delimitadores naturais (ponto, ?, !, vírgula, ;, :)\n  if (segments.length === 0) {\n    segments = text.split(/(?<=[.?!,;:])\\s+/).map(seg => seg.trim()) // .filter(seg => seg.length > 0);\n  }\n  \n  // Mescla segmentos curtos\n  segments = mergeShortSegments(segments, MIN_SEGMENT_LENGTH);\n  \n  // Se algum segmento for muito longo, subdivide-o por espaços, sem quebrar palavras\n  const finalSegments = [];\n  segments.forEach(seg => {\n    if (seg.length > desiredMaxLength * 1.5) {\n      const words = seg.split(\" \");\n      let current = \"\";\n      for (const word of words) {\n        if ((current + \" \" + word).trim().length > desiredMaxLength) {\n          finalSegments.push(current.trim());\n          current = word;\n        } else {\n          current += \" \" + word;\n        }\n      }\n      if (current.trim()) finalSegments.push(current.trim());\n    } else {\n      finalSegments.push(seg);\n    }\n  });\n  \n  return finalSegments;\n}\n\n// Função para escapar caracteres especiais\nfunction textSegmentation(text, maxSize = 200, minSize = 30) {\n  // Divide o texto em parágrafos\n  const parts = text.split(\"\\n\\n\");\n\n  // Se o texto não contém nenhum parágrafo, retorna o texto original\n  if (parts.length === 1 && parts[0].length <= maxSize) {\n    return parts;\n  }\n\n  // Processa a segmentação de cada parágrafo\n  const segments = parts.reduce((acc, part) => {\n    part = part.trim();\n\n    // Se o parágrafo é menor que o tamanho máximo, mantemos ele inteiro\n    if (part.length <= maxSize) {\n      acc.push(part.trim());\n    } else {\n      // Para parágrafos maiores que o tamanho máximo, dividimos em segmentos\n      // baseados apenas nos pontos de separação (. ! ?)\n      let currentSegment = \"\";\n      let lastSegmentEnd = 0;\n\n      // Percorremos o texto caractere por caractere\n      for (let i = 0; i < part.length; i++) {\n        const char = part[i];\n        currentSegment += char;\n\n        // Verificamos se encontramos um ponto de quebra\n        if (char === \".\" || char === \"!\" || char === \"?\") {\n          // Verificar se não é parte de uma numeração (ex: \"1.\", \"2.\")\n          const prevChar = i > 0 ? part[i - 1] : \"\";\n          const isNumbering = /\\d/.test(prevChar);\n\n          // Se for parte de uma numeração, não é um ponto de quebra\n          if (isNumbering) {\n            continue;\n          }\n\n          // Regra especial para ponto final: verificar se tem menos de 4 caracteres após o último espaço\n          if (char === \".\") {\n            // Encontra a última ocorrência de espaço no segmento atual\n            const lastSpaceIndex = currentSegment.lastIndexOf(\" \");\n\n            // Se não há espaço ou a palavra após o último espaço tem menos de 4 caracteres, não quebra\n            if (\n              lastSpaceIndex === -1 ||\n              currentSegment.length - lastSpaceIndex - 1 < 4\n            ) {\n              continue;\n            }\n          }\n\n          // Ponto de quebra válido encontrado\n          if (currentSegment.length >= minSize) {\n            // Garantimos que não há espaços extras\n            const trimmedSegment = currentSegment.trim();\n            acc.push(trimmedSegment);\n\n            // Pegamos o próximo caractere após o ponto de quebra,\n            // mas pulamos qualquer espaço inicial no próximo segmento\n            currentSegment = \"\";\n            lastSegmentEnd = i + 1;\n\n            // Avançamos o índice i para pular espaços entre segmentos\n            while (\n              lastSegmentEnd < part.length &&\n              part[lastSegmentEnd] === \" \"\n            ) {\n              lastSegmentEnd++;\n              i = lastSegmentEnd - 1; // Ajustamos i para continuar do próximo caractere não-espaço\n            }\n          }\n        }\n      }\n\n      // Adicionamos o segmento restante, se houver\n      if (currentSegment.length > 0) {\n        acc.push(currentSegment.trim());\n      }\n    }\n\n    return acc;\n  }, []);\n\n  return segments;\n}\n\n// ------------------------------\n// Funções de segmentação para cada modo\n// ------------------------------\nfunction segmentForText(text) {\n  return textSegmentation(text, DESIRED_TEXT_SEGMENT_SIZE);\n}\n\nfunction segmentForAudio(text) {\n  return textSegmentation(text, DESIRED_AUDIO_SEGMENT_SIZE);\n}\n\n/**\n * Função \"smartSegment\":\n * - Divide o texto em sentenças usando delimitadores finais.\n * - Para cada sentença, se ela contiver dígitos ou tiver menos de 80 ou mais de 600 caracteres,\n *   ela será marcada para envio como texto.\n * - Caso contrário, a sentença é considerada \"audio\".\n * - As sentenças marcadas para áudio são agrupadas até atingirem aproximadamente DESIRED_AUDIO_SEGMENT_SIZE.\n * - Após a segmentação, os segmentos do tipo \"text\" com menos que MIN_SEGMENT_LENGTH são mesclados.\n * \n * Retorna um array de objetos: { type: \"text\" | \"audio\", content: string }.\n */\nfunction smartSegment(text) {\n  const sentences = text.split(/(?<=[.?!])\\s+/).map(s => s.trim()).filter(s => s);\n  const segments = [];\n  let audioBuffer = \"\";\n  \n  for (const sentence of sentences) {\n    if (/\\d/.test(sentence) || sentence.length < 80 || sentence.length > 600) {\n      if (audioBuffer) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = \"\";\n      }\n      segments.push({ type: \"text\", content: sentence });\n    } else {\n      if ((audioBuffer + \" \" + sentence).trim().length > DESIRED_AUDIO_SEGMENT_SIZE) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = sentence;\n      } else {\n        audioBuffer = (audioBuffer + \" \" + sentence).trim();\n      }\n    }\n  }\n  if (audioBuffer) {\n    segments.push({ type: \"audio\", content: audioBuffer.trim() });\n  }\n  \n  const mergedSegments = [];\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    if (seg.type === \"text\" && seg.content.length < MIN_SEGMENT_LENGTH) {\n      if (mergedSegments.length > 0 && mergedSegments[mergedSegments.length - 1].type === \"text\") {\n        mergedSegments[mergedSegments.length - 1].content += \" \" + seg.content;\n      } else if (i < segments.length - 1 && segments[i+1].type === \"text\") {\n        segments[i+1].content = seg.content + \" \" + segments[i+1].content;\n      } else {\n        mergedSegments.push(seg);\n      }\n    } else {\n      mergedSegments.push(seg);\n    }\n  }\n  \n  return mergedSegments;\n}\n\n// ------------------------------\n// Função principal para segmentar e enviar a mensagem\n// ------------------------------\nasync function main() {\n  try {\n    logMessage(`[Main] Modo de saída selecionado: ${outputFormat}`);\n    \n    // Verificação inicial de parâmetros essenciais\n    if (!originalText || originalText.trim().length === 0) {\n      throw new Error(\"Texto original está vazio ou não foi encontrado\");\n    }\n    \n    if (!chatwootService) {\n      throw new Error(\"chatwoot_service não definido\");\n    }\n    \n    if (!accountId) {\n      throw new Error(\"account_id não definido\");\n    }\n    \n    if (!conversationId) {\n      throw new Error(\"conversation_id não definido\");\n    }\n    \n    if (!botToken) {\n      throw new Error(\"bot_token não definido\");\n    }\n    \n    // Adicionando um delay inicial para garantir que o Chatwoot esteja pronto\n    await delay(1000);\n  \n    if (outputFormat === \"audio\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo audio\");\n      }\n      \n      const segments = segmentForAudio(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para áudio.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de áudio: \"${segment.substring(0,50)}...\"`);\n        const audioBuffer = await convertTextToSpeech(segment);\n        await sendAudioMessage(audioBuffer);\n        logMessage(`[Main] Segmento de áudio enviado: \"${segment.substring(0,50)}...\"`);\n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de áudio.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem de áudio enviada com sucesso.\", logs: detailedLogs };\n    } else if (outputFormat === \"smart\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo smart\");\n      }\n      \n      const segments = smartSegment(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} parte(s) (smart mode).`);\n      \n      for (const seg of segments) {\n        if (seg.type === \"audio\") {\n          logMessage(`[Main] Processando segmento de áudio smart: \"${seg.content.substring(0,50)}...\"`);\n          const audioBuffer = await convertTextToSpeech(seg.content);\n          await sendAudioMessage(audioBuffer);\n          logMessage(`[Main] Segmento de áudio enviado: \"${seg.content.substring(0,50)}...\"`);\n        } else {\n          logMessage(`[Main] Processando segmento de texto smart: \"${seg.content.substring(0,50)}...\"`);\n          await sendTextMessage(seg.content);\n          logMessage(`[Main] Segmento de texto enviado: \"${seg.content.substring(0,50)}...\"`);\n        }\n        \n        const delayTime = Math.ceil(seg.content.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem smart enviada com sucesso.\", logs: detailedLogs };\n    } else {\n      // Modo padrão: text\n      const segments = segmentForText(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para texto.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de texto: \"${segment.substring(0,50)}...\"`);\n        await sendTextMessage(segment);\n        logMessage(`[Main] Segmento de texto enviado: \"${segment.substring(0,50)}...\"`);\n        \n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de texto.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagens de texto enviadas com sucesso.\", logs: detailedLogs };\n    }\n  } catch (error) {\n    logError(`[Main] Erro: ${error.toString()}`);\n    return { error: error.toString(), logs: detailedLogs };\n  }\n}\n\nreturn main().then(result => [{ json: result }]);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        500,
        1300
      ],
      "id": "3aa4b08c-0994-4cb9-9118-8b32ff38d404",
      "name": "Chatwoot Output"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH last_conversation AS (\n  -- Encontra a última conversa do usuário\n  SELECT id\n  FROM conversations\n  WHERE user_id = {{ $('Mapping').first().json.chatwoot.contact_id }}\n  ORDER BY date_created DESC\n  LIMIT 1\n),\nlast_two_chat_histories AS (\n  -- Obtém os dois últimos históricos da conversa e define uma ordem para identificar o penúltimo\n  SELECT \n    id,\n    ROW_NUMBER() OVER (ORDER BY id DESC) AS rn\n  FROM core_chat_histories\n  WHERE session_id = (SELECT id FROM last_conversation)\n  ORDER BY id DESC\n  LIMIT 2\n),\nupdate_chat_histories AS (\n  UPDATE core_chat_histories c\n  SET \n    date_created = NOW(),\n    message = (\n      CASE \n        WHEN l.rn = 2 \n          THEN jsonb_set(c.message::jsonb, '{user_name}', to_jsonb('{{ $('Mapping').first().json.chatwoot.user_name }}'::text), true)\n        ELSE c.message::jsonb\n      END\n    )::json\n  FROM last_two_chat_histories l\n  WHERE c.id = l.id\n  RETURNING 1\n)\nUPDATE users u\nSET date_updated = NOW()\nWHERE u.id = {{ $('Mapping').first().json.chatwoot.contact_id }};",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        700,
        1300
      ],
      "id": "26d99333-8bcc-482d-b8c4-4e641412db17",
      "name": "Add Register",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "name": "set_timer",
        "description": "Invoque essa tool para configurar um timer que iniciará uma ação após o tempo especificado. Apenas usuários admin podem usar essa tool. O tempo deve ser informado com valor e unidade (s, m, h). Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\nconst dayjs = require('dayjs');\nconst duration = require('dayjs/plugin/duration');\ndayjs.extend(duration);\n\n/**\n * Esta tool configura um timer via webhook.\n * Ela envia, para o endpoint, todo o objeto mapping (obtido em Core Input)\n * e o tempo em segundos calculado a partir dos parâmetros \"timer_value\" e \"timer_unit\".\n * Apenas usuários admin podem utilizar esta tool.\n */\n\n// Converte o mapping recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usuário é admin\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usuário não autorizado.\" });\n}\n\n// Obtém os parâmetros do timer a partir do input (query)\nconst timerValue = query.timer_value;  // Número (ex: 30)\nconst timerUnit = query.timer_unit;      // \"s\", \"m\" ou \"h\"\n\n// Calcula o tempo em segundos usando dayjs.duration\nconst timerSeconds = dayjs.duration(timerValue, timerUnit).asSeconds();\n\n// Prepara o payload para o webhook\nconst payload = {\n  mapping: mapping,\n  timer_seconds: timerSeconds\n};\n\n// URL do webhook substituindo 'n8n_webhook' pelo valor da variável no mapping\nconst url = `http://${mapping.system.n8n_webhook_service}:5678/webhook/timer`;\n\n/**\n * Função para enviar a requisição ao webhook.\n * Tenta enviar uma única vez e retorna o resultado.\n */\nasync function sendTimerRequest() {\n  try {\n    console.log(`Enviando requisição para configurar o timer para ${timerSeconds} segundos...`);\n    const response = await axios.post(url, payload, {\n      headers: { 'Content-Type': 'application/json' }\n    });\n    console.log(\"Timer configurado com sucesso.\");\n    return { success: true, message: `Timer configurado com sucesso. Ele será acionado em ${timerSeconds} segundos.` };\n  } catch (error) {\n    console.error(\"Erro ao configurar o timer:\", error.response ? error.response.data : error.message);\n    return { success: false, error: error.response ? error.response.data : error.message };\n  }\n}\n\nreturn sendTimerRequest().then(result => JSON.stringify(result));",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"timer_value\": {\n      \"type\": \"number\",\n      \"description\": \"Valor do timer. Exemplo: 30\"\n    },\n    \"timer_unit\": {\n      \"type\": \"string\",\n      \"description\": \"Unidade de tempo para o timer: 's' para segundos, 'm' para minutos, 'h' para horas.\",\n      \"enum\": [\"s\", \"m\", \"h\"]\n    }\n  },\n  \"required\": [\"timer_value\", \"timer_unit\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1380,
        1580
      ],
      "id": "3680376d-7af6-4818-b051-0aedb4da4bfa",
      "name": "Set Timer"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "tableName": {
          "__rl": true,
          "value": "knowledge",
          "mode": "list",
          "cachedResultName": "knowledge"
        },
        "additionalFields": {},
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTrigger",
      "typeVersion": 1,
      "position": [
        -1300,
        1860
      ],
      "id": "b7185a67-4bc6-4b45-a71a-c1de89231c0f",
      "name": "Knowledge Trigger",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  k.*,\n  n.value AS namespace,\n  ph.value AS pinecone_host,\n  (\n    SELECT json_agg(ku.url)\n    FROM knowledge_urls ku\n    WHERE ku.knowledge_id = k.id\n  ) AS urls,\n  (\n    SELECT json_agg(kf.directus_files_id)\n    FROM knowledge_files kf\n    WHERE kf.knowledge_id = k.id\n  ) AS files_id,\n  (\n    SELECT row_to_json(gv)\n    FROM global_vars gv\n    LIMIT 1\n  ) AS global_vars\nFROM knowledge k\nLEFT JOIN namespace n ON n.id = k.name_id\nLEFT JOIN pinecone_host ph ON ph.id = k.pinecone_host_id\nWHERE k.id = {{ $('Knowledge Trigger').first().json.payload.id }};\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1100,
        1860
      ],
      "id": "42909b41-9d9d-4e31-9968-b83ea887b063",
      "name": "Get Global Vars",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\n// Delay configurável\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Executa requisição GET com retry, usando parâmetros configuráveis.\nasync function axiosGetWithRetry(url, config, maxAttempts = 3, delayMs = 1000) {\n  let attempt = 1;\n  while (attempt <= maxAttempts) {\n    try {\n      return await axios.get(url, config);\n    } catch (err) {\n      console.error(`Tentativa ${attempt} para ${url} falhou:`, {\n        message: err.message,\n        status: err.response?.status,\n        data: err.response?.data,\n      });\n      if (attempt === maxAttempts) throw err;\n      attempt++;\n      await delay(delayMs);\n    }\n  }\n}\n\n// Prompt para gerar resumo de um bloco de texto\nconst SUMMARY_PROMPT = `Analise o texto a seguir e elabore um resumo conciso e direto, destacando os principais tópicos e informações essenciais. Esse resumo servirá de base para compor a descrição geral do documento.\n\nTexto:\n{conteudo}\n\nResumo:`;\n\n// Prompt para criar a descrição diretamente a partir do texto completo\nconst DIRECT_DESCRIPTION_PROMPT = `Analise o texto a seguir e crie uma descrição clara e objetiva do conteúdo geral do documento. A resposta deve ser um único parágrafo conciso de texto simples, sem formatação, com aproximadamente 300 caracteres.\n\nTexto:\n{conteudo}\n\nDescrição:`;\n\n// Prompt para gerar a descrição final a partir dos resumos\nconst FINAL_DESCRIPTION_PROMPT = `Com base nos resumos a seguir, elabore uma descrição clara e objetiva do conteúdo geral do documento. A resposta deve ser um único parágrafo conciso de texto simples, sem formatação, com aproximadamente 300 caracteres.\n\nResumos:\n{conteudo}\n\nDescrição:`;\n\n// Cria chunks de forma orgânica, sem misturar conteúdos de diferentes scrapings\nfunction createChunks(text, chunkLength, overlapPercentage) {\n  const overlapLength = Math.floor(chunkLength * (overlapPercentage / 100));\n  const chunks = [];\n  let currentPos = 0;\n  while (currentPos < text.length) {\n    let endPos = currentPos + chunkLength;\n    if (endPos >= text.length) {\n      endPos = text.length;\n    } else {\n      const searchStart = Math.max(currentPos, endPos - 100);\n      let breakPos = -1;\n      let pos = text.lastIndexOf(\"\\n\\n\", endPos);\n      if (pos >= searchStart) {\n        breakPos = pos + 2;\n      } else {\n        pos = text.lastIndexOf(\"\\n\", endPos);\n        if (pos >= searchStart) {\n          breakPos = pos + 1;\n        } else {\n          pos = text.lastIndexOf(\".\", endPos);\n          if (pos >= searchStart) {\n            breakPos = pos + 1;\n          } else {\n            pos = text.lastIndexOf(\"?\", endPos);\n            if (pos >= searchStart) {\n              breakPos = pos + 1;\n            } else {\n              pos = text.lastIndexOf(\"!\", endPos);\n              if (pos >= searchStart) {\n                breakPos = pos + 1;\n              }\n            }\n          }\n        }\n      }\n      if (breakPos > currentPos) {\n        endPos = breakPos;\n      }\n    }\n    const chunk = text.substring(currentPos, endPos).trim();\n    if (chunk.length > 0) chunks.push(chunk);\n    if (endPos === text.length) break;\n    currentPos = endPos - overlapLength;\n    if (currentPos < 0) currentPos = 0;\n  }\n  return chunks;\n}\n\n// Função para atualizar o campo \"description\" da tabela \"knowledge\" no Directus\nasync function updateDirectusDescription(newDescription, globalVars, globalId) {\n  const patchUrl = `http://${globalVars.directus_service}:8055/items/knowledge/${globalId}`;\n  const patchPayload = { description: newDescription };\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": `Bearer ${globalVars.directus_token}`\n  };\n  let attempts = 0;\n  while (attempts < 3) {\n    try {\n      const response = await axios.patch(patchUrl, patchPayload, { headers });\n      console.log(`Directus update successful: ${JSON.stringify(response.data)}`);\n      return response.data;\n    } catch (error) {\n      attempts++;\n      console.error(`Directus update attempt ${attempts} failed: ${error.message}`);\n      if (attempts < 3) {\n        await delay(1000);\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n\nasync function processScraping() {\n  // Extrai dados do nó Get Global Vars\n  const globalData = $('Get Global Vars').first().json;\n  const globalVars = globalData.global_vars;\n  const filesIds = Array.isArray(globalData.files_id) ? globalData.files_id : [];\n  const originalUrls = Array.isArray(globalData.urls) ? globalData.urls : [];\n  // Usa s3_url definido em global_vars\n  const host = globalVars.s3_url;\n  const directusToken = globalVars.directus_token;\n  const jinaToken = globalVars.jina_ai_token;\n  const openrouterKey = globalVars.openrouter_key;\n  const directusService = globalVars.directus_service;\n  const n8nWebhookService = globalVars.n8n_webhook_service;\n  const chunkLength = globalData.chunks_length || 2000; // fallback default\n  const overlapPercentage = globalData.overlap || 0;      // fallback default\n  \n  // Extrai o valor de Knowledge Trigger\n  const knowledgeTriggerId = $('Knowledge Trigger').first().json.payload.id;\n\n  // Processa arquivos para obter finalUrl com retry (se existirem)\n  const fileResults = await Promise.all(\n    filesIds.map(async (fileId) => {\n      try {\n        const response = await axiosGetWithRetry(\n          `http://${directusService}:8055/files/${fileId}`,\n          { headers: { Authorization: `Bearer ${directusToken}` } }\n        );\n        const filename_disk = response.data.data.filename_disk;\n        // Retira o \"s3\" pois já está incluso na URL\n        const finalUrl = `${host}/directus/${filename_disk}`;\n        return { type: 'file', fileId, url: finalUrl };\n      } catch (err) {\n        return {\n          type: 'file',\n          fileId,\n          error: err.message,\n          status: err.response?.status,\n          responseData: err.response?.data,\n        };\n      }\n    })\n  );\n\n  // Prepara URLs para scraping (se existirem)\n  const originalUrlsToScrape = originalUrls.map(url => ({ type: 'original', url }));\n  const allUrlsToScrape = [\n    ...fileResults.filter(item => item.url),\n    ...originalUrlsToScrape\n  ];\n\n  // Executa scraping com retry para cada URL (se houver)\n  const scrapeResults = await Promise.all(\n    allUrlsToScrape.map(async (item) => {\n      try {\n        const scrapingUrl = `https://r.jina.ai/${item.url}`;\n        const response = await axiosGetWithRetry(\n          scrapingUrl,\n          { headers: { Authorization: `Bearer ${jinaToken}` } }\n        );\n        return { ...item, scrapeData: response.data };\n      } catch (err) {\n        return {\n          ...item,\n          scrapeError: err.message,\n          status: err.response?.status,\n          errorData: err.response?.data,\n        };\n      }\n    })\n  );\n\n  // Agrega e limpa conteúdo dos scrapings para gerar chunks e descrição\n  const scrapedTexts = scrapeResults.map(item => item.scrapeData ? JSON.stringify(item.scrapeData) : '');\n  const aggregatedContent = scrapedTexts.join(' ');\n  const cleanedContent = aggregatedContent.replace(/[^a-zA-Z0-9\\s]/g, ' ');\n\n  // Gera chunks dos scrapings (mantendo conteúdo orgânico por scraping)\n  const chunks = [];\n  scrapeResults.forEach(item => {\n    if (item.scrapeData) {\n      const text = JSON.stringify(item.scrapeData);\n      const itemChunks = createChunks(text, chunkLength, overlapPercentage);\n      itemChunks.forEach(chunk => {\n        chunks.push({ chunk, source: item.url });\n      });\n    }\n  });\n\n  // Geração da descrição do conteúdo\n  const blockSize = 200000;\n  let finalDescription;\n  async function enviarPrompt(promptContent) {\n    const response = await axios.post(\n      'https://openrouter.ai/api/v1/chat/completions',\n      {\n        model: 'google/gemini-2.5-pro-preview-03-25',\n        messages: [{ role: 'user', content: promptContent }]\n      },\n      { headers: { Authorization: `Bearer ${openrouterKey}` } }\n    );\n    return response.data;\n  }\n  if (cleanedContent.length > blockSize) {\n    const blocks = [];\n    for (let i = 0; i < cleanedContent.length; i += blockSize) {\n      blocks.push(cleanedContent.substring(i, i + blockSize));\n    }\n    const summaries = await Promise.all(\n      blocks.map(async (block) => {\n        const prompt = `<dados>${block}</dados>\\n` + SUMMARY_PROMPT.replace('{conteudo}', block);\n        try {\n          const summaryResponse = await enviarPrompt(prompt);\n          return (summaryResponse.choices && summaryResponse.choices[0].message.content) || '';\n        } catch (err) {\n          return '';\n        }\n      })\n    );\n    const aggregatedSummaries = summaries.join(' ');\n    const descriptionPrompt = `<dados>${aggregatedSummaries}</dados>\\n` + FINAL_DESCRIPTION_PROMPT.replace('{conteudo}', aggregatedSummaries);\n    try {\n      const descriptionResponse = await enviarPrompt(descriptionPrompt);\n      finalDescription = descriptionResponse;\n    } catch (err) {\n      finalDescription = { error: err.message, status: err.response?.status, errorData: err.response?.data };\n    }\n  } else {\n    const directPrompt = `<dados>${cleanedContent}</dados>\\n` + DIRECT_DESCRIPTION_PROMPT.replace('{conteudo}', cleanedContent);\n    try {\n      const descriptionResponse = await enviarPrompt(directPrompt);\n      finalDescription = descriptionResponse;\n    } catch (err) {\n      finalDescription = { error: err.message, status: err.response?.status, errorData: err.response?.data };\n    }\n  }\n  \n  // Extrai somente o conteúdo da descrição, se disponível\n  if (finalDescription && finalDescription.choices && finalDescription.choices[0] && finalDescription.choices[0].message) {\n    finalDescription = finalDescription.choices[0].message.content;\n  }\n\n  // Atualiza o campo \"description\" na tabela \"knowledge\" no Directus\n  try {\n    const updateResponse = await updateDirectusDescription(finalDescription, globalVars, globalData.id);\n    console.log(\"Directus update response:\", updateResponse);\n  } catch (error) {\n    console.error(\"Falha ao atualizar o Directus após 3 tentativas:\", error.message);\n  }\n\n  // Geração dos vetores a partir dos chunks\n  for (const chunkItem of chunks) {\n    const vectorPromptBody = {\n      messages: [\n        {\n          role: \"user\",\n          content: `Você é um agente interno de um sistema especializado em extrair perguntas e respostas de documentos. Sua tarefa é analisar o chunk fornecido, que representa um segmento de um documento completo, e gerar perguntas e respostas baseadas nas informações contidas nele. \n\nContexto do documento: ${globalData.Instruction_Prompt}\n\nDiretrizes:\n1. Extraia informações relevantes (respostas) do chunk fornecido. Essas informações devem ser associadas a perguntas principais, mantendo sempre o tom e o estilo do texto original.\n2. Para cada resposta extraída:\n   - Crie uma pergunta principal (q) que tenha como resposta a informação extraída (a).\n   - Identifique o trecho específico do documento (t) de onde a resposta foi retirada.\n   - Formule perguntas alternativas (sq) que poderiam ser feitas para obter a mesma resposta (a).\n3. Sempre que encontrar múltiplas informações relevantes, crie múltiplas perguntas e respostas.\n4. Mantenha a originalidade e fidelidade ao conteúdo fornecido.\n\nChunk:\n${chunkItem.chunk}`\n        }\n      ],\n      response_format: {\n        type: \"json_schema\",\n        json_schema: {\n          name: \"extracted_data\",\n          strict: true,\n          schema: {\n            type: \"object\",\n            properties: {\n              results: {\n                type: \"array\",\n                items: {\n                  type: \"object\",\n                  properties: {\n                    a: { type: \"string\", description: \"A resposta ou informação extraída.\" },\n                    t: { type: \"string\", description: \"O trecho exato do documento de onde a resposta foi retirada.\" },\n                    q: { type: \"string\", description: \"A pergunta principal que leva à resposta.\" },\n                    sq: { type: \"array\", items: { type: \"string\" }, description: \"Perguntas alternativas que poderiam obter a mesma resposta.\" }\n                  },\n                  required: [\"a\", \"t\", \"q\", \"sq\"],\n                  additionalProperties: false\n                }\n              }\n            },\n            required: [\"results\"],\n            additionalProperties: false\n          }\n        }\n      }\n    };\n    try {\n      const vectorResponse = await axios.post(\n        'https://openrouter.ai/api/v1/chat/completions',\n        vectorPromptBody,\n        { headers: { Authorization: `Bearer ${openrouterKey}` } }\n      );\n      // Envia a resposta para o webhook incluindo global_vars, knowledge_trigger_id, pinecone_host e namespace\n      await axios.post(\n        `http://${n8nWebhookService}:5678/webhook/vector`,\n        {\n          ...vectorResponse.data,\n          global_vars: globalVars,\n          knowledge_trigger_id: knowledgeTriggerId,\n          pinecone_host: globalData.pinecone_host,\n          namespace: globalData.namespace\n        }\n      );\n    } catch (err) {\n      console.error('Erro ao gerar vetor para chunk:', err.message);\n    }\n    // Aguarda 10 segundos antes da próxima requisição\n    await delay(10000);\n  }\n\n  return { files: fileResults, scraping: scrapeResults, description: finalDescription, chunks };\n}\n\nreturn processScraping()\n  .then(result => [{ json: result }])\n  .catch(error => {\n    console.error('Erro geral:', { message: error.message, details: error });\n    return [{ json: { error: error.message, details: error } }];\n  });"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -900,
        1860
      ],
      "id": "c2119d41-b433-48e6-9ebf-8a8e3b14dc0e",
      "name": "Process Docs"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "vector",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -580,
        1860
      ],
      "id": "9409bd76-0209-4faf-b1c6-8366498d25f4",
      "name": "Vector Trigger",
      "webhookId": "31a23ccc-c8b7-4a93-980c-783c0490d567"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $('Vector Trigger').first().json.body.global_vars.openai_key }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "input",
              "value": "={{ `Context: ${$('Split Vectors').item.json.t} Question: ${$('Split Vectors').item.json.q} Answer: ${$('Split Vectors').item.json.a} Similar Questions: ${$('Split Vectors').item.json.sq.join(\", \")}` }}"
            },
            {
              "name": "model",
              "value": "text-embedding-3-small"
            },
            {
              "name": "dimensions",
              "value": "={{ 1536 }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        20,
        1860
      ],
      "id": "495d7b40-b13f-433f-84cf-f7b455df6cdf",
      "name": "Embeddings",
      "notesInFlow": true
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={{ $json.body.choices[0].message.content.parseJson() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -380,
        1860
      ],
      "id": "2ceeb8fc-b92f-40e2-8c70-e114a08fcbd1",
      "name": "Parse JSON 2"
    },
    {
      "parameters": {
        "fieldToSplitOut": "results",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -180,
        1860
      ],
      "id": "3c0916ed-56a7-4e32-9e9c-3e0b71c9ef09",
      "name": "Split Vectors"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH new_vector AS (\n  INSERT INTO vectors \n    (id, date_created, question, answer, context, similar_questions, knowledge_id)\n  VALUES \n    (\n      uuid_generate_v4(), \n      NOW(), \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].q }} $$, \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].a }} $$, \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].t }} $$, \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].sq.join(',') }} $$, \n      {{ $('Vector Trigger').item.json.body.knowledge_trigger_id }}\n    )\n  RETURNING id AS vector_id\n),\nnew_dimension AS (\n  INSERT INTO dimensions (values, date_created, vector_id)\n  SELECT $$ {{ $('Embeddings').item.json.data[0].embedding.join(',') }} $$, NOW(), vector_id\n  FROM new_vector\n  RETURNING vector_id\n)\nINSERT INTO vectors_status (vector_id, value)\nSELECT vector_id, '#2ECDA7'\nFROM new_vector\nRETURNING vector_id;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        220,
        1860
      ],
      "id": "4bbeb6e1-2bb9-455f-9383-4852ee74b9f9",
      "name": "Add Vectors",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rag",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1300,
        2180
      ],
      "id": "e564df0d-aad6-40d2-8d7a-018d6c709550",
      "name": "RAG Input",
      "webhookId": "d503e6f9-0989-42d5-a598-e268b20c3182"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Por favor, analise a entrada do usuário e o histórico recente. \n\nEntrada do usuário: \n<user_input>{{ $('RAG Input').first().json.body.content }}</user_input>\n\nHistórico das últimas 10 mensagens: \n<conversation_history>{{ $('Get History').first().json.chat_histories.map(item => item.message).slice(-10).toJsonString() }}</conversation_history>",
        "options": {
          "systemMessage": "=Você é um agente especializado em realizar buscas no banco vetorial para fornecer contexto adicional à inteligência artificial principal.\n\nObjetivo:\nAnalisar a entrada do usuário e o histórico recente de mensagens para decidir se deve invocar a tool 'retriever' e, caso necessário, realizar buscas eficientes.\n\nDiretrizes:\nBusca desnecessária: Se a entrada do usuário não contiver perguntas relevantes ou específicas (ex.: saudações, mensagens genéricas ou irrelevantes), retorne: \"Busca desnecessária.\"\nNenhuma informação encontrada: Se, ao usar a tool 'retriever', nenhuma informação relevante for encontrada, retorne: \"Nenhuma informação relevante encontrada.\"\nForneça respostas precisas: Se encontrar informações no banco vetorial, forneça apenas o conteúdo necessário para responder à solicitação do usuário, de forma objetiva e sem interpretações adicionais.\nRegras para invocar a tool 'retriever':\nAnalise cuidadosamente a entrada do usuário e as descrições dos conhecimentos disponíveis para identificar qualquer possibilidade de relação com os temas abordados nos conhecimentos.\nConsidere como relevante qualquer pergunta do usuário que possa estar relacionada aos documentos descritos nos conhecimentos disponíveis. Se houver uma chance de associação, a busca deve ser realizada.\nUse as descrições dos conhecimentos disponíveis para identificar o knowledge_id mais adequado:\n\n<knowledge_metadata>{{ $('Get History').first().json.knowledge.map(item => ({ knowledge_id: item.id, description: item.description })).toJsonString() }}</knowledge_metadata>\n\nUse múltiplas queries, se necessário: Se a solicitação do usuário for ampla ou ambígua, faça buscas utilizando palavras-chave diferentes para cobrir todas as possibilidades.\nCombine os resultados de forma precisa e concisa, retornando apenas o contexto essencial à AI principal.\nInstruções adicionais:\nSe houver qualquer relação potencial entre a solicitação do usuário e os conhecimentos disponíveis, realize a busca imediatamente.\nAo invocar a tool 'retriever', faça perguntas claras e precisas, alinhadas ao contexto da entrada do usuário e aos temas descritos nos conhecimentos disponíveis.\nO foco é fornecer contexto relevante e direto para a AI principal.",
          "passthroughBinaryImages": true
        }
      },
      "id": "a2ded5bf-177d-4a12-89b4-b8eab7ca769c",
      "name": "RAG Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        -900,
        2180
      ],
      "retryOnFail": false,
      "executeOnce": false
    },
    {
      "parameters": {
        "name": "retriever",
        "description": "=Invoque essa tool para buscar informações no banco vetorial e fornecer respostas relevantes com base nos conhecimentos disponíveis. Use-a somente quando necessário para complementar o contexto.",
        "jsCode": "const axios = require('axios');\n\nasync function runTool() {\n  let logs = \"\";\n  \n  try {\n    // Obter parâmetros de entrada\n    logs += \"Obtendo parâmetros de entrada...\\n\";\n    const searchQuery = query.query;\n    const knowledgeId = query.knowledge_id;\n    logs += `searchQuery: ${searchQuery}\\nknowledgeId: ${knowledgeId}\\n`;\n    \n    // Obter mapping a partir do nó \"RAG Input\"\n    let mappingInput = $('RAG Input').first().json.body.mapping;\n    if (typeof mappingInput === 'string') {\n      try {\n        mappingInput = JSON.parse(mappingInput);\n        logs += \"Mapping Input convertido de string para objeto.\\n\";\n      } catch (e) {\n        throw new Error(\"Falha ao converter mapping para objeto.\");\n      }\n    }\n    logs += \"Mapping Input obtido.\\n\";\n    \n    if (!mappingInput.system) {\n      throw new Error(\"mappingInput.system está indefinido.\");\n    }\n    \n    // Gerar embeddings usando a API do OpenAI\n    logs += \"Chamando endpoint de embeddings da OpenAI...\\n\";\n    const openaiKey = mappingInput.system.openai_key;\n    const embeddingResponse = await axios.post(\n      'https://api.openai.com/v1/embeddings',\n      {\n        input: searchQuery,\n        model: \"text-embedding-3-small\"\n      },\n      {\n        headers: {\n          \"Authorization\": `Bearer ${openaiKey}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    logs += \"Embeddings obtidos com sucesso.\\n\";\n    const embedding = embeddingResponse.data.data[0].embedding;\n    logs += `Embedding (primeiros 5 valores): ${embedding.slice(0,5).join(\", \")}...\\n`;\n    \n    // Obter pinecone_host e namespace do histórico\n    logs += \"Obtendo pinecone_host e namespace a partir do histórico...\\n\";\n    const historyKnowledge = $('Get History').first().json.knowledge;\n    const knowledgeItem = historyKnowledge.find(item => item.id === knowledgeId);\n    if (!knowledgeItem) {\n      throw new Error(`Conhecimento com id ${knowledgeId} não encontrado.`);\n    }\n    const pineconeHostRaw = knowledgeItem.pinecone_host;\n    const namespace = knowledgeItem.namespace;\n    logs += `pineconeHostRaw: ${pineconeHostRaw}, namespace: ${namespace}\\n`;\n    \n    // Garantir que pinecone_host comece com \"https://\"\n    let pineconeHost = pineconeHostRaw;\n    if (!pineconeHost.startsWith(\"https://\")) {\n      pineconeHost = \"https://\" + pineconeHost;\n    }\n    logs += `pineconeHost final: ${pineconeHost}\\n`;\n    \n    // Requisição para a API do Pinecone\n    logs += \"Chamando API do Pinecone...\\n\";\n    const pineconeKey = mappingInput.system.pinecone_key;\n    const pineconeQueryUrl = `${pineconeHost}/query`;\n    const pineconeResponse = await axios.post(\n      pineconeQueryUrl,\n      {\n        namespace: namespace,\n        vector: embedding,\n        topK: 3,\n        includeValues: false,\n        includeMetadata: true\n      },\n      {\n        headers: {\n          \"Api-Key\": pineconeKey,\n          \"X-Pinecone-API-Version\": \"2024-10\",\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    logs += \"Resposta do Pinecone obtida com sucesso.\\n\";\n    logs += `Pinecone response data: ${JSON.stringify(pineconeResponse.data)}\\n`;\n    \n    // Processar os resultados do Pinecone usando as chaves corretas dos metadados (\"a\", \"q\" e \"t\")\n    const matches = pineconeResponse.data.matches;\n    matches.forEach((m, idx) => {\n      logs += `Match ${idx + 1}: id=${m.id}, score=${m.score}, metadata=${JSON.stringify(m.metadata)}\\n`;\n    });\n    \n    const filteredMatches = matches.filter(item => item.score >= 0.0)\n      .map(item => ({\n        vector: item.id,\n        score: item.score,\n        answer: item.metadata ? item.metadata.a : null,\n        question: item.metadata ? item.metadata.q : null,\n        context: item.metadata ? item.metadata.t : null\n      }));\n    logs += `Matches filtrados: ${JSON.stringify(filteredMatches)}\\n`;\n    \n    const resultString = `Os vetores retornados foram: ${JSON.stringify(filteredMatches)}`;\n    logs += \"Processamento final concluído.\\n\";\n    \n    console.log(\"Logs:\", logs);\n    // Retorna apenas o resultado final (string) sem os logs.\n    return resultString;\n  } catch (error) {\n    logs += `Erro: ${error.message}\\n`;\n    console.error(\"Erro:\", error.message, \"Logs:\", logs);\n    return `Erro: ${error.message}`;\n  }\n}\n\nreturn runTool();\n",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"knowledge_id\": {\n      \"type\": \"integer\",\n      \"description\": \"O ID do conhecimento específico no qual a busca será realizada.\"\n    },\n    \"query\": {\n      \"type\": \"string\",\n      \"description\": \"A pergunta ou consulta que será usada para realizar a busca no banco vetorial.\"\n    }\n  }\n}"
      },
      "id": "41fc08f8-545b-4630-aa13-8ec4b7b26c85",
      "name": "Retriever",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        -600,
        2460
      ]
    },
    {
      "parameters": {
        "content": "",
        "height": 660,
        "width": 1860,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1420,
        1740
      ],
      "typeVersion": 1,
      "id": "8cca0dfb-74e9-479b-85a4-daeb7626a164",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1100,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1400,
        2080
      ],
      "id": "be558bf9-3986-490d-97da-afe857ba3cd7",
      "name": "Sticky Note9"
    },
    {
      "parameters": {
        "content": "",
        "width": 300,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -780,
        2420
      ],
      "typeVersion": 1,
      "id": "bb80c8c5-a160-46fa-a53f-c0fbe1e83fe7",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "model": "={{ $('RAG Input').item.json.body.mapping.parseJson().system.model }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -720,
        2460
      ],
      "id": "d2ffb844-73bd-434b-82f3-a24f1961c2b0",
      "name": "OpenRouter ",
      "credentials": {
        "openRouterApi": {
          "id": "fbVI3oy00ZqZFPfH",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 700,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1400,
        1760
      ],
      "id": "b1c86e44-32d6-4db3-aea5-094e05d0e47f",
      "name": "Sticky Note10"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1100,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -680,
        1760
      ],
      "id": "1bfd9788-7df8-4dcb-aa39-e3d9e3c3bc3b",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"chatwoot\": {\n    \"account_id\": {{ $('Consumer').first().json.body.account.id }},\n    \"contact_id\": {{ $('Consumer').first().json.body.conversation.contact_inbox.contact_id }},\n\n    \"conversation_id\": {{ $('Consumer').first().json.body.conversation.messages[0].conversation_id }},\n    \"sender_type\": {{ JSON.stringify($('Consumer').first().json.body.conversation.messages[0].sender_type) }},\n    \"bot_token\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.bot_token) }},\n    \"conversation_status\": {{ JSON.stringify($json.current_status) }},\n    \"assignee\": {{ JSON.stringify($('Consumer').first().json.body.conversation?.meta?.assignee?.name || null ) }},\n    \n    \"content\": {{ JSON.stringify(\n      ($('Consumer').first().json.body?.content || '')\n        .replace(\n          /^\\*\\*(.*?)\\*\\*\\n\\n/,\n          $('Consumer').first().json.body.sender.identifier?.match(/@g\\.us$/) ? '' : '$&'\n        )\n        .replace(\n          new RegExp('@' + ($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, ''), 'g'),\n          '@YOU'\n        )\n        .trim()\n    ) }},\n    \n    \"data_url\": {{ JSON.stringify(\n        $('Consumer').first().json.body.conversation.messages?.[0]?.attachments?.[0]?.data_url || null\n      )\n    }},\n    \n    \"message_id\": {{ $('Consumer').first().json.body.id }},\n    \n    \"channel\": {{\n      JSON.stringify(\n        $('Consumer').first().json.body.conversation.channel === 'Channel::Api' \n        ? (\n            /@s\\.whatsapp\\.net$/.test($('Consumer').first().json.body.sender.identifier) \n            ? 'WhatsApp Web' \n            : /@g\\.us$/.test($('Consumer').first().json.body.sender.identifier) \n            ? 'WhatsApp Web Group' \n            : $('Consumer').first().json.body.conversation.channel.replace('Channel::', '')\n          ) \n        : $('Consumer').first().json.body.conversation.channel.replace('Channel::', '')\n      )\n    }},\n    \n    \"user_name\": {{ JSON.stringify(\n      $('Consumer').first().json.body.sender.identifier?.match(/@g\\.us$/)\n        ? (\n            $('Consumer').first().json.body?.content?.match(/^\\*\\*(.*?)\\*\\*/)?.[1] || ''\n          )\n        : $('Consumer').first().json.body.sender?.name || ''\n    ) }},\n\n    \"phone_number\": {{ JSON.stringify($('Consumer').first().json.body.sender.phone_number) || null }},\n\n    \"events\": {{ JSON.stringify($('Get Vars').first().json.events) }}\n  },\n  \n  \"system\": {\n    \"cooldown\": {{ $('Get Vars').first().json.ai_agents.cooldown }},\n    \"workflow_path\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.workflow_path) }},\n    \"model\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.model) }},\n    \"openai_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.openai_key) }},\n    \"directus_token\": {{ JSON.stringify($('Get Vars').first().json.global_vars.directus_token) }},\n    \"stirling_pdf_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.stirling_pdf_key) }},\n    \"elevenlabs_key\": \"{{ $('Get Vars').first().json.global_vars.elevenlabs_key }}\",\n    \"conversations_id\": {{ JSON.stringify($('Get Vars').first().json.conversations.id) }},\n    \"context_window\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.context_window) }},\n    \"enabled_condition\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.enabled_condition) }},\n    \"allow_whatsapp_groups\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.allow_whatsapp_groups) }},\n    \"allow_human_interruption\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.allow_human_interruption) }},\n    \"agent_phone_number\": {{ JSON.stringify(($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, '')) }},\n    \"agent_mentioned\": {{ JSON.stringify(($('Consumer').first().json.body?.content || '' ).includes('@' + ($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, ''))) }},\n    \"agent_name\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.name) }},\n    \"system_message\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.system_message) }},\n    \"user_type\": {{ JSON.stringify($('Get Vars').first().json.users.type) }},\n    \"output_format\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.output_format) }},\n    \"elevenlabs_model\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.elevenlabs_model) }},\n    \"elevenlabs_voice\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.elevenlabs_voice) }},\n    \"chatwoot_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.chatwoot_service) }},\n    \"n8n_webhook_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.n8n_webhook_service) }},\n    \"stirling_pdf_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.stirling_pdf_service) }},\n    \"directus_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.directus_service) }},\n    \"enabled_rag\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.enabled_rag) }},\n    \"ai_agent_id\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.id) }},\n    \"pinecone_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.pinecone_key) }},\n    \"downtime\": {{ new Date(\"1970-01-01T\" + $('Get Vars').first().json.ai_agents.downtime + \"Z\").getTime() / 1000 }},\n    \"clientId\": {{ JSON.stringify($('Get Vars').first().json.global_vars.clientId) }},\n    \"clientSecret\": {{ JSON.stringify($('Get Vars').first().json.global_vars.clientSecret) }},\n    \"refreshToken\": {{ JSON.stringify($('Get Vars').first().json.global_vars.refreshToken) }},\n    \"accessToken\": {{ JSON.stringify($('Get Vars').first().json.global_vars.accessToken) }},\n    \"core_chat_histories\": {{ JSON.stringify($('Get Vars').item.json.core_chat_histories, null, 2) }}\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -700,
        580
      ],
      "id": "cc1cc3ea-47e2-439b-9960-b775136dd90b",
      "name": "Mapping"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        300,
        1100
      ],
      "id": "1391b948-718b-45b7-a5aa-29bc0d8c009f",
      "name": "No Operation "
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\nasync function runTool() {\n  const logArray = [];\n  let currentStatus = \"\";\n  \n  try {\n    console.log(\"Obtendo data de última interação e downtime...\");\n    logArray.push(\"Obtendo data de última interação e downtime...\");\n    \n    const dateUpdatedStr = $('Get Vars').first().json.users.date_updated;\n    const downtimeStr = $('Get Vars').first().json.ai_agents.downtime;\n    console.log(`date_updated: ${dateUpdatedStr}`);\n    console.log(`downtime: ${downtimeStr}`);\n    logArray.push(`date_updated: ${dateUpdatedStr}`);\n    logArray.push(`downtime: ${downtimeStr}`);\n    \n    // Se downtime for \"00:00:00\", considere desativado e não realizar a requisição.\n    if (downtimeStr === \"00:00:00\") {\n      console.log(\"Downtime é 00:00:00. Nenhuma ação será realizada.\");\n      logArray.push(\"Downtime é 00:00:00. Nenhuma ação será realizada.\");\n      currentStatus = $('Consumer').first().json.body.conversation.status;\n      return [{ json: { current_status: currentStatus, logs: logArray } }];\n    }\n    \n    const lastUpdated = new Date(dateUpdatedStr);\n    const now = new Date();\n    const diffMs = now - lastUpdated;\n    const diffMinutes = (diffMs / 60000).toFixed(2);\n    \n    // Converter downtime (HH:MM:SS) para milissegundos e para minutos\n    const [hours, minutes, seconds] = downtimeStr.split(':').map(Number);\n    const downtimeMs = ((hours * 3600) + (minutes * 60) + seconds) * 1000;\n    const downtimeMinutes = (downtimeMs / 60000).toFixed(2);\n    \n    console.log(`diff: ${diffMinutes} minutes, downtime: ${downtimeMinutes} minutes`);\n    logArray.push(`diff: ${diffMinutes} minutes, downtime: ${downtimeMinutes} minutes`);\n    \n    // Obter conversation status e conversation_id do nó Consumer\n    const conversationStatus = $('Consumer').first().json.body.conversation.status;\n    const convId = $('Consumer').first().json.body.conversation.messages[0].conversation_id;\n    console.log(`conversation status: ${conversationStatus}`);\n    console.log(`conversation_id: ${convId}`);\n    logArray.push(`conversation status: ${conversationStatus}`);\n    logArray.push(`conversation_id: ${convId}`);\n    \n    // Inicialmente, currentStatus recebe o status atual\n    currentStatus = conversationStatus;\n    \n    // Verifica se o tempo de inatividade foi excedido e se conversation.status é diferente de \"pending\"\n    if (diffMs >= downtimeMs && conversationStatus !== \"pending\") {\n      console.log(\"Condições atendidas: tempo de inatividade excedido e conversation.status não é 'pending'.\");\n      logArray.push(\"Condições atendidas: tempo de inatividade excedido e conversation.status não é 'pending'. Tentando abrir conversa no Chatwoot...\");\n      \n      const chatwootService = $('Get Vars').first().json.global_vars.chatwoot_service;\n      const accountId = $('Consumer').first().json.body.account.id;\n      const conversationId = convId;\n      const botToken = $('Get Vars').first().json.ai_agents.bot_token;\n      \n      const toggleUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/toggle_status`;\n      console.log(`Toggle URL: ${toggleUrl}`);\n      logArray.push(`Toggle URL: ${toggleUrl}`);\n      \n      try {\n        const response = await axios.post(\n          toggleUrl,\n          { status: \"pending\" },\n          { headers: { api_access_token: botToken } }\n        );\n        console.log(\"Conversa aberta com sucesso no Chatwoot.\");\n        logArray.push(\"Conversa aberta com sucesso no Chatwoot.\");\n        currentStatus = \"pending\";\n      } catch (err) {\n        console.error(\"Erro ao abrir conversa:\", err.message);\n        logArray.push(`Erro ao abrir conversa: ${err.message}`);\n      }\n    } else {\n      console.log(\"Condições não atendidas: tempo de inatividade não excedido ou conversation.status é 'pending'. Nenhuma ação realizada.\");\n      logArray.push(\"Condições não atendidas: tempo de inatividade não excedido ou conversation.status é 'pending'. Nenhuma ação realizada.\");\n    }\n    \n    return [{ json: { current_status: currentStatus, logs: logArray } }];\n  } catch (error) {\n    console.error(\"Erro geral:\", error.message);\n    logArray.push(`Erro geral: ${error.message}`);\n    return [{ json: { error: error.message, current_status: currentStatus, logs: logArray } }];\n  }\n}\n\nreturn runTool();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -900,
        580
      ],
      "id": "9990a106-8f3e-402f-8a23-6af38a90cf44",
      "name": "Downtime",
      "alwaysOutputData": false
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -100,
        1300
      ],
      "id": "8508753a-1eb9-4d07-9fc3-a171ba5a866f",
      "name": "No Operation 0"
    },
    {
      "parameters": {
        "triggerMode": "listenTrigger",
        "channelName": "specific_channel",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTrigger",
      "typeVersion": 1,
      "position": [
        -180,
        2180
      ],
      "id": "14a66f3e-937f-4bfc-9c10-4772492baffb",
      "name": "Postgres Trigger",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "async function main() {\n  // Função auxiliar para limitar o tamanho dos logs\n  const trimLog = (msg, limit = 100) =>\n    (typeof msg === 'string' && msg.length > limit ? msg.substring(0, limit) + '...' : msg);\n\n  // Array para armazenar os logs de debug\n  let logs = [];\n\n  try {\n    // Obtém o payload do nó \"Postgres Trigger\"\n    const payload = $('Postgres Trigger').first().json.payload;\n    logs.push(\"Payload carregado.\");\n    console.log(\"Payload:\", trimLog(JSON.stringify(payload)));\n\n    // Determina a operação\n    const op = payload.operation;\n    logs.push(\"Operação: \" + op);\n    console.log(\"Operação:\", op);\n\n    // Garante que pinecone_host comece com \"https://\"\n    let pineconeHost = payload.data.pinecone_host;\n    if (!pineconeHost.startsWith(\"https://\")) {\n      pineconeHost = \"https://\" + pineconeHost;\n      logs.push(\"Prefixo 'https://' adicionado.\");\n      console.log(\"pinecone_host modificado:\", pineconeHost);\n    }\n\n    // Configura os headers para o Pinecone\n    const pineconeHeaders = {\n      \"Api-Key\": payload.global_vars.pinecone_key,\n      \"X-Pinecone-API-Version\": \"2024-10\",\n      \"Content-Type\": \"application/json\"\n    };\n    logs.push(\"Headers Pinecone configurados.\");\n    console.log(\"Headers Pinecone:\", pineconeHeaders);\n\n    let endpoint, options, response, mainResponse;\n\n    // Branch para deleção: DISABLED ou DELETE\n    if (op === \"DISABLED\" || op === \"DELETE\") {\n      endpoint = pineconeHost + \"/vectors/delete\";\n      logs.push(\"Endpoint para deleção: \" + endpoint);\n      console.log(\"Endpoint de deleção:\", endpoint);\n\n      const deleteBody = {\n        ids: [payload.data.id],\n        namespace: payload.data.namespace\n      };\n      logs.push(\"Body para deleção: \" + trimLog(JSON.stringify(deleteBody)));\n      console.log(\"Body de deleção:\", deleteBody);\n\n      options = {\n        method: \"POST\",\n        uri: endpoint,\n        headers: pineconeHeaders,\n        body: deleteBody,\n        json: true\n      };\n\n      response = await this.helpers.request(options);\n      logs.push(\"Resposta da deleção recebida.\");\n      console.log(\"Resposta da deleção:\", trimLog(JSON.stringify(response)));\n\n      mainResponse = response;\n\n    // Branch para upsert via OpenAI (para UPDATE ou INSERT com enabled true)\n    } else if ((op === \"UPDATE\" || op === \"INSERT\") && payload.data.enabled === true) {\n      let embedding; // Para o upsert no Pinecone\n\n      // Se for INSERT, verifica se já existe embedding em Directus (tabela dimensions)\n      if (op === \"INSERT\") {\n        const directusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\n        const directusEndpoint = directusHost + \"/items/dimensions\";\n        const directusHeaders = {\n          \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n          \"Content-Type\": \"application/json\"\n        };\n        logs.push(\"Consultando Directus (dimensions) para vector_id: \" + payload.data.id);\n        console.log(\"Directus endpoint (dimensions):\", directusEndpoint);\n\n        const directusQueryOptions = {\n          method: \"GET\",\n          uri: directusEndpoint,\n          qs: { \"filter[vector_id][_eq]\": payload.data.id },\n          headers: directusHeaders,\n          json: true\n        };\n\n        let directusRecord = await this.helpers.request(directusQueryOptions);\n        logs.push(\"Resposta Directus (dimensions): \" + trimLog(JSON.stringify(directusRecord)));\n        console.log(\"Directus GET response (dimensions):\", trimLog(JSON.stringify(directusRecord)));\n\n        if (\n          directusRecord &&\n          directusRecord.data &&\n          directusRecord.data.length > 0 &&\n          directusRecord.data[0].values\n        ) {\n          let directusValues = directusRecord.data[0].values;\n          // Se for string, converte para array de floats; se já for array, utiliza diretamente.\n          if (typeof directusValues === \"string\") {\n            embedding = directusValues.split(\",\").map(item => parseFloat(item.trim()));\n          } else if (Array.isArray(directusValues)) {\n            embedding = directusValues;\n          }\n          logs.push(\"Embedding reutilizado do Directus (dimensions).\");\n          console.log(\"Embedding reutilizado:\", trimLog(JSON.stringify(embedding)));\n        }\n      }\n\n      // Se embedding não foi obtido (ou para UPDATE), gere via OpenAI\n      if (!embedding) {\n        const openAIEndpoint = \"https://api.openai.com/v1/embeddings\";\n        const openAIHeaders = {\n          \"Authorization\": \"Bearer \" + payload.global_vars.openai_key,\n          \"Content-Type\": \"application/json\"\n        };\n        logs.push(\"Endpoint OpenAI: \" + openAIEndpoint);\n        console.log(\"Endpoint OpenAI:\", openAIEndpoint);\n        logs.push(\"Headers OpenAI configurados.\");\n        console.log(\"Headers OpenAI:\", openAIHeaders);\n\n        // Constrói o input para OpenAI (adiciona espaço após cada vírgula em similar_questions)\n        const similarQuestionsInput = payload.data.similar_questions\n          ? payload.data.similar_questions.replace(/,/g, ', ')\n          : \"\";\n        const openAIInput = `Context: ${payload.data.context} Question: ${payload.data.question} Answer: ${payload.data.answer} Similar Questions: ${similarQuestionsInput}`;\n        logs.push(\"Input para OpenAI: \" + trimLog(openAIInput));\n        console.log(\"Input OpenAI:\", openAIInput);\n\n        const openAIBody = {\n          input: openAIInput,\n          model: \"text-embedding-3-small\",\n          dimensions: 1536\n        };\n        logs.push(\"Body para OpenAI: \" + trimLog(JSON.stringify(openAIBody)));\n        console.log(\"Body OpenAI:\", openAIBody);\n\n        options = {\n          method: \"POST\",\n          uri: openAIEndpoint,\n          headers: openAIHeaders,\n          body: openAIBody,\n          json: true\n        };\n\n        let openAIResponse = await this.helpers.request(options);\n        logs.push(\"Resposta do OpenAI recebida.\");\n        console.log(\"Resposta OpenAI:\", trimLog(JSON.stringify(openAIResponse)));\n\n        if (openAIResponse && openAIResponse.data && openAIResponse.data.length > 0) {\n          embedding = openAIResponse.data[0].embedding;\n          logs.push(\"Embedding extraído do OpenAI.\");\n          console.log(\"Embedding:\", trimLog(JSON.stringify(embedding)));\n        } else {\n          throw new Error(\"Embedding não retornado pelo OpenAI.\");\n        }\n      }\n\n      // Converte similar_questions CSV para array\n      let similarQuestionsArray = [];\n      if (payload.data.similar_questions) {\n        similarQuestionsArray = payload.data.similar_questions.split(\",\").map(s => s.trim());\n      }\n      logs.push(\"similar_questions convertido para array: \" + trimLog(JSON.stringify(similarQuestionsArray)));\n      console.log(\"similar_questions array:\", similarQuestionsArray);\n\n      // Upsert no Pinecone usando o embedding obtido\n      endpoint = pineconeHost + \"/vectors/upsert\";\n      logs.push(\"Endpoint para upsert (Pinecone): \" + endpoint);\n      console.log(\"Endpoint de upsert:\", endpoint);\n\n      const upsertBody = {\n        vectors: [\n          {\n            id: payload.data.id,\n            values: embedding, // embedding é um array de floats\n            metadata: {\n              a: payload.data.answer,\n              t: payload.data.context,\n              q: payload.data.question,\n              sq: similarQuestionsArray\n            }\n          }\n        ],\n        namespace: payload.data.namespace\n      };\n      logs.push(\"Body para upsert (Pinecone): \" + trimLog(JSON.stringify(upsertBody)));\n      console.log(\"Body de upsert:\", upsertBody);\n\n      options = {\n        method: \"POST\",\n        uri: endpoint,\n        headers: pineconeHeaders,\n        body: upsertBody,\n        json: true\n      };\n\n      response = await this.helpers.request(options);\n      logs.push(\"Resposta do upsert Pinecone recebida.\");\n      console.log(\"Resposta do upsert:\", trimLog(JSON.stringify(response)));\n\n      mainResponse = response;\n\n      // Atualiza ou cria o registro na tabela dimensions do Directus (como já estava implementado)\n      const directusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\n      const directusDimensionsEndpoint = directusHost + \"/items/dimensions\";\n      const directusHeaders = {\n        \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n        \"Content-Type\": \"application/json\"\n      };\n      logs.push(\"Directus dimensions endpoint: \" + directusDimensionsEndpoint);\n      console.log(\"Directus dimensions endpoint:\", directusDimensionsEndpoint);\n\n      const directusQueryOptions = {\n        method: \"GET\",\n        uri: directusDimensionsEndpoint,\n        qs: { \"filter[vector_id][_eq]\": payload.data.id },\n        headers: directusHeaders,\n        json: true\n      };\n\n      let directusRecord = await this.helpers.request(directusQueryOptions);\n      logs.push(\"Resposta Directus (dimensions): \" + trimLog(JSON.stringify(directusRecord)));\n      console.log(\"Directus GET response (dimensions):\", trimLog(JSON.stringify(directusRecord)));\n\n      const currentTimestamp = new Date().toISOString();\n      // Converte o embedding para string sem colchetes\n      const directusValues = Array.isArray(embedding) ? embedding.join(\",\") : embedding;\n      const dimensionsBody = {\n        values: directusValues,\n        vector_id: payload.data.id,\n        date_created: currentTimestamp,\n        date_updated: currentTimestamp\n      };\n\n      if (directusRecord && directusRecord.data && directusRecord.data.length > 0) {\n        const recordId = directusRecord.data[0].id;\n        const directusUpdateEndpoint = directusDimensionsEndpoint + \"/\" + recordId;\n        logs.push(\"Atualizando registro dimensions Directus com id: \" + recordId);\n        console.log(\"Atualizando Directus dimensions em:\", directusUpdateEndpoint);\n\n        const directusUpdateOptions = {\n          method: \"PATCH\",\n          uri: directusUpdateEndpoint,\n          headers: directusHeaders,\n          body: dimensionsBody,\n          json: true\n        };\n\n        const directusUpdateResponse = await this.helpers.request(directusUpdateOptions);\n        logs.push(\"Resposta atualização Directus dimensions: \" + trimLog(JSON.stringify(directusUpdateResponse)));\n        console.log(\"Directus dimensions update response:\", trimLog(JSON.stringify(directusUpdateResponse)));\n      } else {\n        logs.push(\"Nenhum registro Dimensions Directus encontrado, criando novo.\");\n        console.log(\"Criando novo registro Dimensions Directus.\");\n\n        const directusCreateOptions = {\n          method: \"POST\",\n          uri: directusDimensionsEndpoint,\n          headers: directusHeaders,\n          body: dimensionsBody,\n          json: true\n        };\n\n        const directusCreateResponse = await this.helpers.request(directusCreateOptions);\n        logs.push(\"Resposta criação Directus dimensions: \" + trimLog(JSON.stringify(directusCreateResponse)));\n        console.log(\"Directus dimensions create response:\", trimLog(JSON.stringify(directusCreateResponse)));\n      }\n\n    // Branch para upsert usando valores do \"Get Dimensions\" (caso op seja ENABLED)\n    } else if (op === \"ENABLED\") {\n      endpoint = pineconeHost + \"/vectors/upsert\";\n      logs.push(\"Endpoint para upsert (Get Dimensions): \" + endpoint);\n      console.log(\"Endpoint de upsert:\", endpoint);\n\n      let similarQuestionsArray = [];\n      if (payload.data.similar_questions) {\n        similarQuestionsArray = payload.data.similar_questions.split(\",\").map(s => s.trim());\n      }\n      logs.push(\"similar_questions convertido para array: \" + trimLog(JSON.stringify(similarQuestionsArray)));\n      console.log(\"similar_questions array:\", similarQuestionsArray);\n\n      let values = $('Get Dimensions').first().json.values;\n      if (typeof values === \"string\") {\n        values = values.split(\",\").map(item => parseFloat(item.trim()));\n        logs.push(\"Valores convertidos de string para array: \" + trimLog(JSON.stringify(values)));\n        console.log(\"Valores convertidos:\", values);\n      } else if (Array.isArray(values)) {\n        if (values.length > 0 && typeof values[0] === \"string\") {\n          values = values.map(item => parseFloat(item.trim()));\n          logs.push(\"Valores convertidos de array de strings para floats: \" + trimLog(JSON.stringify(values)));\n          console.log(\"Valores convertidos:\", values);\n        }\n      } else {\n        values = [values];\n        logs.push(\"Valores encapsulados em array: \" + trimLog(JSON.stringify(values)));\n        console.log(\"Valores encapsulados:\", values);\n      }\n\n      const upsertBody = {\n        vectors: [\n          {\n            id: payload.data.id,\n            values: values,\n            metadata: {\n              a: payload.data.answer,\n              t: payload.data.context,\n              q: payload.data.question,\n              sq: similarQuestionsArray\n            }\n          }\n        ],\n        namespace: payload.data.namespace\n      };\n      logs.push(\"Body para upsert (Get Dimensions): \" + trimLog(JSON.stringify(upsertBody)));\n      console.log(\"Body de upsert:\", upsertBody);\n\n      options = {\n        method: \"POST\",\n        uri: endpoint,\n        headers: pineconeHeaders,\n        body: upsertBody,\n        json: true\n      };\n\n      response = await this.helpers.request(options);\n      logs.push(\"Resposta do upsert recebida.\");\n      console.log(\"Resposta do upsert:\", trimLog(JSON.stringify(response)));\n\n      mainResponse = response;\n    } else {\n      logs.push(\"Operação não compatível. Nenhuma requisição enviada.\");\n      console.log(\"Operação não compatível.\");\n      mainResponse = { message: \"Operação não compatível.\" };\n    }\n\n    // Atualiza a tabela vectors_status para os casos ENABLED, DISABLED, INSERT ou UPDATE (ou DELETE)\n    if ([\"ENABLED\", \"DISABLED\", \"INSERT\", \"UPDATE\", \"DELETE\"].includes(op)) {\n      const statusValue = payload.data.enabled === true ? \"#2ECDA7\" : \"#E35169\";\n      const directusStatusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\n      const directusStatusEndpoint = directusStatusHost + \"/items/vectors_status\";\n      const directusHeaders = {\n        \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n        \"Content-Type\": \"application/json\"\n      };\n      logs.push(\"Atualizando tabela vectors_status em: \" + directusStatusEndpoint);\n      console.log(\"Directus vectors_status endpoint:\", directusStatusEndpoint);\n\n      const statusQueryOptions = {\n        method: \"GET\",\n        uri: directusStatusEndpoint,\n        qs: { \"filter[vector_id][_eq]\": payload.data.id },\n        headers: directusHeaders,\n        json: true\n      };\n\n      let statusRecord = await this.helpers.request(statusQueryOptions);\n      logs.push(\"Resposta da consulta vectors_status: \" + trimLog(JSON.stringify(statusRecord)));\n      console.log(\"Directus vectors_status GET response:\", trimLog(JSON.stringify(statusRecord)));\n\n      const currentTimestamp = new Date().toISOString();\n      const statusBody = {\n        value: statusValue,\n        vector_id: payload.data.id,\n        date_created: currentTimestamp,\n        date_updated: currentTimestamp\n      };\n\n      if (statusRecord && statusRecord.data && statusRecord.data.length > 0) {\n        const recordId = statusRecord.data[0].id;\n        const statusUpdateEndpoint = directusStatusEndpoint + \"/\" + recordId;\n        logs.push(\"Atualizando registro vectors_status com id: \" + recordId);\n        console.log(\"Atualizando vectors_status em:\", statusUpdateEndpoint);\n\n        const statusUpdateOptions = {\n          method: \"PATCH\",\n          uri: statusUpdateEndpoint,\n          headers: directusHeaders,\n          body: statusBody,\n          json: true\n        };\n\n        var statusResponse = await this.helpers.request(statusUpdateOptions);\n        logs.push(\"Resposta atualização vectors_status: \" + trimLog(JSON.stringify(statusResponse)));\n        console.log(\"Directus vectors_status update response:\", trimLog(JSON.stringify(statusResponse)));\n      } else {\n        logs.push(\"Nenhum registro vectors_status encontrado, criando novo.\");\n        console.log(\"Criando novo registro vectors_status.\");\n\n        const statusCreateOptions = {\n          method: \"POST\",\n          uri: directusStatusEndpoint,\n          headers: directusHeaders,\n          body: statusBody,\n          json: true\n        };\n\n        var statusResponse = await this.helpers.request(statusCreateOptions);\n        logs.push(\"Resposta criação vectors_status: \" + trimLog(JSON.stringify(statusResponse)));\n        console.log(\"Directus vectors_status create response:\", trimLog(JSON.stringify(statusResponse)));\n      }\n    }\n\n    return [{\n      json: {\n        mainResponse,\n        logs\n      }\n    }];\n  } catch (error) {\n    console.error(\"Erro:\", error);\n    logs.push(\"Erro: \" + error.message);\n    return [{\n      json: {\n        error: error.message,\n        logs\n      }\n    }];\n  }\n}\n\nreturn main();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        2180
      ],
      "id": "d31c7c9a-a837-4f69-b5c7-9fa5e5a792d1",
      "name": "Update Vectors"
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "dimensions",
          "mode": "list",
          "cachedResultName": "dimensions"
        },
        "returnAll": true,
        "where": {
          "values": [
            {
              "column": "vector_id",
              "value": "={{ $json.payload.data.id }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        20,
        2180
      ],
      "id": "f62eaf07-9275-4845-bbf7-3a49cf42160c",
      "name": "Get Dimensions",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 700,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -280,
        2080
      ],
      "id": "4a2caf6e-ee2d-4767-9774-092cd7bff5cb",
      "name": "Sticky Note15"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -540,
        2180
      ],
      "id": "83b2bc4b-d2a1-4e10-adf2-86e70eb07f2e",
      "name": "No Operation 3"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH knowledge_descriptions AS (\n  SELECT json_agg(\n    json_build_object(\n      'id', k.id,\n      'description', k.description,\n      'pinecone_host', ph.value,\n      'namespace', ns.value\n    )\n  ) AS knowledge_data\n  FROM knowledge_ai_agents kaa\n  JOIN knowledge k ON k.id = kaa.knowledge_id\n  LEFT JOIN pinecone_host ph ON ph.id = k.pinecone_host_id\n  LEFT JOIN namespace ns ON ns.id = k.name_id\n  WHERE kaa.ai_agents_id = {{ $('RAG Input').item.json.body.mapping.parseJson().system.ai_agent_id }}\n),\nchat_histories AS (\n  SELECT json_agg(ch.*) AS chat_items\n  FROM core_chat_histories ch\n  WHERE ch.session_id = '{{ $('RAG Input').item.json.body.mapping.parseJson().system.conversations_id }}'\n)\nSELECT\n  (SELECT knowledge_data FROM knowledge_descriptions) AS knowledge,\n  (SELECT chat_items FROM chat_histories) AS chat_histories;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1100,
        2180
      ],
      "id": "fac17f0f-52f1-46a1-8978-93ff90435f7f",
      "name": "Get History",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "name": "scheduling",
        "description": "Ferramenta para gerenciar agendamentos e compromissos através do n8n. Processa solicitações relacionadas a criação, atualização, consulta e cancelamento de eventos agendados.\n",
        "jsCode": "// SchedulingAssistant tool for n8n\nconst axios = require('axios');\n\n// Parse the incoming query and mapping data\ntry {\n  // Access the operation from the input query\n  const params = query;\n  \n  // Get the mapping data\n  const mapping = JSON.parse($('Core Input').item.json.body.mapping);\n  \n  // Define the webhook URL using the mapping\n  const url = `http://${mapping.system.n8n_webhook_service}:5678/webhook/scheduling`;\n  \n  // Prepare payload with operation details\n  const payload = {\n    params: { \n      ...params \n    },\n    mapping: mapping\n  };\n  \n  // Send request to webhook endpoint\n  const response = await axios.post(url, payload);\n  \n  // Return webhook response as string\n  return JSON.stringify(response.data);\n  \n} catch (error) {\n  // Handle errors\n  return `Error processing request: ${error.message}`;\n}",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"operation\": {\n      \"type\": \"string\",\n      \"description\": \"The scheduling operation\",\n      \"enum\": [\"create\", \"update\", \"query\", \"delete\", \"query-slots\"]\n    },\n    \"dateTime\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"description\": \"Data e hora do agendamento (horário de Brasília)\"\n    },\n    \"newDateTime\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"description\": \"Nova data e hora para o agendamento quando estiver atualizando (horário de Brasília)\"\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"description\": \"Título do agendamento\",\n      \"default\": \"compromisso\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"Descrição do agendamento\",\n      \"default\": \"nenhuma\"\n    },\n    \"calendarId\": {\n      \"type\": \"string\",\n      \"description\": \"Identificador do calendário\",\n      \"default\": \"primary\"\n    }\n  },\n  \"required\": [\"operation\", \"dateTime\"],\n  \"dependencies\": {\n    \"operation\": {\n      \"oneOf\": [\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"update\"]\n            }\n          },\n          \"required\": [\"newDateTime\"]\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"create\", \"query\", \"query-slots\"]\n            }\n          }\n        }\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1500,
        1580
      ],
      "id": "7a796314-1f8a-4efc-8e3f-799cd66e7ae4",
      "name": "Scheduling"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 500,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        960,
        840
      ],
      "id": "cb3cf431-dbba-4669-9caa-a6f4d62b54d7",
      "name": "Sticky Note12"
    },
    {
      "parameters": {
        "content": "",
        "height": 340,
        "width": 540,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        940,
        820
      ],
      "typeVersion": 1,
      "id": "0b5dee9e-9557-43a3-a6ab-106176749969",
      "name": "Sticky Note16"
    },
    {
      "parameters": {
        "content": "Modulo de agendamento",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1000,
        800
      ],
      "id": "768376fe-f7a1-46b1-9cac-9830236e35e8",
      "name": "Sticky Note17"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "scheduling",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        1060,
        940
      ],
      "id": "d7234d25-ff53-4156-8ec0-cb2d151ba181",
      "name": "Scheduling Trigger",
      "webhookId": "e5ac896b-72e2-4095-a781-3ce17a36b792"
    },
    {
      "parameters": {
        "jsCode": "const CONFIG = {\n  timezone: 'America/Sao_Paulo',  // Fuso horário padrão\n  maxCommitmentsPerClient: -1,    // -1 para desativar, 1 para um agendamento por email\n  saveToDirectus: true,           // Habilitar salvamento no Directus\n  validateBeforeBooking: true,    // Habilitar validação de horario antes do agendamento\n  startHour: 9,                   // Parâmetros de inicio do horário comercial \n  endHour: 18,                    // Parâmetros de fim do horário comercial \n  defaultDuration: 60             // Duração padrão em minutos\n};\n\nconst inputData = $('Scheduling Trigger').first().json.body.params\nconst inputMapping = $('Scheduling Trigger').first().json.body.mapping;\nconst systemData = inputMapping.system;\nconst chatwootData = inputMapping.chatwoot;\nconst eventData = chatwootData.events\n      .filter(calendar => calendar.calendar_id == inputData.calendarId);\nconst { contact_id } = chatwootData;\nconst logs = [];\n\nconst credentials = {\n  accessToken: systemData.accessToken,\n  refreshToken: systemData.refreshToken,\n  clientId: systemData.clientId,\n  clientSecret: systemData.clientSecret,\n  directusToken: systemData.directus_token,\n  directusService: systemData.directus_service\n};\n\nconst dayjs = require('dayjs');\nconst utc = require('dayjs/plugin/utc');\nconst timezone = require('dayjs/plugin/timezone');\nconst isSameOrAfter = require('dayjs/plugin/isSameOrAfter');\nconst isSameOrBefore = require('dayjs/plugin/isSameOrBefore');\n\n// Configurar os plugins do dayjs logo no início\ndayjs.extend(utc);\ndayjs.extend(timezone);\ndayjs.extend(isSameOrAfter);\ndayjs.extend(isSameOrBefore);\n\n// Definir timezone padrão para todas as operações\ndayjs.tz.setDefault(CONFIG.timezone);\n\n// =========================================================\n// FUNÇÕES AUXILIARES PARA MANIPULAÇÃO DE DATAS\n// =========================================================\n\n// Converte uma data para o formato UTC (para salvar no Directus)\nfunction formatToUTC(dateTime) {\n  // Garantir que estamos tratando a data no timezone local primeiro\n  const localDate = dayjs(dateTime).tz(CONFIG.timezone);\n  // Converter para UTC\n  return localDate.utc().format();\n}\n\n// Converte uma data de UTC para o fuso horário local (para exibição)\nfunction formatFromUTC(dateTime, format = null) {\n  const localDate = dayjs(dateTime).tz(CONFIG.timezone);\n  return format ? localDate.format(format) : localDate;\n}\n\n// Extrai componentes de data e hora de uma string ISO\nfunction extractDateTimeComponents(dateTimeStr) {\n  // Garantir que estamos lidando com a data no fuso horário correto\n  const dateTime = dayjs(dateTimeStr).tz(CONFIG.timezone);\n  \n  return {\n    date: dateTime.format('YYYY-MM-DD'),\n    time: dateTime.format('HH:mm'),\n    dateTime: dateTime.format(), // ISO string completo\n    formattedDate: dateTime.format('DD/MM/YYYY'), // Formato brasileiro\n    formattedTime: dateTime.format('HH:mm')\n  };\n}\n\n// =========================================================\n// FUNÇÕES AUXILIARES\n// =========================================================\n\nfunction log(message, data = null) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    message\n  };\n  \n  if (data) {\n    if (typeof data === 'string' && data.length > 200) {\n      entry.data = data.substring(0, 200) + '... (truncado)';\n    } else if (typeof data === 'object') {\n      const stringified = JSON.stringify(data);\n      entry.data = stringified.length > 200 \n        ? JSON.stringify(data).substring(0, 200) + '... (truncado)' \n        : data;\n    } else {\n      entry.data = data;\n    }\n  }\n  \n  logs.push(entry);\n}\n\nfunction calculateDateTime() {\n  if (!inputData.dateTime) {\n    throw new Error(\"Para criar um evento, forneça uma data e hora.\");\n  }\n\n  // Garantir que as datas estão no fuso horário local\n  const startTime = formatFromUTC(inputData.dateTime);\n  const endTime = startTime.add(CONFIG.defaultDuration, 'minute');\n\n  return {\n    startTime,\n    endTime\n  };\n}\n\nfunction createClient(token) {\n  const axios = require('axios');\n  return {\n    get: (url, params = {}) => axios({\n      method: 'get',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` },\n      params\n    }),\n    post: (url, data) => axios({\n      method: 'post',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    put: (url, data) => axios({\n      method: 'put',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    delete: (url) => axios({\n      method: 'delete',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` }\n    })\n  };\n};\n\nasync function validateAvailability(token, calendarId, dateTime, duration) {\n  log('Validando disponibilidade para agendamento', { calendarId, dateTime, duration });\n  \n  try {\n    // Calcular horário de início e fim no fuso horário local\n    const startTime = formatFromUTC(dateTime);\n    const endTime = startTime.add(duration, 'minute');\n    \n    log('Período para validação:', {\n      start: startTime.format('YYYY-MM-DD HH:mm'),\n      end: endTime.format('YYYY-MM-DD HH:mm')\n    });\n    \n    // Para o Google Calendar, precisamos enviar em UTC ISO\n    // O Google Calendar vai interpretar corretamente baseado no timezone especificado no evento\n    const timeMin = startTime.subtract(1, 'minute').toISOString();\n    const timeMax = endTime.add(1, 'minute').toISOString();\n    \n    const client = createClient(token);\n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n      {\n        timeMin,\n        timeMax,\n        singleEvents: true,\n        orderBy: 'startTime'\n      }\n    );\n    \n    // Filtrar apenas eventos que se sobrepõem ao período desejado\n    const conflictingEvents = (response.data.items || []).filter(event => {\n      // Pular eventos cancelados\n      if (event.status === 'cancelled') return false;\n      \n      // Converter horários do evento para o mesmo fuso horário local\n      const eventStart = event.start.dateTime \n        ? formatFromUTC(event.start.dateTime)\n        : formatFromUTC(event.start.date).startOf('day');\n        \n      const eventEnd = event.end.dateTime \n        ? formatFromUTC(event.end.dateTime)\n        : formatFromUTC(event.end.date).endOf('day');\n        \n      // Verificar sobreposição\n      // Caso 1: Evento começa durante o período desejado\n      const startsInPeriod = eventStart.isAfter(startTime) && eventStart.isBefore(endTime);\n      \n      // Caso 2: Evento termina durante o período desejado\n      const endsInPeriod = eventEnd.isAfter(startTime) && eventEnd.isBefore(endTime);\n      \n      // Caso 3: Evento engloba completamente o período desejado\n      const surroundsPeriod = eventStart.isSameOrBefore(startTime) && eventEnd.isSameOrAfter(endTime);\n      \n      // Caso 4: Exata correspondência de início ou fim\n      const exactMatchStart = eventStart.isSame(startTime);\n      const exactMatchEnd = eventEnd.isSame(endTime);\n      \n      return startsInPeriod || endsInPeriod || surroundsPeriod || exactMatchStart || exactMatchEnd;\n    });\n    \n    const isAvailable = conflictingEvents.length === 0;\n    \n    if (isAvailable) {\n      log('Horário disponível para agendamento');\n    } else {\n      log('Conflito de agendamento detectado', \n        conflictingEvents.map(e => ({\n          title: e.summary, \n          start: e.start.dateTime || e.start.date,\n          end: e.end.dateTime || e.end.date\n        }))\n      );\n    }\n    \n    return {\n      available: isAvailable,\n      conflictingEvents: isAvailable ? [] : conflictingEvents.map(e => ({\n        title: e.summary || 'Sem título',\n        start: e.start.dateTime || e.start.date,\n        end: e.end.dateTime || e.end.date,\n        id: e.id\n      }))\n    };\n  } catch (error) {\n    // Verificar se é erro de token expirado - se for, deixe propagar para executeWithToken tratar\n    if (error.response && error.response.status === 401) {\n      log('Token expirado durante validação de disponibilidade, propagando erro');\n      throw error; // Propagar o erro para executeWithToken tratar\n    }\n    \n    // Para outros erros, continuamos com o comportamento atual\n    log('Erro ao validar disponibilidade', error.message);\n    return {\n      available: false,\n      error: error.message,\n      errorType: 'validation_error'\n    };\n  }\n}\n\nasync function getCalendarName(token, calendarId) {\n  log(`Buscando informações do calendário: ${calendarId}`);\n  \n  try {\n    const client = createClient(token);\n    let response;\n    \n    try {\n      response = await client.get(\n        `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}`\n      );\n      log('Resposta da API Google:', response.data);\n    } catch (error) {\n      // Se for erro de token expirado, tenta renovar e fazer nova requisição\n      if (error.response && error.response.status === 401) {\n        log('Token expirado durante busca de calendário, renovando');\n        try {\n          const newToken = await refreshGoogleToken();\n          credentials.accessToken = newToken; // Atualizar o token localmente\n          const newClient = createClient(newToken);\n          \n          try {\n            response = await newClient.get(\n              `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}`\n            );\n            log('Resposta da API Google após renovação de token:', response.data);\n          } catch (secondError) {\n            // Se falhar novamente, usamos o ID como nome\n            log('Falha na segunda tentativa de buscar nome do calendário', secondError.message);\n            return calendarId;\n          }\n        } catch (renewError) {\n          log('Erro ao renovar token', renewError.message);\n          return calendarId; // Fallback para ID em caso de erro na renovação\n        }\n      } else {\n        // Outros erros\n        log('Erro não relacionado a token expirado:', error.message);\n        throw error;\n      }\n    }\n\n    // O nome do calendário está no campo \"summary\"\n    const calendarName = response.data.summary || 'Calendário sem nome';\n    log(`Nome do calendário obtido: ${calendarName}`);\n    return calendarName;\n  } catch (error) {\n    log('Erro ao buscar nome do calendário', error.message);\n    \n    // Para calendários especiais como \"primary\", podemos definir nomes amigáveis\n    if (calendarId === 'primary') {\n      return 'Calendário Principal';\n    }\n    \n    // Em caso de erro, retorna o próprio ID como nome\n    return calendarId;\n  }\n}\n\nasync function ensureSchedulingRelation(calendarId) {\n  if (!CONFIG.saveToDirectus) return { calendarId, calendarName: calendarId };\n  \n  log('Verificando/criando relação na tabela scheduling para calendar_id', calendarId);\n  \n  try {\n    const client = createClient(credentials.directusToken);\n    \n    // Obter o nome do calendário (com tratamento de erros aprimorado)\n    const token = credentials.accessToken;\n    let calendarName;\n    \n    try {\n      calendarName = await getCalendarName(token, calendarId);\n    } catch (error) {\n      // Se falhar ao obter o nome, usa o ID como fallback\n      log('Falha ao obter nome do calendário, usando ID como fallback', error.message);\n      calendarName = calendarId;\n    }\n    \n    // Verificar se o calendário já existe na tabela scheduling\n    const searchResponse = await client.get(\n      `http://${credentials.directusService}:8055/items/event_history_user`\n    );\n\n    const calendars = searchResponse.data.data;\n    const calendarCurrent = calendars.find(calendar => calendar.calendar_id === calendarId && calendar.user_id === contact_id);\n    let newCalendarId = null;\n\n    // Se não existir, criar o registro\n    if (!calendarCurrent) {\n      log('Criando novo registro na tabela scheduling', { calendarId, calendarName, contact_id });\n      \n      const response = await client.post(\n        `http://${credentials.directusService}:8055/items/event_history_user`,\n        {\n          name: calendarName,\n          calendar_id: calendarId,\n          user_id: contact_id\n        }\n      );\n\n      newCalendarId = response.data.data.id;\n      \n      log('Relação na tabela scheduling criada com sucesso');\n    } else {\n      // Verificar se precisamos atualizar o nome do calendário\n      if (calendarCurrent.name !== calendarName && calendarName !== calendarId) {\n        // Só atualiza se tivermos um nome real (diferente do ID)\n        log('Atualizando nome do calendário na tabela scheduling', { \n          oldName: calendarCurrent.name, \n          newName: calendarName \n        });\n        const axios = require('axios');\n\n        await axios({\n          method: 'patch',\n          url: `http://${credentials.directusService}:8055/items/event_history_user/${calendarCurrent.id}`,\n          headers: {\n            'Authorization': `Bearer ${credentials.directusToken}`,\n            'Content-Type': 'application/json'\n          },\n          data: {\n            name: calendarName\n          }\n        });\n        \n        log('Nome do calendário atualizado com sucesso');\n      } else {\n        log('Relação na tabela scheduling já existe');\n      }\n    }\n    \n    return {\n      id: newCalendarId || calendarCurrent.id,\n      calendarId,\n      calendarName\n    };\n  } catch (error) {\n    // Log detalhado para ajudar no debug\n    if (error.response) {\n      log('Detalhes do erro ao criar relação scheduling', {\n        status: error.response.status,\n        data: error.response.data,\n        headers: error.response.headers\n      });\n    } else if (error.request) {\n      log('Erro na resposta do Directus', error.request);\n    }\n    \n    log('Erro ao verificar/criar relação na tabela scheduling', error.message);\n    return {\n      calendarId,\n      calendarName: calendarId // Fallback para o ID em caso de erro\n    };\n  }\n}\n\nasync function saveToDirectus(eventData) {\n  if (!CONFIG.saveToDirectus) return true;\n  \n  log('Salvando agendamento no Directus', eventData);\n  \n  try {\n    \n    // Primeiro, verificar/criar a relação na tabela scheduling\n    const calendarId = inputData.calendarId || 'primary';\n    const scheduling = await ensureSchedulingRelation(calendarId);\n\n    // Converter a data para UTC antes de salvar no Directus\n    const dateInUTC = formatToUTC(eventData.startTime);\n    log('Data convertida para UTC para salvar no Directus:', dateInUTC);\n    \n    // Preparar dados para envio\n    const directusData = {\n      title: eventData.title,\n      description: eventData.description || '',\n      date: dateInUTC,  // Aqui garantimos que estamos salvando em UTC\n      event_id: eventData.eventId,\n      session_id: scheduling.id, \n      calendar_id: calendarId\n    };\n    \n    log('Payload para Directus', directusData);\n    \n    // Realizar a requisição\n    const client = createClient(credentials.directusToken);\n    await client.post(\n      `http://${credentials.directusService}:8055/items/event_history`,\n      directusData\n    );\n    \n    log('Agendamento salvo com sucesso no Directus');\n    return true;\n  } catch (error) {\n    if (error.response) {\n      log('Detalhes do erro do Directus', {\n        status: error.response.status,\n        data: error.response.data,\n        headers: error.response.headers\n      });\n    } else if (error.request) {\n      log('Erro na resposta do Directus', error.request);\n    }\n    log('Erro ao salvar agendamento no Directus', error.message);\n    return false;\n  }\n}\n\nasync function refreshGoogleToken() {\n  log('Renovando token do Google');\n\n  try {\n    const axios = require('axios');\n    const qs = require('querystring');\n\n    const response = await axios({\n      method: 'post',\n      url: 'https://oauth2.googleapis.com/token',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      data: qs.stringify({\n        client_id: credentials.clientId,\n        client_secret: credentials.clientSecret,\n        refresh_token: credentials.refreshToken,\n        grant_type: 'refresh_token'\n      })\n    });\n    \n    const newToken = response.data.access_token;\n    \n    // Atualizar token no Directus\n    await axios({\n      method: 'patch',\n      url: `http://${credentials.directusService}:8055/items/global_vars`,\n      headers: {\n        'Authorization': `Bearer ${credentials.directusToken}`,\n        'Content-Type': 'application/json'\n      },\n      data: { accessToken: newToken }\n    });\n    \n    log('Token renovado e atualizado com sucesso');\n    return newToken;\n  } catch (error) {\n    log('Erro ao renovar token', error.message);\n    throw error;\n  }\n}\n\nasync function executeWithToken(operation) {\n  try {\n    return await operation(credentials.accessToken);\n  } catch (error) {\n    // Se for erro de token expirado, renovar e tentar novamente\n    if (error.response && error.response.status === 401) {\n      log('Token expirado, renovando e tentando novamente');\n      try {\n        const newToken = await refreshGoogleToken();\n        credentials.accessToken = newToken; // Atualizar o token localmente também\n        const result = await operation(newToken);\n        return {\n          ...result,\n          message: result.message + \" (após renovação do token)\"\n        };\n      } catch (renewError) {\n        log('Erro ao renovar token durante executeWithToken', renewError.message);\n        throw { message: 'Falha ao renovar token: ' + renewError.message, errorType: 'token_refresh_failed' };\n      }\n    }\n    \n    // Outros erros\n    const errorMsg = error.message || 'Erro desconhecido';\n    let errorType = \"general_error\";\n    \n    if (errorMsg.includes(\"Limite máximo\")) errorType = \"appointment_limit_exceeded\";\n    if (errorMsg.includes(\"Acesso negado\") || errorMsg.includes(\"Email obrigatório\")) errorType = \"access_denied\";\n    \n    throw { message: errorMsg, errorType };\n  }\n}\n\n// =========================================================\n// FUNÇÕES BASE\n// =========================================================\n\nasync function createEvent(token) {\n  const calendarId = inputData.calendarId ? inputData.calendarId : \"primary\";\n  let { title, description } = inputData;\n\n  if (!title) {\n    throw new Error(\"Para criar um evento, forneça um título\");\n  }\n\n  const { startTime, endTime } = calculateDateTime();\n  \n  // Validar disponibilidade se a opção estiver ativada\n  if (CONFIG.validateBeforeBooking) {\n    log('Validando disponibilidade antes de agendar');\n    \n    // Usamos executeWithToken para garantir a renovação de token se necessário\n    const validateWithToken = async (currentToken) => {\n      return await validateAvailability(\n        currentToken,\n        calendarId,\n        startTime.format(),\n        CONFIG.defaultDuration\n      );\n    };\n    \n    const validationResult = await executeWithToken(validateWithToken);\n    \n    if (!validationResult.available) {\n      // Horário não disponível, retornar erro com detalhes\n      const errorMsg = \"O horário solicitado já está ocupado.\";\n      log(errorMsg, validationResult.conflictingEvents);\n      \n      throw {\n        message: errorMsg,\n        errorType: \"scheduling_conflict\",\n        conflictingEvents: validationResult.conflictingEvents\n      };\n    }\n  }\n\n  // Verificar limite de agendamentos\n  if (CONFIG.maxCommitmentsPerClient != -1) {\n    if (eventData.length >= CONFIG.maxCommitmentsPerClient) {\n      throw new Error(`Limite máximo de ${CONFIG.maxCommitmentsPerClient} agendamento(s) excedido.`);\n    }\n  }\n\n  const event = {\n    summary: title,\n    description: description || '',\n    start: {\n      dateTime: startTime.toISOString(),\n      timeZone: CONFIG.timezone\n    },\n    end: {\n      dateTime: endTime.toISOString(),\n      timeZone: CONFIG.timezone\n    }\n  };\n\n  log('Criando evento', { title, calendarId });\n  \n  let client = createClient(token);\n  const response = await client.post(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n    event\n  );\n\n  // Formatar os horários no fuso horário local para exibição\n  const formattedStartTime = startTime.format();\n  const formattedEndTime = endTime.format();\n\n  let savedToDirectus = false;\n  if(CONFIG.saveToDirectus){\n    // Dados para salvar no Directus\n    const eventData = {\n      title,\n      description: description || '',\n      startTime: formattedStartTime,\n      endTime: formattedEndTime,\n      eventId: response.data.id\n    };\n    savedToDirectus = await saveToDirectus(eventData);\n  }\n\n  return {\n    success: true,\n    message: \"Evento criado com sucesso\" + (savedToDirectus ? \" e registrado no event_history\" : \"\"),\n    eventId: response.data.id,\n    eventLink: response.data.htmlLink,\n    startTime: formattedStartTime,\n    endTime: formattedEndTime,\n    savedToDirectus\n  };\n}\n\nasync function updateEvent(token) {\n  log('Iniciando processo de atualização de evento');\n  \n  try {\n    // Verificar parâmetros obrigatórios\n    const calendarId = inputData.calendarId || 'primary';\n    \n    if (!inputData.dateTime) {\n      throw new Error(\"Para atualizar um evento, forneça a data e hora original do agendamento.\");\n    }\n    \n    if (!inputData.newDateTime && !inputData.title && !inputData.description) {\n      throw new Error(\"Para atualizar um evento, forneça pelo menos um novo valor (data/hora, título ou descrição).\");\n    }\n    \n    log('Tentando atualizar evento no calendário:', calendarId);\n    log('Data/hora original:', inputData.dateTime);\n    \n    if (inputData.newDateTime) {\n      log('Nova data/hora:', inputData.newDateTime);\n    }\n    \n    // Extrair data e hora original para buscar o evento - usando nossa função auxiliar\n    const originalDateTime = formatFromUTC(inputData.dateTime);\n    const originalDateTimeComponents = extractDateTimeComponents(originalDateTime.format());\n    \n    log('Buscando evento com data:', originalDateTimeComponents.date, 'e hora:', originalDateTimeComponents.time);\n    \n    // Verificar se há eventos disponíveis\n    if (!eventData || !Array.isArray(eventData) || eventData.length === 0) {\n      log('Nenhum evento encontrado para este calendário');\n      return {\n        message: \"Nenhum evento encontrado para atualizar neste calendário.\",\n        success: false\n      };\n    }\n    \n    // Filtrar eventos do calendário especificado\n    const calendarEvents = eventData.filter(event => event.calendar_id === calendarId);\n    \n    if (calendarEvents.length === 0) {\n      log('Nenhum evento encontrado para este calendário específico');\n      return {\n        message: \"Nenhum evento encontrado para este calendário.\",\n        success: false\n      };\n    }\n    \n    // Buscar evento que corresponda à data e hora original\n    const eventToUpdate = calendarEvents.find(event => {\n      // Converter data/hora do evento do Directus para local usando nossa função auxiliar\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n      \n      // Verificar correspondência de data e hora\n      const dateMatches = eventDateTimeComponents.date === originalDateTimeComponents.date;\n      const timeMatches = eventDateTimeComponents.time === originalDateTimeComponents.time;\n      \n      log(`Comparando evento: ${event.title}, data: ${eventDateTimeComponents.date} (match: ${dateMatches}), hora: ${eventDateTimeComponents.time} (match: ${timeMatches})`);\n      \n      return dateMatches && timeMatches;\n    });\n    \n    if (!eventToUpdate) {\n      // Se não encontrar o evento exato, retornar todos os eventos disponíveis\n      const allEvents = calendarEvents.map(event => {\n        // Converter data/hora do evento do Directus para local\n        const eventDateTime = formatFromUTC(event.date);\n        const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n        \n        return {\n          id: event.id,\n          title: event.title,\n          description: event.description || '',\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          dateTime: eventDateTime.format(),\n          eventId: event.event_id\n        };\n      });\n      \n      // Ordenar por data/hora\n      allEvents.sort((a, b) => {\n        if (a.date !== b.date) return a.date.localeCompare(b.date);\n        return a.time.localeCompare(b.time);\n      });\n      \n      log('Evento não encontrado, retornando lista de eventos disponíveis');\n      \n      return {\n        message: `Nenhum evento encontrado na data e hora especificadas. Você possui ${allEvents.length} eventos neste calendário.`,\n        success: false,\n        events: allEvents\n      };\n    }\n    \n    log('Evento encontrado para atualização:', {\n      id: eventToUpdate.id,\n      eventId: eventToUpdate.event_id,\n      title: eventToUpdate.title,\n      date: formatFromUTC(eventToUpdate.date).format('YYYY-MM-DD HH:mm')\n    });\n    \n    // Se vai atualizar a data/hora, validar disponibilidade\n    if (inputData.newDateTime && CONFIG.validateBeforeBooking) {\n      log('Validando disponibilidade para a nova data/hora');\n      \n      // Usar executeWithToken para garantir renovação do token se necessário\n      const validateWithToken = async (currentToken) => {\n        return await validateAvailability(\n          currentToken,\n          calendarId,\n          inputData.newDateTime,\n          CONFIG.defaultDuration\n        );\n      };\n      \n      const validationResult = await executeWithToken(validateWithToken);\n      \n      // Verificar se o resultado encontrou conflitos além do próprio evento\n      if (!validationResult.available) {\n        // Filtrar o próprio evento da lista de conflitos\n        const otherConflicts = validationResult.conflictingEvents.filter(\n          conflict => conflict.id !== eventToUpdate.event_id\n        );\n        \n        if (otherConflicts.length > 0) {\n          // Horário não disponível, retornar erro com detalhes\n          const errorMsg = \"O novo horário solicitado está ocupado por outro evento.\";\n          log(errorMsg, otherConflicts);\n          \n          throw {\n            message: errorMsg,\n            errorType: \"scheduling_conflict\",\n            conflictingEvents: otherConflicts\n          };\n        }\n      }\n    }\n    \n    // Preparar dados para a atualização no Google Calendar\n    const { startTime, endTime } = inputData.newDateTime \n      ? {\n          startTime: formatFromUTC(inputData.newDateTime),\n          endTime: formatFromUTC(inputData.newDateTime).add(CONFIG.defaultDuration, 'minute')\n        }\n      : {\n          startTime: formatFromUTC(inputData.dateTime),\n          endTime: formatFromUTC(inputData.dateTime).add(CONFIG.defaultDuration, 'minute')\n        };\n    \n    // Construir o objeto de atualização\n    const updatedEvent = {\n      summary: inputData.title || eventToUpdate.title,\n      description: inputData.description !== undefined ? inputData.description : eventToUpdate.description || '',\n      start: {\n        dateTime: startTime.toISOString(),\n        timeZone: CONFIG.timezone\n      },\n      end: {\n        dateTime: endTime.toISOString(),\n        timeZone: CONFIG.timezone\n      }\n    };\n    \n    log('Enviando atualização para o Google Calendar', updatedEvent);\n    \n    // Executar a atualização no Google Calendar\n    const updateGoogleCalendar = async (currentToken) => {\n      const client = createClient(currentToken);\n      return await client.put(\n        `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventToUpdate.event_id)}`,\n        updatedEvent\n      );\n    };\n    \n    // Usar executeWithToken para garantir renovação do token se necessário\n    const response = await executeWithToken(updateGoogleCalendar);\n    \n    log('Evento atualizado no Google Calendar com sucesso');\n    \n    // Atualizar no Directus se necessário\n    if (CONFIG.saveToDirectus) {\n      try {\n        // Preparar dados para atualização no Directus\n        const directusData = {\n          title: inputData.title || eventToUpdate.title,\n          description: inputData.description !== undefined ? inputData.description : eventToUpdate.description || ''\n        };\n        \n        // Se a data foi alterada, atualizar também - sempre salvando em UTC\n        if (inputData.newDateTime) {\n          const dateInUTC = formatToUTC(startTime);\n          directusData.date = dateInUTC;\n          log('Nova data em UTC para o Directus:', dateInUTC);\n        }\n        \n        log('Atualizando evento no Directus', directusData);\n\n        // Atualizar no Directus - Usando PATCH em vez de PUT\n        const axios = require('axios');\n        \n        // Atualizar no Directus\n        await axios({\n          method: 'patch',\n          url: `http://${credentials.directusService}:8055/items/event_history/${eventToUpdate.id}`,\n          headers: {\n            'Authorization': `Bearer ${credentials.directusToken}`,\n            'Content-Type': 'application/json'\n          },\n          data: directusData\n        });\n        \n        log('Evento atualizado no Directus com sucesso');\n      } catch (directusError) {\n        log('Erro ao atualizar evento no Directus', directusError.message);\n        // Continuar mesmo com erro no Directus\n      }\n    }\n    \n    // Formatar resultado - retornando no fuso horário local\n    const formattedStartTime = startTime.format();\n    const formattedEndTime = endTime.format();\n    \n    return {\n      success: true,\n      message: \"Evento atualizado com sucesso\",\n      eventId: eventToUpdate.event_id,\n      eventLink: response.data.htmlLink,\n      startTime: formattedStartTime,\n      endTime: formattedEndTime,\n      title: updatedEvent.summary,\n      description: updatedEvent.description\n    };\n    \n  } catch (error) {\n    log('Erro ao atualizar evento', error.message);\n    \n    // Verificar se o erro é específico de conflito de agendamento\n    if (error.errorType === \"scheduling_conflict\") {\n      return {\n        success: false,\n        message: error.message,\n        errorType: error.errorType,\n        conflictingEvents: error.conflictingEvents\n      };\n    }\n    \n    throw { \n      message: `Erro ao atualizar evento: ${error.message}`, \n      errorType: \"update_failed\" \n    };\n  }\n}\n\nasync function deleteEvent(token) {\n  log('Iniciando processo de cancelamento de agendamento');\n  \n  try {\n    const calendarId = inputData.calendarId || 'primary';\n    log('Verificando eventos no calendário:', calendarId);\n    \n    // Verificar se temos a data e hora para cancelamento\n    if (!inputData.dateTime) {\n      throw new Error(\"Para cancelar um evento, forneça a data e hora do agendamento.\");\n    }\n    \n    // Converter a data/hora de entrada para o fuso horário local\n    const inputDateTime = formatFromUTC(inputData.dateTime);\n    const inputDateTimeComponents = extractDateTimeComponents(inputDateTime.format());\n    \n    log('Data alvo para cancelamento:', inputDateTimeComponents.date);\n    log('Hora alvo para cancelamento:', inputDateTimeComponents.time);\n    \n    // Verificar se há eventos disponíveis\n    if (!eventData || !Array.isArray(eventData) || eventData.length === 0) {\n      log('Nenhum evento encontrado para este calendário');\n      return {\n        message: \"Nenhum agendamento encontrado para cancelar. Não há eventos marcados neste calendário.\",\n        success: false,\n        events: []\n      };\n    }\n    \n    // Filtrar apenas eventos do calendário especificado\n    const calendarEvents = eventData.filter(event => event.calendar_id === calendarId);\n    \n    if (calendarEvents.length === 0) {\n      log('Nenhum evento encontrado para este calendário específico');\n      return {\n        message: \"Nenhum agendamento encontrado para este calendário.\",\n        success: false,\n        events: []\n      };\n    }\n    \n    log('Eventos disponíveis no calendário:', calendarEvents.length);\n    \n    // Buscar eventos que correspondam à data/hora especificada\n    const matchingEvents = calendarEvents.filter(event => {\n      // Converter data/hora do evento do Directus para o fuso horário local\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n      \n      // Verificar correspondência direta de data, hora e calendário\n      const dateMatches = eventDateTimeComponents.date === inputDateTimeComponents.date;\n      const timeMatches = eventDateTimeComponents.time === inputDateTimeComponents.time;\n      \n      log(`Analisando evento ${event.id}: data=${dateMatches} (${eventDateTimeComponents.date}), hora=${timeMatches} (${eventDateTimeComponents.time})`);\n      \n      return dateMatches && timeMatches;\n    });\n    \n    log('Eventos correspondentes encontrados:', matchingEvents.length);\n    \n    if (matchingEvents.length === 0) {\n      // Se não encontrar eventos correspondentes, retornar todos os eventos disponíveis\n      const allEvents = calendarEvents.map(event => {\n        // Converter data/hora do evento do Directus para o fuso horário local\n        const eventDateTime = formatFromUTC(event.date);\n        const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n        \n        return {\n          id: event.id,\n          title: event.title,\n          description: event.description || '',\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          dateTime: eventDateTime.format(),\n          eventId: event.event_id\n        };\n      });\n      \n      // Ordenar por data/hora\n      allEvents.sort((a, b) => {\n        if (a.date !== b.date) return a.date.localeCompare(b.date);\n        return a.time.localeCompare(b.time);\n      });\n      \n      log('Nenhum evento correspondente, retornando lista de eventos disponíveis:', allEvents.length);\n      \n      return {\n        message: `Nenhum agendamento encontrado para a data/hora especificada. Você possui ${allEvents.length} agendamentos neste calendário.`,\n        success: false,\n        events: allEvents\n      };\n    }\n    \n    // Processar o cancelamento de cada evento correspondente\n    const results = [];\n    for (const event of matchingEvents) {\n      // Converter data/hora do evento do Directus para o fuso horário local para logging\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n      \n      log('Cancelando evento:', { \n        id: event.id, \n        eventId: event.event_id, \n        title: event.title, \n        date: eventDateTimeComponents.date,\n        time: eventDateTimeComponents.time\n      });\n      \n      try {\n        // Função para executar a exclusão com tratamento de token\n        const deleteFromGoogleCalendar = async (currentToken) => {\n          const client = createClient(currentToken);\n          return await client.delete(\n            `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(event.event_id)}`\n          );\n        };\n        \n        // Usar executeWithToken para garantir que o token seja renovado se necessário\n        await executeWithToken(deleteFromGoogleCalendar);\n        \n        log('Evento cancelado no Google Calendar com sucesso');\n        \n        // 2. Se o evento foi cancelado com sucesso no Google, remover do Directus\n        if (CONFIG.saveToDirectus) {\n          try {\n            const directusClient = createClient(credentials.directusToken);\n            await directusClient.delete(\n              `http://${credentials.directusService}:8055/items/event_history/${event.id}`\n            );\n            log('Evento removido do Directus com sucesso');\n          } catch (directusError) {\n            log('Erro ao remover evento do Directus', directusError.message);\n            // Continuar mesmo com erro no Directus\n          }\n        }\n        \n        // Adicionar ao resultado\n        results.push({\n          eventId: event.event_id,\n          title: event.title,\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          status: 'canceled'\n        });\n      } catch (error) {\n        log('Erro ao cancelar evento no Google Calendar', error.message);\n        \n        results.push({\n          eventId: event.event_id,\n          title: event.title,\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          status: 'error',\n          error: error.message\n        });\n      }\n    }\n    \n    // Determinar mensagem baseada nos resultados\n    const successCount = results.filter(r => r.status === 'canceled').length;\n    const errorCount = results.filter(r => r.status === 'error').length;\n    \n    let message;\n    if (successCount > 0 && errorCount === 0) {\n      message = `${successCount} agendamento(s) cancelado(s) com sucesso.`;\n    } else if (successCount > 0 && errorCount > 0) {\n      message = `${successCount} agendamento(s) cancelado(s) com sucesso. ${errorCount} apresentaram erro.`;\n    } else {\n      message = `Falha ao cancelar os agendamentos. Todos os ${errorCount} eventos apresentaram erro.`;\n    }\n    \n    return {\n      message,\n      success: successCount > 0,\n      canceledCount: successCount,\n      errorCount,\n      results\n    };\n    \n  } catch (error) {\n    log('Erro ao processar cancelamento de evento', error.message);\n    \n    // Se o erro for \"Nenhum evento encontrado\", tentar retornar a lista de eventos\n    if (error.message.includes(\"Nenhum evento encontrado\")) {\n      try {\n        const calendarId = inputData.calendarId || 'primary';\n        const calendarEvents = eventData.filter(event => event.session_id === calendarId);\n        \n        if (calendarEvents && calendarEvents.length > 0) {\n          const allEvents = calendarEvents.map(event => {\n            // Converter data/hora do evento do Directus para o fuso horário local\n            const eventDateTime = formatFromUTC(event.date);\n            const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n            \n            return {\n              id: event.id,\n              title: event.title,\n              description: event.description || '',\n              date: eventDateTimeComponents.date,\n              time: eventDateTimeComponents.time,\n              eventId: event.event_id\n            };\n          }).sort((a, b) => {\n            if (a.date !== b.date) return a.date.localeCompare(b.date);\n            return a.time.localeCompare(b.time);\n          });\n          \n          return {\n            message: `Nenhum agendamento encontrado na data e hora especificadas. Você possui ${allEvents.length} agendamentos neste calendário.`,\n            success: false,\n            events: allEvents\n          };\n        }\n      } catch (secondError) {\n        log('Erro ao tentar recuperar lista de eventos', secondError.message);\n      }\n    }\n    \n    throw { message: error.message, errorType: \"general_error\" };\n  }\n}\n\nasync function queryEvents(token) {\n  log('Consultando eventos do calendário');\n  \n  try {\n    const calendarId = inputData.calendarId || 'primary';\n    log('ID do calendário para consulta:', calendarId);\n\n    // Verificar se há eventos disponíveis\n    if (!eventData || !Array.isArray(eventData) || eventData.length === 0) {\n      log('Nenhum evento encontrado para este calendário');\n      return {\n        message: \"Nenhum evento encontrado para este calendário\",\n        eventsToday: [],\n        upcomingEvents: []\n      };\n    }\n    \n    // Obter a data atual no fuso horário local\n    const today = dayjs().tz(CONFIG.timezone).startOf('day');\n    log('Data de referência para consulta:', today.format('YYYY-MM-DD'));\n    \n    // Separar eventos de hoje e próximos eventos\n    const eventsToday = [];\n    const upcomingEvents = [];\n    \n    eventData.forEach(event => {\n      // Converter a data do evento de UTC para o fuso horário local\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDate = eventDateTime.startOf('day');\n      \n      // Extrair componentes para criar objeto de resultado\n      const components = extractDateTimeComponents(eventDateTime.format());\n      \n      // Criar objeto base para o evento\n      const eventObject = {\n        id: event.id,\n        title: event.title,\n        description: event.description || '',\n        date: components.date,\n        time: components.time,\n        formattedDate: components.formattedDate,\n        dateTime: eventDateTime.format(),\n        eventId: event.event_id\n      };\n      \n      // Verificar se o evento é de hoje\n      if (eventDate.isSame(today, 'day')) {\n        eventsToday.push(eventObject);\n      } \n      // Verificar se o evento é futuro (após hoje)\n      else if (eventDate.isAfter(today, 'day')) {\n        upcomingEvents.push(eventObject);\n      }\n    });\n    \n    // Ordenar eventos por data/hora\n    eventsToday.sort((a, b) => dayjs(a.dateTime).diff(dayjs(b.dateTime)));\n    upcomingEvents.sort((a, b) => dayjs(a.dateTime).diff(dayjs(b.dateTime)));\n    \n    log('Eventos encontrados para hoje:', eventsToday.length);\n    log('Eventos futuros encontrados:', upcomingEvents.length);\n    \n    return {\n      message: `Encontrados ${eventsToday.length} eventos para hoje e ${upcomingEvents.length} eventos futuros`,\n      eventsToday,\n      upcomingEvents\n    };\n  } catch (error) {\n    log('Erro ao consultar eventos', error.message);\n    throw new Error(`Erro ao consultar eventos: ${error.message}`);\n  }\n}\n\nasync function queryAvailableSlots(token) {\n  log('Iniciando busca por slots disponíveis');\n  \n  try {\n    // Definir timezone padrão para todas as operações\n    dayjs.tz.setDefault(CONFIG.timezone);\n    \n    const calendarId = inputData.calendarId || 'primary';\n    log('Calendário selecionado:', calendarId);\n    \n    // Determinar a data alvo - sempre convertendo para o timezone local\n    let targetDate;\n    \n    if (inputData.dateTime) {\n      // Se tiver dateTime (como usado em createEvent), extrair a data\n      targetDate = formatFromUTC(inputData.dateTime).startOf('day');\n      log('Usando data de dateTime:', targetDate.format('YYYY-MM-DD'));\n    } else if (inputData.date) {\n      // Se tiver date específico\n      targetDate = formatFromUTC(inputData.date).startOf('day');\n      log('Usando data fornecida:', targetDate.format('YYYY-MM-DD'));\n    } else {\n      // Default para a data atual em fuso horário local\n      targetDate = dayjs().tz(CONFIG.timezone).startOf('day');\n      log('Nenhuma data fornecida, usando data atual:', targetDate.format('YYYY-MM-DD'));\n    }\n    \n    const targetDateStr = targetDate.format('YYYY-MM-DD');\n    \n    // Parâmetros de horário comercial (padrões caso não sejam fornecidos)\n    const startHour = CONFIG.startHour;  \n    const endHour = CONFIG.endHour;\n    const slotDuration = inputData.slotDuration || CONFIG.defaultDuration; // Duração em minutos (padrão: 60 min)\n    \n    log('Horário comercial configurado:', `${startHour}:00 - ${endHour}:00, slots de ${slotDuration} minutos`);\n    log('Data alvo para consulta:', targetDateStr);\n    \n    // Função para buscar eventos no Google Calendar para a data selecionada\n    const fetchGoogleCalendarEvents = async (authToken) => {\n      const client = createClient(authToken);\n      \n      // Definir início e fim do dia na timezone configurada (Brasília)\n      const startOfDay = targetDate;\n      const endOfDay = targetDate.add(1, 'day');\n      \n      // Converter para ISO para a API do Google\n      const timeMin = startOfDay.toISOString();\n      const timeMax = endOfDay.toISOString();\n      \n      log('Buscando eventos no período (ISO):', { timeMin, timeMax });\n      \n      const response = await client.get(\n        `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n        {\n          timeMin,\n          timeMax,\n          singleEvents: true,\n          orderBy: 'startTime'\n        }\n      );\n      \n      return response.data.items || [];\n    };\n    \n    // Buscar eventos no Google Calendar\n    const googleEvents = await executeWithToken(fetchGoogleCalendarEvents);\n    log('Eventos encontrados no Google Calendar:', googleEvents.length);\n    \n    // Combinar com os eventos do Directus (se disponíveis)\n    let allEvents = [];\n    \n    // Adicionar eventos do Google Calendar, convertendo para timezone local\n    if(googleEvents.length)\n      googleEvents.forEach(event => {\n        if (event.status !== 'cancelled') {\n          // Converter datas para o fuso horário local\n          const startTime = event.start.dateTime \n            ? formatFromUTC(event.start.dateTime)\n            : formatFromUTC(event.start.date).startOf('day');\n            \n          const endTime = event.end.dateTime \n            ? formatFromUTC(event.end.dateTime)\n            : formatFromUTC(event.end.date).endOf('day');\n          \n          log(`Evento do Google: ${event.summary}, Início: ${startTime.format('YYYY-MM-DD HH:mm')}, Fim: ${endTime.format('YYYY-MM-DD HH:mm')}`);\n          \n          allEvents.push({\n            id: event.id,\n            title: event.summary || 'Sem título',\n            start: startTime,\n            end: endTime,\n            source: 'google'\n          });\n        }\n      });\n    \n    // Adicionar eventos do Directus (se existirem), convertendo de UTC para o fuso horário local\n    if (eventData && Array.isArray(eventData)) {\n      const directusEvents = eventData.filter(event => {\n        // Converter para o fuso horário local para comparação\n        const eventDateTime = formatFromUTC(event.date);\n        return eventDateTime.format('YYYY-MM-DD') === targetDateStr && \n               event.session_id === calendarId;\n      });\n      \n      directusEvents.forEach(event => {\n        // Converter de UTC para o fuso horário local\n        const eventStart = formatFromUTC(event.date);\n        const eventEnd = eventStart.add(slotDuration, 'minutes');\n        \n        log(`Evento do Directus: ${event.title}, Início: ${eventStart.format('YYYY-MM-DD HH:mm')}, Fim: ${eventEnd.format('YYYY-MM-DD HH:mm')}`);\n        \n        // Verificar se já existe um evento do Google com o mesmo ID\n        const exists = allEvents.some(e => e.id === event.event_id && e.source === 'google');\n        \n        if (!exists) {\n          allEvents.push({\n            id: event.id,\n            title: event.title || 'Sem título',\n            start: eventStart,\n            end: eventEnd,\n            source: 'directus'\n          });\n        }\n      });\n    }\n    \n    log('Total de eventos após combinação:', allEvents.length);\n    \n    // Gerar todos os slots possíveis para o horário comercial\n    const availableSlots = [];\n    const busySlots = [];\n    \n    // Criar horário comercial no fuso horário local\n    const businessStart = targetDate.hour(startHour).minute(0).second(0);\n    const businessEnd = targetDate.hour(endHour).minute(0).second(0);\n    \n    log(`Horário comercial: ${businessStart.format('YYYY-MM-DD HH:mm')} até ${businessEnd.format('YYYY-MM-DD HH:mm')}`);\n    \n    // Formatar data para exibição no padrão brasileiro\n    const formattedDate = targetDate.format('DD/MM/YYYY');\n    \n    // Iterar sobre os slots do horário comercial\n    let currentSlotStart = businessStart;\n    \n    while (currentSlotStart.isBefore(businessEnd)) {\n      const currentSlotEnd = currentSlotStart.add(slotDuration, 'minutes');\n      \n      log(`Analisando slot: ${currentSlotStart.format('HH:mm')} - ${currentSlotEnd.format('HH:mm')}`);\n      \n      // Verificar se este slot está ocupado por algum evento\n      const isSlotBusy = allEvents.some(event => {\n        // Verificar sobreposição com o horário no fuso horário local\n        const eventStart = event.start;\n        const eventEnd = event.end;\n        \n        // Log de debug para verificar comparação de horários\n        log(`  Comparando com evento: ${event.title}`);\n        log(`    Evento: ${eventStart.format('HH:mm')} - ${eventEnd.format('HH:mm')}`);\n        \n        // Verificar sobreposição utilizando métodos básicos do dayjs\n        const startsInSlot = eventStart.isAfter(currentSlotStart) && eventStart.isBefore(currentSlotEnd);\n        const endsInSlot = eventEnd.isAfter(currentSlotStart) && eventEnd.isBefore(currentSlotEnd);\n        const coversSlot = eventStart.isSameOrBefore(currentSlotStart) && eventEnd.isSameOrAfter(currentSlotEnd);\n        const exactMatchStart = eventStart.isSame(currentSlotStart);\n        const exactMatchEnd = eventEnd.isSame(currentSlotEnd);\n        \n        // Verificação combinada\n        const overlaps = startsInSlot || endsInSlot || coversSlot || exactMatchStart || exactMatchEnd;\n        \n        if (overlaps) {\n          log(`    SOBREPOSIÇÃO ENCONTRADA`);\n        }\n        \n        return overlaps;\n      });\n      \n      const slotInfo = {\n        start: currentSlotStart.format('HH:mm'),\n        end: currentSlotEnd.format('HH:mm'),\n        startISO: currentSlotStart.format(),\n        endISO: currentSlotEnd.format(),\n        formattedDateTime: `${formattedDate} ${currentSlotStart.format('HH:mm')}` // Formato brasileiro\n      };\n      \n      if (isSlotBusy) {\n        busySlots.push(slotInfo);\n        log(`Slot ocupado: ${slotInfo.start} - ${slotInfo.end}`);\n      } else {\n        availableSlots.push(slotInfo);\n        log(`Slot disponível: ${slotInfo.start} - ${slotInfo.end}`);\n      }\n      \n      // Avançar para o próximo slot\n      currentSlotStart = dayjs(currentSlotEnd);  // Criar nova instância para evitar problemas de referência\n    }\n    \n    log('Slots disponíveis encontrados:', availableSlots.length);\n    log('Slots ocupados encontrados:', busySlots.length);\n    \n    // Informações do dia para o resultado\n    const dayInfo = {\n      date: targetDateStr,\n      formattedDate: formattedDate, // Formato brasileiro DD/MM/YYYY\n      dayOfWeek: targetDate.format('dddd'),\n      isToday: targetDate.isSame(dayjs().tz(CONFIG.timezone), 'day'),\n      businessHours: `${startHour}:00 - ${endHour}:00`\n    };\n    \n    return {\n      success: true,\n      message: `Encontrados ${availableSlots.length} horários disponíveis para ${formattedDate}`,\n      day: dayInfo,\n      availableSlots,\n      busySlots,\n      slotDuration\n    };\n    \n  } catch (error) {\n    log('Erro ao consultar slots disponíveis', error.message);\n    if (error.response) {\n      log('Detalhes do erro da API', {\n        status: error.response.status,\n        data: error.response.data\n      });\n    } else if (error.stack) {\n      log('Stack trace do erro', error.stack);\n    }\n    \n    throw { \n      message: `Erro ao consultar horários disponíveis: ${error.message}`, \n      errorType: \"general_error\" \n    };\n  }\n}\n\n// =========================================================\n// FUNÇÀO PRINCIPAL\n// =========================================================\n\nasync function main() {\n  try {\n    const operations = {\n      'create': createEvent,\n      'update': updateEvent,\n      'delete': deleteEvent,\n      'query': queryEvents,\n      'query-slots': queryAvailableSlots\n    };\n    \n    if (!inputData.operation || !operations[inputData.operation]) {\n      throw new Error(\"Operação inválida. Use 'create', 'update', 'delete', 'query' ou 'query_slots'\");\n    }\n    \n    const operation = inputData.operation;\n    const result = await executeWithToken(operations[operation]);\n    \n    return {\n      success: true,\n      ...result,\n      logs\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error.message || \"Erro desconhecido\",\n      errorType: error.errorType || \"general_error\",\n      logs\n    };\n  }\n}\n\n// Iniciar execução\nreturn [{\n  json: await main()\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        940
      ],
      "id": "dd167075-48c7-406b-82bd-7c213443c3b4",
      "name": "Calendar Manager"
    },
    {
      "parameters": {
        "name": "clickup",
        "description": "Ferramenta para gerenciar tarefas no ClickUp. Permite criar, listar, atualizar ou remover tarefas. Para criar, forneça pelo menos o título. Para atualizar ou remover, você precisa fornecer o ID da tarefa. Para listar, você pode aplicar filtros opcionais.",
        "jsCode": "const workspaceId = '9011917991';\nconst listId = '901109860036';\nconst apiKey = 'pk_44163283_ZIFREHZQNJWKZ5YSD0XVV45B272AOARG';\nconst https = require('https');\n\nconst logs = [];\n\nfunction log(message) {\n  logs.push({ time: new Date().toISOString(), message });\n}\n\nfunction request(path, method, body = null) {\n  log(`Requisição: ${method} ${path}`);\n  \n  return new Promise((resolve, reject) => {\n    const options = {\n      hostname: 'api.clickup.com',\n      path,\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': apiKey\n      }\n    };\n    \n    const req = https.request(options, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        try {\n          log(`Resposta: status ${res.statusCode}`);\n          \n          // Tratamento de respostas vazias (comum em DELETEs)\n          if (!data || data.trim() === '') {\n            return res.statusCode < 300 \n              ? resolve({ success: true }) \n              : reject({ \n                  success: false, \n                  message: `Erro: ${res.statusMessage}`, \n                  statusCode: res.statusCode \n                });\n          }\n          \n          const responseData = JSON.parse(data);\n          \n          if (res.statusCode < 300) {\n            resolve(responseData);\n          } else {\n            reject({\n              success: false,\n              message: `Erro: ${responseData.err || res.statusMessage}`,\n              statusCode: res.statusCode\n            });\n          }\n        } catch (error) {\n          log(`Erro ao processar resposta: ${error.message}`);\n          reject({\n            success: false,\n            message: `Erro ao processar resposta: ${error.message}`,\n            data\n          });\n        }\n      });\n    });\n\n    req.on('error', (error) => {\n      log(`Erro na requisição: ${error.message}`);\n      reject({ success: false, message: `Erro na requisição: ${error.message}` });\n    });\n\n    if (body) {\n      const data = typeof body === 'string' ? body : JSON.stringify(body);\n      log(`Enviando dados: ${data.substring(0, 100)}${data.length > 100 ? '...' : ''}`);\n      req.write(data);\n    }\n    \n    req.end();\n  });\n}\n\nconst operations = {\n  async list(query) {\n    log('Operação: listar tarefas');\n    \n    try {\n      // Construir parâmetros de consulta\n      const params = [];\n      \n      if (query.status) params.push(`statuses[]=${encodeURIComponent(query.status)}`);\n      if (query.assignee) params.push(`assignees[]=${encodeURIComponent(query.assignee)}`);\n      if (query.due_date_gt) params.push(`due_date_gt=${encodeURIComponent(query.due_date_gt)}`);\n      if (query.due_date_lt) params.push(`due_date_lt=${encodeURIComponent(query.due_date_lt)}`);\n      \n      // Paginação\n      params.push(`page=${query.page || 0}`);\n      const limit = Math.min(query.limit || 20, 100);\n      params.push(`limit=${limit}`);\n      \n      log(`Parâmetros: ${params.join('&')}`);\n      \n      // Fazer requisição\n      const data = await request(\n        `/api/v2/list/${listId}/task?${params.join('&')}`, \n        'GET'\n      );\n      \n      log(`Tarefas encontradas: ${data.tasks.length}`);\n      \n      return {\n        success: true,\n        tasks: data.tasks,\n        total_count: data.tasks.length,\n        has_more: data.tasks.length === limit\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n\n  async create(query) {\n    log('Operação: criar tarefa');\n    \n    if (!query.title) {\n      log('Erro: Título da tarefa não fornecido');\n      return { success: false, message: \"Título da tarefa é obrigatório para criação\" };\n    }\n    \n    const body = {\n      name: query.title,\n      description: query.description || '',\n      due_date: query.due_date || null,\n      priority: query.priority || 3,\n      assignees: query.assignees || []\n    };\n    \n    try {\n      log(`Criando tarefa: \"${query.title}\"`);\n      const data = await request(`/api/v2/list/${listId}/task`, 'POST', body);\n      log(`Tarefa criada com sucesso, ID: ${data.id}`);\n      \n      return {\n        success: true,\n        message: \"Tarefa criada com sucesso\",\n        taskId: data.id,\n        taskUrl: data.url\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n  \n  async delete(query) {\n    log('Operação: remover tarefa');\n    \n    if (!query.task_id) {\n      log('Erro: ID da tarefa não fornecido');\n      return { success: false, message: \"ID da tarefa é obrigatório para remoção\" };\n    }\n    \n    try {\n      log(`Removendo tarefa: ${query.task_id}`);\n      await request(`/api/v2/task/${query.task_id}`, 'DELETE');\n      log('Tarefa removida com sucesso');\n      \n      return {\n        success: true,\n        message: \"Tarefa removida com sucesso\",\n        taskId: query.task_id\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n  \n  async update(query) {\n    log('Operação: atualizar tarefa');\n    \n    if (!query.task_id) {\n      log('Erro: ID da tarefa não fornecido');\n      return { success: false, message: \"ID da tarefa é obrigatório para atualização\" };\n    }\n    \n    // Mapear campos\n    const fields = {\n      title: 'name',\n      description: 'description',\n      due_date: 'due_date',\n      priority: 'priority',\n      status: 'status',\n      assignees: 'assignees'\n    };\n    \n    const body = {};\n    \n    // Filtrar campos fornecidos\n    Object.entries(fields).forEach(([src, dest]) => {\n      if (query[src] !== undefined) body[dest] = query[src];\n    });\n    \n    if (Object.keys(body).length === 0) {\n      log('Erro: Nenhum campo fornecido para atualização');\n      return { success: false, message: \"Nenhum campo fornecido para atualização\" };\n    }\n    \n    try {\n      log(`Atualizando tarefa: ${query.task_id}`);\n      await request(`/api/v2/task/${query.task_id}`, 'PUT', body);\n      log('Tarefa atualizada com sucesso');\n      \n      return {\n        success: true,\n        message: \"Tarefa atualizada com sucesso\",\n        taskId: query.task_id\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  }\n};\n\ntry {\n  log(`Iniciando processamento: ${JSON.stringify(query)}`);\n  \n  const operation = query.operation || 'create';\n  \n  const result = await operations[operation](query);\n  \n  return JSON.stringify({\n    success: true,\n    ...result,\n    logs: logs\n  });\n} catch (error) {\n  log(`Erro não tratado: ${error.message || JSON.stringify(error)}`);\n  return JSON.stringify({ \n    success: false, \n    message: `Erro não tratado: ${error.message || 'Erro desconhecido'}`,\n    logs \n  });\n}",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"operation\": {\n      \"type\": \"string\",\n      \"description\": \"Operação a ser realizada: criar, listar, atualizar ou remover tarefas\",\n      \"enum\": [\"create\", \"list\", \"update\", \"delete\"],\n      \"default\": \"create\"\n    },\n    \"task_id\": {\n      \"type\": \"string\",\n      \"description\": \"ID da tarefa (obrigatório para atualizar ou remover)\"\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"description\": \"Título da tarefa (obrigatório para criar, opcional para atualizar)\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"Descrição detalhada da tarefa (opcional)\"\n    },\n    \"due_date\": {\n      \"type\": \"string\",\n      \"description\": \"Data de vencimento no formato timestamp ou ISO 8601 (opcional)\"\n    },\n    \"priority\": {\n      \"type\": \"integer\",\n      \"description\": \"Prioridade da tarefa (1: Urgente, 2: Alta, 3: Normal, 4: Baixa) (opcional)\",\n      \"enum\": [1, 2, 3, 4]\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"description\": \"Status da tarefa (para atualizar ou filtrar na listagem)\"\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"integer\"\n      },\n      \"description\": \"Lista de IDs dos usuários atribuídos à tarefa (opcional)\"\n    },\n    \"assignee\": {\n      \"type\": \"integer\",\n      \"description\": \"Filtrar por ID do usuário atribuído (para listar)\"\n    },\n    \"due_date_gt\": {\n      \"type\": \"string\",\n      \"description\": \"Filtrar tarefas com data de vencimento posterior (para listar)\"\n    },\n    \"due_date_lt\": {\n      \"type\": \"string\",\n      \"description\": \"Filtrar tarefas com data de vencimento anterior (para listar)\"\n    },\n    \"page\": {\n      \"type\": \"integer\",\n      \"description\": \"Número da página para paginação (para listar)\",\n      \"default\": 0\n    },\n    \"limit\": {\n      \"type\": \"integer\",\n      \"description\": \"Número de tarefas por página (máximo 100, para listar)\",\n      \"default\": 20\n    }\n  },\n  \"required\": [\"operation\"],\n  \"dependencies\": {\n    \"operation\": {\n      \"oneOf\": [\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"create\"]\n            }\n          },\n          \"required\": [\"title\"]\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"list\"]\n            }\n          }\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"update\"]\n            }\n          },\n          \"required\": [\"task_id\"]\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"delete\"]\n            }\n          },\n          \"required\": [\"task_id\"]\n        }\n      ]\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1620,
        1580
      ],
      "id": "6a06dfcc-eb35-41cb-b35b-313783de7027",
      "name": "Clickup"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -940,
        2460
      ],
      "id": "828e3074-8af6-4072-8085-b0e91dc613f6",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "3raLgi1Pp00Yk6mH",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        920,
        1580
      ],
      "id": "fbae12cb-887e-4604-ad27-2fb16a50746e",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "3raLgi1Pp00Yk6mH",
          "name": "OpenAi account"
        }
      }
    }
  ],
  "connections": {
    "Memory": {
      "ai_memory": [
        [
          {
            "node": "Main Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Main Agent": {
      "main": [
        [
          {
            "node": "No Operation 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add to List": {
      "main": [
        [
          {
            "node": "Get List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get List": {
      "main": [
        [
          {
            "node": "Switch 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON": {
      "main": [
        [
          {
            "node": "Split Itens",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop": {
      "main": [
        [
          {
            "node": "Execute Core",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Itens": {
      "main": [
        [
          {
            "node": "Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Media": {
      "main": [
        [
          {
            "node": "Switch 02",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 02": {
      "main": [
        [
          {
            "node": "Transcription",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Convert PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset List": {
      "main": [
        [
          {
            "node": "Chatwoot Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Final List 2": {
      "main": [
        [
          {
            "node": "Switch 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Final List 1": {
      "main": [
        [
          {
            "node": "Parse JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cooldown": {
      "main": [
        [
          {
            "node": "Get List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation 2": {
      "main": [
        []
      ]
    },
    "Consumer": {
      "main": [
        [
          {
            "node": "Get Vars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 3": {
      "main": [
        [
          {
            "node": "No Operation ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Reset List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Input": {
      "main": [
        [
          {
            "node": "Main Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter": {
      "ai_languageModel": [
        []
      ]
    },
    "Get Vars": {
      "main": [
        [
          {
            "node": "Downtime",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert PDF": {
      "main": [
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transcription": {
      "main": [
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Core": {
      "main": [
        [
          {
            "node": "Get Final List 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear History": {
      "main": [
        [
          {
            "node": "Parse JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restart History": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Switch 2": {
      "main": [
        [
          {
            "node": "Download Media",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Keep Loop",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Switch 1": {
      "main": [
        [
          {
            "node": "No Operation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Final List 1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Cooldown",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 0": {
      "main": [
        [
          {
            "node": "Update History",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Add to List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Keep Loop": {
      "main": [
        [
          {
            "node": "Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update History": {
      "main": [
        [
          {
            "node": "Open Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chatwoot Output": {
      "main": [
        [
          {
            "node": "Add Register",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Register": {
      "main": [
        []
      ]
    },
    "Set Timer": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Knowledge Trigger": {
      "main": [
        [
          {
            "node": "Get Global Vars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Global Vars": {
      "main": [
        [
          {
            "node": "Process Docs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Docs": {
      "main": [
        []
      ]
    },
    "Vector Trigger": {
      "main": [
        [
          {
            "node": "Parse JSON 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON 2": {
      "main": [
        [
          {
            "node": "Split Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Vectors": {
      "main": [
        [
          {
            "node": "Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings": {
      "main": [
        [
          {
            "node": "Add Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Vectors": {
      "main": [
        []
      ]
    },
    "RAG Input": {
      "main": [
        [
          {
            "node": "Get History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retriever": {
      "ai_tool": [
        [
          {
            "node": "RAG Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter ": {
      "ai_languageModel": [
        []
      ]
    },
    "Mapping": {
      "main": [
        [
          {
            "node": "Switch 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation ": {
      "main": [
        [
          {
            "node": "Clear History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Downtime": {
      "main": [
        [
          {
            "node": "Mapping",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation 0": {
      "main": [
        [
          {
            "node": "Keep Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Trigger": {
      "main": [
        [
          {
            "node": "Get Dimensions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Dimensions": {
      "main": [
        [
          {
            "node": "Update Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG Agent": {
      "main": [
        [
          {
            "node": "No Operation 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get History": {
      "main": [
        [
          {
            "node": "RAG Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scheduling": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Scheduling Trigger": {
      "main": [
        [
          {
            "node": "Calendar Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clickup": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "RAG Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Main Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {},
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "e0960667-4af9-4620-aa5d-3855438e3516",
  "triggerCount": 7,
  "tags": []
}