{
  "createdAt": "2025-04-26T20:38:17.301Z",
  "updatedAt": "2025-05-22T19:33:50.635Z",
  "id": "LQ19C52Nja6cCqe5",
  "name": "[Anna] v2",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Core Input').item.json.body.mapping.parseJson().system.conversations_id }}",
        "tableName": "core_chat_histories",
        "contextWindowLength": "={{ $('Core Input').item.json.body.mapping.parseJson().system.context_window }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        1140,
        1580
      ],
      "id": "eba64d47-8f88-48d6-8b6a-bca4629deb8b",
      "name": "Memory",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "width": 780,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        960,
        1540
      ],
      "typeVersion": 1,
      "id": "d2a433ce-9c89-4fe2-9fbf-662169e66a0d",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.body.content || ' ' }}",
        "options": {
          "systemMessage": "=## PRIMEIRA MENSAGEM OBRIGAT√ìRIA\n**SEMPRE inicie TODA nova conversa se identificando como Anna da Beauty Show e perguntando o nome, se n√£o sabe, ou ent√£o confirmando o nome, se j√° tiver na mem√≥ria:**\n\n**Se N√ÉO souber o nome (varie as mensagens):**\n```\nOp√ß√£o 1: \"Oi! Tudo bem? üòä Sou a Anna da Beauty Show! Qual seu nome, por favor?\"\n\nOp√ß√£o 2: \"Oi! üòä Anna aqui, da Beauty Show! Como posso te chamar?\"\n\nOp√ß√£o 3: \"Ol√°! Sou a Anna da Beauty Show! Qual seu nome?\"\n```\n\n**Se J√Å souber o nome (varie as mensagens):**\n```\nOp√ß√£o 1: \"Oi [NOME]! Tudo bem? üòä Anna aqui, da Beauty Show!\"\n\nOp√ß√£o 2: \"Ol√° [NOME]! üòä √â a Anna da Beauty Show!\"\n\nOp√ß√£o 3: \"Oi [NOME]! Anna da Beauty Show aqui! üòä\"\n```\n\n**NUNCA use sauda√ß√µes gen√©ricas como:**\n- \"Como posso ajud√°-lo hoje?\"\n- \"Boa tarde! Como vai?\"  \n- \"Em que posso ajudar?\"\n\n**N√ÉO repita essa mensagem se j√° se apresentou na conversa.**\n\n## REGRA FUNDAMENTAL DE CONVERSA√á√ÉO\n**SEMPRE fa√ßa UMA pergunta de cada vez e AGUARDE a resposta antes de continuar.**\n**NUNCA envie m√∫ltiplas perguntas na mesma mensagem.**\n**VARIE suas mensagens para evitar parecer rob√≥tica.**\n**SEJA DIRETIVA: foque em qualificar rapidamente e ir para o fechamento.**\n**EVITE perguntas que tirem o foco da venda (experi√™ncias passadas, detalhes desnecess√°rios).**\n- Voc√™ √© Anna da empresa Beauty Show, especialista em t√©cnicas de venda e persuas√£o, respondendo clientes por WhatsApp.\n- Sua miss√£o principal √© vender ingressos dos congressos da Beauty Show (Make e Nails).\n- Objetivo secund√°rio: esclarecer d√∫vidas ou vender ingresso apenas para a feira.\n- **ESTRAT√âGIA**: Qualificar ‚Üí Criar Valor ‚Üí Testar Interesse ‚Üí Oferecer Desconto ‚Üí Fechar\n- Sempre mantenha tom amig√°vel, profissional e variado para evitar parecer rob√¥.\n- Nunca fale de assuntos que n√£o sejam sobre o evento Beauty Show.\n- Utilize portugu√™s correto, linguagem leve e profissional.\n\n## FLUXO CONVERSACIONAL ESTRAT√âGICO\n\n### 1. IDENTIFICA√á√ÉO R√ÅPIDA (Passo a passo)\n\n**PASSO 1 - Ap√≥s receber o nome:**\n```\n\"Prazer, [NOME]! Vi que voc√™ demonstrou interesse no nosso evento! \nVoc√™ est√° procurando informa√ß√µes sobre:\n- Congressos de Make ou Nails üíÑüíÖ\n- Ou apenas a feira mesmo? üé™\"\n```\n*[AGUARDE A RESPOSTA antes de continuar]*\n\n### 2. QUALIFICA√á√ÉO DIRETIVA (Foco no fechamento)\n*[Sempre aguarde a resposta antes de fazer a pr√≥xima pergunta]*\n\n**Se mencionar \"Congresso\":**\n- **DIRETO AO PONTO:** \"Qual √°rea voc√™ atua: Make ou Nails?\"\n- *[Aguarde resposta e v√° para apresenta√ß√£o com valor]*\n\n**Se mencionar \"Feira\":**\n- **APRESENTA√á√ÉO DA FEIRA:** \n```\n\"A Beauty Show √© incr√≠vel! S√£o 3 dias de pura imers√£o no mundo da beleza!\n\nVoc√™ vai ter acesso a:\n‚Ä¢ Marcas famosas e lan√ßamentos exclusivos\n‚Ä¢ Talks com Beauty Experts e influencers  \n‚Ä¢ Experimenta√ß√£o de produtos\n‚Ä¢ Networking com mais de 20 mil profissionais\n‚Ä¢ Aulas gratuitas e muito conte√∫do\n\nFoi criada para voc√™ ver, ser vista e fazer contatos para a vida toda! ‚ú®\n\nTem alguma d√∫vida sobre a feira?\"\n```\n- *[Aguarde resposta e esclare√ßa d√∫vidas]*\n\n**Se apenas \"informa√ß√µes\":**\n- **QUALIFICA√á√ÉO R√ÅPIDA:** \"Qual √°rea te interessa mais: maquiagem ou manicure?\"\n- *[Aguarde resposta e direcione para apresenta√ß√£o]*\n\n### 3. APRESENTA√á√ÉO COM VALOR (Criar desejo ANTES do pre√ßo)\n**Para Congresso de Make (ESGOTADO):**\n```\n\"Que pena! O Congresso de Make teve uma procura incr√≠vel e j√° esgotou! üòÖ\n\nMas n√£o se preocupe! Voc√™ ainda pode conseguir sua vaga atrav√©s das nossas embaixadoras, que t√™m uma cota especial reservada.\n\nImagina perder a chance de aprender com:\n‚Ä¢ Luana Charamba - que trabalha com artistas famosos\n‚Ä¢ Helder Marucci - especialista em noivas  \n‚Ä¢ Bia Sobral - marketing para maquiadores\n\nVou te passar o link das embaixadoras. Tem v√°rias espalhadas pelo Brasil:\nhttps://beautyshow.com.br/embaixadores/\n\nOu... que tal o Congresso de Nails? Ainda tenho vagas e √© igualmente incr√≠vel! üíÖ\"\n```\n\n**Para Congresso de Nails (DISPON√çVEL):**\n```\n\"Que demais! O Congresso de Nails ainda tem vagas Experience! \nOs melhores profissionais do pa√≠s em UM DIA s√≥.\n\nVoc√™ vai aprender com:\n‚Ä¢ Katiane Brito - unhas hiperrealistas\n‚Ä¢ Grazi Brum - t√©cnicas com alicate e brocas\n‚Ä¢ Michele Santos - empreendedorismo para crescer\n\nPlus: seu ingresso j√° inclui os 3 dias da feira \ncompleta! √â como ganhar um b√¥nus! ‚ú®\"\n```\n\n### 4. TESTE DE TEMPERATURA\n- \"Faz sentido pra voc√™, [NOME]?\"\n- \"Seria algo que te interessaria?\"\n- \"Consegue se imaginar l√° aprendendo essas t√©cnicas?\"\n\n### 5. GATILHO DE URG√äNCIA + DESCONTO (S√≥ ap√≥s interesse confirmado)\n```\n\"Olha, [NOME], aproveitando que voc√™ est√° aqui \ncomigo agora, consigo liberar um desconto especial \nde 20% que √© exclusivo para quem conversa direto conosco.\n\nMas √© por tempo limitado... \nQuer que eu j√° gere seu cupom?\"\n```\n\n### 6. FECHAMENTO SUAVE\n```\n\"√ìtimo! üéØ Vou gerar seu link personalizado.\n√â rapidinho, em 2 minutos voc√™ j√° tem sua vaga garantida! ‚ú®\"\n\n[Para Congresso de Nails Experience com desconto:]\nhttps://www.sympla.com.br/evento/beauty-show-2025---congresso-de-manicure/2914705?token=6f4a1c8e7b3d9f2a5e8c1d4b7a9f2c5e&referrer=beautyshow.com.br\n```\n\n## INFORMA√á√ïES DO EVENTO\n- **Data**: 24, 25 e 26 de maio de 2025\n- **Local**: Expo Center Norte, S√£o Paulo\n- **Hor√°rio**: 10h √†s 20h\n- **Congressos**: Make e Nails no dia 26/05\n- **Desconto**: 20% exclusivo para atendimento direto\n\n## STATUS DE DISPONIBILIDADE E VENDAS\n\n### ‚ö†Ô∏è Congresso de Maquiagem (Make) - ESGOTADO\n**Ambos os lotes (Experience e Black) est√£o esgotados**\n\n**Script para interessados em Make:**\n```\n\"[NOME], o Congresso de Make teve uma procura incr√≠vel e est√° esgotado! üòÖ\n\nMas n√£o se preocupe! Voc√™ ainda pode conseguir sua vaga atrav√©s das nossas embaixadoras, que t√™m uma cota especial reservada.\n\nElas ficam espalhadas pelo Brasil todo. Vou te passar o link para voc√™ ver qual fica mais pr√≥xima de voc√™:\n\nhttps://beautyshow.com.br/embaixadores/\n\nL√° voc√™ encontra contato direto e condi√ß√µes especiais! üéØ\"\n```\n\n### ‚úÖ Congresso de Manicure (Nails) - DISPON√çVEL\n**EXPERIENCE** (BLACK esgotado)\n- Certificado digital  \n- Entrada em todos os dias da feira\n- Kit do participante: bloco e caneta\n- **Valor**: 10√ó de R$36,70 ou R$367,00 √† vista\n- **Com desconto 20%**: 10√ó de R$29,36 ou R$293,60 √† vista\n\n**Link para venda (Experience com desconto):**\nhttps://www.sympla.com.br/evento/beauty-show-2025---congresso-de-manicure/2914705?token=6f4a1c8e7b3d9f2a5e8c1d4b7a9f2c5e&referrer=beautyshow.com.br\n\n**Script para quem quer Black de Nails:**\n```\n\"O Black de Nails tamb√©m est√° esgotado, mas tenho o Experience dispon√≠vel com 20% de desconto!\n\nSe voc√™ realmente quer o Black, pode tentar com nossas embaixadoras:\nhttps://beautyshow.com.br/embaixadores/\n\nMas o Experience tem praticamente os mesmos benef√≠cios, s√≥ n√£o tem o certificado impresso e kit completo. O conte√∫do √© exatamente o mesmo! \n\nQuer que eu gere seu cupom Experience com desconto?\"\n```\n\n### üé™ Feira Beauty Show - SEM DESCONTO\n**Para quem quer apenas a feira:**\n```\n\"A entrada da feira n√£o tem desconto promocional, mas o valor √© super acess√≠vel!\n\nAqui est√° o link direto:\nhttps://www.sympla.com.br/evento/beauty-show-2025/2914704?referrer=beleza.beautyfair.com.br\n\nS√£o 3 dias incr√≠veis de networking, marcas famosas e muito conte√∫do gratuito! ‚ú®\"\n```\n\n## MANEJO DE OBJE√á√ïES\n- **Pre√ßo**: \"Entendo sua preocupa√ß√£o. Muitos profissionais veem como investimento que traz retorno r√°pido. E com o desconto especial, ficou ainda mais acess√≠vel! üí∏\"\n- **Tempo**: \"Justamente por isso o Beauty Show foi planejado em 3 dias intensivos! Em pouco tempo, voc√™ recebe conte√∫do que economizaria meses! ‚ö°\"\n- **Localiza√ß√£o**: \"O Expo Center Norte √© super acess√≠vel! Muitos v√™m de fora e consideram o networking um grande diferencial! üåü\"\n\n## MAPEAMENTO DE LEADS (Para quem n√£o compra)\n- Como conheceu o evento?\n- Nome completo\n- √Årea de atua√ß√£o (Make, Nails ou ambos)\n- J√° participou de eventos de capacita√ß√£o?\n- **Encerramento**: \"Sem problemas! üòâ Estou por aqui se precisar. Caso decida garantir sua vaga com desconto, √© s√≥ me chamar! ‚ú®\"\n\n## LIMITA√á√ïES\n- N√£o falar sobre outros assuntos fora do Beauty Show\n- Redirecionar educadamente: \"Essa quest√£o n√£o faz parte do nosso escopo, mas estou aqui para ajudar com tudo sobre o Beauty Show! üòâ\"\n\n## BASE DE CONHECIMENTO COMPLETA\n\n### CONGRESSOS DETALHADOS\n\n#### Congresso de Maquiagem (Make) - 26/05 - ESGOTADO\n**Proposta:** Fique por dentro das novas tend√™ncias, t√©cnicas e produtos de maquiagem com os profissionais mais admirados do Brasil.\n\n**Incluso na inscri√ß√£o:**\n- Experi√™ncia presencial em todas as palestras\n- Acesso aos 3 dias da feira Beauty Show (24 a 26 de maio) \n- Desconto de 5% nos Congressos Beauty Fair 2025 (6 a 7 de setembro)\n- Acesso Super App Beauty Fair (agenda, programa√ß√£o, not√≠cias, networking)\n\n**Palestrantes:**\n- **Bia Sobral**: \"Potencialize seus resultados com estrat√©gias de marketing para maquiadores sem perder sua ess√™ncia no processo.\"\n- **Helder Marucci**: \"Desvende os segredos de atendimento √† noivas com maquiagem glam e atemporal.\"\n- **Luana Charamba**: \"A maquiagem que transcende pinc√©is: a vis√£o da visagista que conquistou artistas e transformou vidas ao redor do mundo.\"\n- **Rachel Peres | KOHLL BEAUTY**: \"Eleve o n√≠vel do seu atendimento e prepare uma pele com efeito transl√∫cido de alt√≠ssima resist√™ncia.\"\n- **Raphael Lessa**: \"Aprenda a 'pele borrifadora' √† prova d'√°gua e atrito em pele preta.\"\n\n#### Congresso de Manicure (Nails) - 26/05 - DISPON√çVEL\n**Proposta:** Conte√∫do de valor para quem trabalha ou gostaria de empreender. Inova√ß√µes, dicas de sa√∫de e tudo sobre o mercado de est√©tica e cuidado das unhas.\n\n**Incluso na inscri√ß√£o:**\n- Experi√™ncia presencial em todas as palestras\n- Acesso aos 3 dias da feira Beauty Show (24 a 26 de maio)\n- Desconto de 5% nos Congressos Beauty Fair 2025 (6 a 7 de setembro) \n- Acesso Super App Beauty Fair (agenda, programa√ß√£o, not√≠cias, networking)\n\n**Palestrantes:**\n- **Grazi Brum | STALEKS**: \"Manicure Combinada ‚Äì A t√©cnica perfeita unindo alicate, tesoura e brocas!\"\n- **Katiane Brito**: \"O Maravilhoso Mundo das Unhas ‚Äì Sucesso e unhas hiperrealistas!\"\n- **Michele Santos | FORMS**: \"Empreendedorismo para Crescer ‚Äì Inova√ß√£o e estrat√©gias para impulsionar seu neg√≥cio de unhas!\"\n- **Talita Costa | REAL LOVE**: \"Top Gel com Mold F1 ‚Äì Alongamento de unhas de forma f√°cil e r√°pida!\"\n- **Let√≠cia Camara**: \"Manicure de Valor ‚Äì Aprenda a se destacar e ser reconhecida na profiss√£o!\"\n- **Altair Hottes | V√íLIA**: \"A Qu√≠mica dos Produtos ‚Äì Descubra a ci√™ncia por tr√°s das f√≥rmulas!\"\n- **Charlany Vieira | CUCCIO**: \"SPA dos P√©s Natural√© ‚Äì Beleza e bem-estar com o poder da natureza!\"\n\n### FEIRA BEAUTY SHOW\n\n**Por que ir:**\n- **NETWORKING**: \"Beauty Show foi criado para ver, ser vista e fazer contatos para o resto da vida. Na primeira edi√ß√£o, foram mais de 20 mil participantes que se somaram √†s principais marcas, Beauty Experts e Influencers de beleza do pa√≠s.\"\n- **ATUALIZA√á√ÉO**: \"Fundamental para os profissionais e uma oportunidade √∫nica para quem ama aprender sobre beleza. No Beauty Show, voc√™ ter√° acesso ao que existe de mais inovador diretamente com os melhores.\"\n- **EXPOSI√á√ÉO**: \"Quer marcas famosas? Aqui tem. Produtos top? N√£o podem faltar. Fotos com a sua influencer favorita? Com certeza. Nossa programa√ß√£o √© completa, feita para proporcionar encontros inesquec√≠veis.\"\n\n**Destaques:**\n- Talks com Beauty Experts\n- Experimenta√ß√£o de produtos  \n- Congressos & Aulas Gr√°tis\n\n### HOSPEDAGEM (Para quem perguntar)\n\n**HOTEL INTERCITY ANHEMBI**\n- Endere√ßo: R. Marambaia, 357 - Casa Verde, S√£o Paulo/SP\n- Pr√≥ximo ao Expo Center Norte\n- Facilidades: Piscina climatizada, academia 24h, caf√© da manh√£\n- Tarifas: Individual R$550 + 5% ISS / Duplo R$590 + 5% ISS / Triplo R$720 + 5% ISS\n\n**WYNDHAM GARDEN SP CONVENTION NORTEL**  \n- Endere√ßo: Av. Luiz Dumont Villares, 400 - Santana, S√£o Paulo/SP\n- Facilidades: Piscina, academia, caf√© da manh√£\n- **CUPOM BEAUTYSHOW20: 20% de desconto na tarifa**\n\n**RAMADA ENCORE SP TIRADENTES**\n- Endere√ßo: Av. Tiradentes, 826 - Centro Hist√≥rico, S√£o Paulo/SP\n- Facilidades: Caf√© da manh√£\n- Tarifas: Individual R$450 + 5% ISS / Duplo R$490 + 5% ISS\n\n### MANEJO DE OBJE√á√ïES\n- **Pre√ßo**: \"Entendo sua preocupa√ß√£o. Muitos profissionais veem o evento como um investimento que traz retorno r√°pido. E com o desconto especial, ficou ainda mais acess√≠vel! üí∏\"\n- **Tempo**: \"Justamente por isso o Beauty Show foi planejado em 3 dias intensivos! Em pouco tempo, voc√™ recebe conte√∫do que economizaria meses! ‚ö°\"\n- **Localiza√ß√£o**: \"O Expo Center Norte √© super acess√≠vel! Muitos v√™m de fora e consideram o networking um grande diferencial! üåü\"\n\n## FRASES DE IMPACTO\n- \"Essa pode ser a virada de chave da sua carreira! üöÄ\"\n- \"Tr√™s dias intensivos com os maiores nomes da Make e Nails! üíÑüíÖ\"\n- \"Oportunidade √∫nica para acelerar sua jornada no mundo da beleza! üåü\"\n- \"√â como ter uma p√≥s-gradua√ß√£o em beleza em 3 dias! üìö\"",
          "passthroughBinaryImages": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        1260,
        1320
      ],
      "id": "caa20e44-11ed-4bd9-84d0-6babe8bf6317",
      "name": "Main Agent"
    },
    {
      "parameters": {
        "operation": "push",
        "list": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "messageData": "={{ JSON.stringify({\n    'content': $('Mapping').first().json.chatwoot.content,\n    'data_url': $('Mapping').first().json.chatwoot.data_url,\n    'timestamp': $now,\n    'message_id': $('Mapping').first().json.chatwoot.message_id\n}) }}",
        "tail": true
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -300,
        680
      ],
      "id": "f38efd9f-18ce-4c0c-98b4-7983a19e7de0",
      "name": "Add to List",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -100,
        680
      ],
      "id": "2b512577-c712-425a-b6bd-1b0d6841e09f",
      "name": "Get List",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        300,
        480
      ],
      "id": "31dc41d2-ba03-4e7a-b3d8-0251d3df8e8a",
      "name": "No Operation"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"data\": {{ \n    (() => {\n      const sourceNodeName = $('Get Final List 2').isExecuted ? 'Get Final List 2' : $prevNode.name;\n      const data = $(sourceNodeName).first().json.data;\n      const uniqueIds = new Set();\n      const messages = [];\n\n      data.reduce((_, buffer) => {\n        const parsed = JSON.parse(buffer);\n        if (!uniqueIds.has(parsed.message_id)) {\n          uniqueIds.add(parsed.message_id);\n\n          let index = messages.findIndex(msg => msg.message_id > parsed.message_id);\n          if (index === -1) index = messages.length;\n          messages.splice(index, 0, parsed);\n        }\n      }, []);\n\n      return messages.reduce((acc, msg) => {\n        delete msg.message_id;\n        acc.push({ content: msg, loop_reset: true });\n        return acc;\n      }, []);\n\n    })()\n  }}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        700,
        780
      ],
      "id": "56c62db7-ba58-43d5-a741-90a3f788e2fb",
      "name": "Parse JSON"
    },
    {
      "parameters": {
        "fieldToSplitOut": "data",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -1300,
        1300
      ],
      "id": "f6938961-3079-4917-9a71-afa7cdee37c9",
      "name": "Split Itens"
    },
    {
      "parameters": {
        "options": {
          "reset": "={{ $json.loop_reset }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -1100,
        1300
      ],
      "id": "2557f44f-a46d-4be9-9fbb-54445cd3adc5",
      "name": "Loop"
    },
    {
      "parameters": {
        "url": "={{ $json.content.data_url }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -700,
        1300
      ],
      "id": "287e6687-337c-4e05-bc09-c3c3a5708a3e",
      "name": "Download Media"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{\n  $binary.data?.fileExtension === 'oga' \n    ? 0 \n    : !$binary.data || ['png', 'jpg', 'jpeg'].includes($binary.data.fileExtension)\n      ? 1 \n      : $binary.data.fileExtension === 'pdf' \n        ? 2 \n        : 3\n}}"
      },
      "id": "fafc6665-bdb2-4bc8-8e73-3e97fd6ecee7",
      "name": "Switch 02",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -500,
        1300
      ]
    },
    {
      "parameters": {
        "content": "",
        "height": 600,
        "width": 2300,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1400,
        380
      ],
      "typeVersion": 1,
      "id": "3890e33b-6500-44d7-8045-200c46b52135",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "",
        "height": 1360,
        "width": 2340,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1420,
        360
      ],
      "typeVersion": 1,
      "id": "235863e6-541c-44bf-a7a1-6487b692c76e",
      "name": "Sticky Note2"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1620,
        1320
      ],
      "id": "e58ddba9-7d2d-426a-a322-9e4d7de3c2df",
      "name": "No Operation 2"
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}"
      },
      "id": "384e7cbb-da65-4ed7-b144-3fd3b80f402b",
      "name": "Reset List",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        300,
        1300
      ],
      "notesInFlow": false,
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -100,
        1100
      ],
      "id": "a58746f8-dcd6-4e0d-afb9-76120bdd9e61",
      "name": "Get Final List 2",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        500,
        580
      ],
      "id": "68f9ccba-54cc-45d3-b489-e83cdde81ec8",
      "name": "Get Final List 1",
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "=6"
      },
      "id": "90e3fce7-6625-46c9-9b27-4cf2ced01be5",
      "name": "Reset List 2",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        700,
        580
      ],
      "notesInFlow": false,
      "credentials": {
        "redis": {
          "id": "Yj8Yu3a3AZgluvcL",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "amount": "={{ \n  $('Mapping').first().json.system.cooldown - $now.diffTo(\n    JSON.parse($('Get List').item.json.data.last()).timestamp,\n    'seconds'\n  )\n}}"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        300,
        680
      ],
      "id": "4b699b17-228b-4dd1-ad1f-f1ce74a09ea4",
      "name": "Cooldown",
      "webhookId": "816f562a-62f9-4197-b5da-004f01f371fe"
    },
    {
      "parameters": {
        "queue": "main-n8n",
        "options": {
          "acknowledge": "executionFinishesSuccessfully",
          "jsonParseBody": true,
          "onlyContent": true
        }
      },
      "type": "n8n-nodes-base.rabbitmqTrigger",
      "typeVersion": 1,
      "position": [
        -1300,
        580
      ],
      "id": "bf8a1e4f-8f98-41dc-8d9a-d286086c9630",
      "name": "Consumer",
      "credentials": {
        "rabbitmq": {
          "id": "zbqB1qaBGZEpzbgR",
          "name": "RabbitMQ account"
        }
      }
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{ \n  $node[\"Get Final List 2\"].runIndex === 0\n    ? (\n        JSON.parse($('Get Final List 1').first().json.data.last()).timestamp ===\n        JSON.parse($('Get Final List 2').first().json.data.last()).timestamp\n      ) ? 1 : 0\n    : (\n          JSON.parse($('Get Final List 2').all(0, $runIndex - 0).first().json.data.last()).timestamp ===\n          JSON.parse($('Get Final List 2').all(0, $runIndex - 1).first().json.data.last()).timestamp\n      ) ? 1 : 0\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        100,
        1200
      ],
      "id": "a2a6018c-f2d1-4e0d-89d9-189183c39b8d",
      "name": "Switch 3"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "main",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        1060,
        1320
      ],
      "id": "a84bdb0a-c2f0-4ad2-919a-cd2a8f39c74b",
      "name": "Core Input",
      "webhookId": "d503e6f9-0989-42d5-a598-e268b20c3182"
    },
    {
      "parameters": {
        "model": "={{ $json.body.mapping.parseJson().system.model }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        1020,
        1580
      ],
      "id": "25612fc6-0adb-47ea-8f4f-5c8e1f106a9d",
      "name": "OpenRouter",
      "credentials": {
        "openRouterApi": {
          "id": "fbVI3oy00ZqZFPfH",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 860,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        960,
        1220
      ],
      "id": "79cb0a5a-0fda-4787-bd59-a7a8817af68c",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "",
        "height": 520,
        "width": 900,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        940,
        1200
      ],
      "typeVersion": 1,
      "id": "325c8cd9-46f0-4a59-9542-0a71c02c3ced",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "content": "",
        "height": 700,
        "width": 2300,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1400,
        1000
      ],
      "typeVersion": 1,
      "id": "3aecf5ab-87b5-4291-9d18-5eebbc1928d8",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=DO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 \n    FROM ai_agents\n    WHERE account_id = {{ $json.body.account.id }}\n      AND {{ $json.body.inbox.id }} = ANY(string_to_array(inboxes_ids, ',')::int[])\n  ) THEN\n    RAISE EXCEPTION 'Nenhum AI Agent encontrado para a conta % e inbox %', {{ $json.body.account.id }}, {{ $json.body.inbox.id }};\n  END IF;\nEND $$;\nWITH\n-- 1) Seleciona o AI Agent associado √† conta e √† caixa de entrada\nselected_ai AS (\n    SELECT ai.*\n    FROM ai_agents ai\n    WHERE ai.account_id = {{ $json.body.account.id }}\n      AND {{ $json.body.inbox.id }} = ANY(string_to_array(ai.inboxes_ids, ',')::int[])\n    LIMIT 1\n),\n-- 2) Seleciona as vari√°veis globais (assume-se que seja um singleton)\nselected_gv AS (\n    SELECT *\n    FROM global_vars\n    LIMIT 1\n),\n-- 3) Faz o upsert do usu√°rio: insere se n√£o existir, caso contr√°rio, ignora\nupsert_user AS (\n    INSERT INTO users (id, date_created, picture_url, username, phone, ai_agent)\n    SELECT {{ $json.body.sender.id }}, NOW(), '{{ $json.body.sender.avatar }}', '{{ $json.body.sender.name }}', '{{ $json.body.sender.phone_number }}', ai.id\n    FROM selected_ai ai\n    WHERE ai.id IS NOT NULL\n    ON CONFLICT (id) DO NOTHING\n    RETURNING *\n),\n-- 4) Seleciona o usu√°rio (rec√©m-inserido ou existente)\nfinal_user AS (\n    SELECT * FROM upsert_user\n    UNION\n    SELECT * FROM users\n    WHERE id = {{ $json.body.sender.id }}\n),\n-- 5) Cria uma nova conversa apenas se n√£o existir nenhuma para esse usu√°rio\nmaybe_new_conversation AS (\n    INSERT INTO conversations (id, user_id, date_created)\n    SELECT gen_random_uuid(), final_user.id, NOW()\n    FROM final_user\n    WHERE NOT EXISTS (\n        SELECT 1\n        FROM conversations\n        WHERE user_id = final_user.id\n    )\n    RETURNING *\n),\n-- 6) Seleciona a √∫ltima conversa do usu√°rio (nova ou existente)\nlast_conversation AS (\n    SELECT * FROM maybe_new_conversation\n    UNION\n    SELECT * FROM conversations\n    WHERE user_id = (SELECT id FROM final_user)\n    ORDER BY date_created DESC\n    LIMIT 1\n),\n-- 7) Seleciona os hist√≥ricos de chat (simplificado)\nchat_histories AS (\n    SELECT ch.*\n    FROM core_chat_histories ch\n    JOIN last_conversation lc ON ch.session_id = lc.id\n    ORDER BY ch.date_created DESC\n    LIMIT (SELECT context_window FROM selected_ai)\n),\n-- 8) Seleciona os calend√°rios (scheduling) associados ao usu√°rio\nuser_calendars AS (\n    SELECT sch.*\n    FROM event_history_user sch\n    WHERE sch.user_id = (SELECT id FROM final_user)\n),\n-- 9) Seleciona os eventos do usu√°rio a partir da data atual\nuser_events AS (\n    SELECT eh.*\n    FROM event_history eh\n    JOIN user_calendars uc ON eh.session_id = uc.id\n    WHERE eh.date >= CURRENT_DATE\n    ORDER BY eh.date ASC  -- Ordenando cronologicamente a partir de hoje\n)\n-- 10) Retorna os resultados no formato JSON\nSELECT\n    (SELECT row_to_json(ai) FROM selected_ai ai) AS ai_agents,\n    (SELECT row_to_json(gv) FROM selected_gv gv) AS global_vars,\n    (SELECT row_to_json(final_user) FROM final_user) AS users,\n    (SELECT row_to_json(last_conversation) FROM last_conversation) AS conversations,\n    (SELECT json_agg(row_to_json(ch)) FROM chat_histories ch) AS core_chat_histories,\n    (SELECT COALESCE(json_agg(evt), '[]'::json) FROM user_events evt) AS events;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1100,
        580
      ],
      "id": "5dc52430-9223-4274-8491-de1754c40d62",
      "name": "Get Vars",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://{{ $('Mapping').item.json.system.stirling_pdf_service }}:8080/api/v1/convert/pdf/img",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-KEY",
              "value": "={{ $('Mapping').first().json.system.stirling_pdf_key }}"
            },
            {
              "name": "accept",
              "value": "*/*"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "imageFormat",
              "value": "jpg"
            },
            {
              "name": "singleOrMultiple",
              "value": "single"
            },
            {
              "name": "colorType",
              "value": "color"
            },
            {
              "name": "dpi",
              "value": "80"
            },
            {
              "parameterType": "formBinaryData",
              "name": "fileInput",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "f1ebf6a5-de30-4492-8e13-943761e79db6",
      "name": "Convert PDF",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -300,
        1400
      ],
      "notesInFlow": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/audio/transcriptions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $('Mapping').first().json.system.openai_key }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "whisper-1"
            },
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "d3c25024-7b73-4ab9-8880-981c27068ba9",
      "name": "Transcription",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -300,
        1200
      ],
      "notesInFlow": true
    },
    {
      "parameters": {
        "content": "Fluxo de processamento principal",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1380,
        400
      ],
      "id": "a6d3c581-b365-4c04-bbba-74261115544a",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\nconst mappingData = $('Mapping').first().json; // Obt√©m todo o conte√∫do de 'Mapping'\nconsole.log(\"Mapping Data:\", mappingData);\n\nconst baseWebhookUrl = `http://${mappingData.system.n8n_webhook_service}:5678/webhook/`;\nconst finalWorkflowPath = mappingData.system.workflow_path;\nconst defaultFinalUrl = `${baseWebhookUrl}${finalWorkflowPath}`;\n\nconst formData = new FormData();\n\n// Unifica os valores de \"content\" com quebra de linha dupla\nconst unifiedContent = items\n  .map(item => item.json.content)\n  .filter(content => content) // Remove itens vazios ou undefined\n  .join('\\n\\n');\nconsole.log(\"Unified Content:\", unifiedContent);\n\n// Monta o JSON separado para o corpo da requisi√ß√£o\nconst jsonData = {\n  content: unifiedContent,\n  mapping: mappingData\n};\n\n// Adiciona os dados JSON ao FormData\nformData.append('content', jsonData.content);\nformData.append('mapping', JSON.stringify(jsonData.mapping));\n\n// Adiciona arquivos bin√°rios mantendo os nomes originais\nitems.forEach((item) => {\n  if (item.binary) {\n    Object.keys(item.binary).forEach((key) => {\n      const file = item.binary[key];\n      formData.append(key, Buffer.from(file.data, 'base64'), {\n        filename: file.fileName || key,\n        contentType: file.mimeType,\n      });\n    });\n  }\n});\n\nif (mappingData.system.enabled_rag === true || mappingData.system.enabled_rag === 'true') {\n  console.log(\"RAG is enabled. Sending request to the RAG endpoint first.\");\n  const ragUrl = `${baseWebhookUrl}rag`;\n  console.log(`Sending RAG request to: ${ragUrl}`);\n\n  return axios.post(ragUrl, formData, { headers: formData.getHeaders() })\n    .then(ragResponse => {\n      console.log(\"RAG Response received:\", ragResponse.data);\n      // Ajuste: obter o valor de \"output\" em vez de \"rag_return\"\n      const rag_return = ragResponse.data.output;\n      jsonData.rag_return = rag_return; // Inclui o retorno do RAG no JSON\n\n      // Reconstroi o FormData com os dados atualizados (incluindo rag_return)\n      const finalFormData = new FormData();\n      finalFormData.append('content', jsonData.content);\n      finalFormData.append('mapping', JSON.stringify(jsonData.mapping));\n      finalFormData.append('rag_return', rag_return);\n      items.forEach((item) => {\n        if (item.binary) {\n          Object.keys(item.binary).forEach((key) => {\n            const file = item.binary[key];\n            finalFormData.append(key, Buffer.from(file.data, 'base64'), {\n              filename: file.fileName || key,\n              contentType: file.mimeType,\n            });\n          });\n        }\n      });\n      \n      // Recupera a URL final do mapping; se n√£o existir, usa a URL padr√£o\n      let finalUrl = mappingData.system.rag_return;\n      if (!finalUrl) {\n        console.error(\"mappingData.system.rag_return is undefined. Using default final URL instead.\");\n        finalUrl = defaultFinalUrl;\n      }\n      console.log(`Mapping system.rag_return value: \"${finalUrl}\"`);\n      console.log(\"Sending final request to the RAG final endpoint...\");\n\n      return axios.post(finalUrl, finalFormData, { headers: finalFormData.getHeaders() })\n        .then(finalResponse => {\n          console.log(\"Final Response received:\", finalResponse.data);\n          return [{\n            json: {\n              rag: ragResponse.data,\n              final: finalResponse.data,\n              logs: [\n                `RAG request sent to: ${ragUrl}`,\n                `RAG response received with output: ${rag_return}`,\n                `Final request sent to: ${finalUrl}`,\n                `Final response received successfully.`\n              ]\n            }\n          }];\n        })\n        .catch(finalError => {\n          console.error(`Final request error for URL (${finalUrl}):`, finalError.message);\n          return [{\n            json: {\n              error: finalError.message,\n              rag: ragResponse.data,\n              logs: [\n                `RAG request sent to: ${ragUrl}`,\n                `RAG response received with output: ${rag_return}`,\n                `Attempted final request to: ${finalUrl}`,\n                `Final request error: ${finalError.message}`\n              ]\n            }\n          }];\n        });\n    })\n    .catch(ragError => {\n      console.error(\"RAG request error:\", ragError.message);\n      return [{\n        json: {\n          error: ragError.message,\n          logs: [\n            `RAG request sent to: ${baseWebhookUrl}rag`,\n            `RAG request error: ${ragError.message}`\n          ]\n        }\n      }];\n    });\n} else {\n  console.log(\"RAG is not enabled. Sending request directly to the default final URL:\", defaultFinalUrl);\n  return axios.post(defaultFinalUrl, formData, { headers: formData.getHeaders() })\n    .then(response => {\n      console.log(\"Final Response received:\", response.data);\n      return [{\n        json: {\n          final: response.data,\n          logs: [\n            `Final request sent to: ${defaultFinalUrl}`,\n            `Final response received successfully.`\n          ]\n        }\n      }];\n    })\n    .catch(error => {\n      console.error(\"Final request error:\", error.message);\n      return [{\n        json: {\n          error: error.message,\n          logs: [\n            `Final request error for URL (${defaultFinalUrl}): ${error.message}`\n          ]\n        }\n      }];\n    });\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -900,
        1100
      ],
      "id": "c554b7b7-9e86-4318-8c13-b220a7bb8b46",
      "name": "Execute Core"
    },
    {
      "parameters": {
        "content": "Fluxo Core, respons√°vel pelo processamento da AI",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1000,
        1180
      ],
      "id": "ca510ab9-7adf-4bb7-ba22-1710dc1295f9",
      "name": "Sticky Note14"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Obt√©m o √∫ltimo item da tabela conversations com base no campo 'date_created'\nWITH last_conversation AS (\n    SELECT id \n    FROM conversations\n    WHERE user_id = {{ $('Mapping').first().json.chatwoot.contact_id }}\n    ORDER BY date_created DESC\n    LIMIT 1\n),\n\n-- Obt√©m os √∫ltimos dois registros da tabela core_chat_histories com base no session_id\nlast_two_chat_histories AS (\n    SELECT id \n    FROM core_chat_histories\n    WHERE session_id = (SELECT id FROM last_conversation)\n    ORDER BY id DESC\n    LIMIT 2\n)\n\n-- Deleta os √∫ltimos dois registros encontrados\nDELETE FROM core_chat_histories\nWHERE id IN (SELECT id FROM last_two_chat_histories);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        500,
        1100
      ],
      "id": "b39ad79d-99b1-48ce-8fde-ee081dd48322",
      "name": "Clear History",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "name": "restart_history",
        "description": "=Invoque essa tool para iniciar uma nova conversa para o user, assim ignorando o hist√≥rico passado. Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\n\n// Converte o mapeamento recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usu√°rio √© admin; caso contr√°rio, retorna erro\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usu√°rio n√£o autorizado.\" });\n}\n\n/**\n * Fun√ß√£o que espera pelo tempo especificado.\n * @param {number} ms - Milissegundos a aguardar.\n * @returns {Promise<void>}\n */\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Fun√ß√£o para enviar a requisi√ß√£o para criar uma conversa no Directus.\n * Tenta at√© 3 vezes em caso de falha, com delay de 1 segundo entre as tentativas.\n * @returns {Promise<object>} - Objeto com sucesso ou erro.\n */\nasync function sendRequest() {\n  const url = `http://${mapping.system.directus_service}:8055/items/conversations`;\n  const data = {\n    user_id: mapping.chatwoot.contact_id,\n    date_created: new Date().toISOString()\n  };\n  const headers = {\n    Authorization: `Bearer ${mapping.system.directus_token}`,\n    'Content-Type': 'application/json'\n  };\n\n  let attempt = 0;\n  let lastError = null;\n\n  while (attempt < 3) {\n    try {\n      const response = await axios.post(url, data, { headers });\n      console.log(`Requisi√ß√£o realizada com sucesso na tentativa ${attempt + 1}.`);\n      return { success: true, data: response.data };\n    } catch (error) {\n      attempt++;\n      lastError = error;\n      console.error(`Tentativa ${attempt} falhou:`, error.response ? error.response.data : error.message);\n      if (attempt < 3) {\n        console.log(\"Aguardando 1 segundo antes da nova tentativa...\");\n        await delay(1000);\n      }\n    }\n  }\n  \n  return { success: false, error: lastError.response ? lastError.response.data : lastError.message };\n}\n\nreturn sendRequest().then(result => JSON.stringify(result));"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1260,
        1580
      ],
      "id": "2c8d4091-4798-44a3-89e5-d44ee314d784",
      "name": "Restart History"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{\n  $json.content.data_url?.match(/\\.(oga|png|jpg|jpeg|txt|pdf)$/i) !== null \n  && !!$json.content.data_url \n    ? 0 \n    : !!$json.content.content \n      ? 1\n      : 2\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -900,
        1500
      ],
      "id": "d7a5fbdf-6e60-4d93-8d49-6c16ce8f5965",
      "name": "Switch 2"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{ \n  $('Add to List').item.json.chatwoot.message_id !==\n  JSON.parse($('Get List').item.json.data.first()).message_id\n    ? 0\n    : $now.minus($('Mapping').first().json.system.cooldown, 'seconds').diffTo(\n        JSON.parse($('Get List').item.json.data.last()).timestamp,\n        'seconds'\n      ) >= 0\n      ? 1\n      : 2\n}}\n\n\n\n"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        100,
        580
      ],
      "id": "be373b6a-08f3-45d3-b4b5-4bcaacf1f5fe",
      "name": "Switch 1"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{\n  (\n    $('Mapping').first().json.chatwoot.channel !== 'WhatsApp Web Group' ||\n    (\n      $('Mapping').first().json.system.allow_whatsapp_groups === 'always_enabled' ||\n      (\n        $('Mapping').first().json.system.allow_whatsapp_groups === 'enabled_when_mentioned' &&\n        $('Mapping').first().json.system.agent_mentioned\n      )\n    )\n  )\n  &&\n  {\n    'pending_status': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact' &&\n      $('Mapping').first().json.chatwoot.conversation_status === 'pending',\n\n    'all_status': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact',\n\n    'not_assigned': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact' &&\n      !$('Mapping').first().json.chatwoot.assignee\n  }[$('Mapping').first().json.system.enabled_condition]\n    ? 1\n    : 0\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -500,
        580
      ],
      "id": "fa7fce13-38d7-435a-bc81-1e7aa9471bf9",
      "name": "Switch 0"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7cade77f-2498-4515-991a-cbe2d5ffe67a",
              "name": "content",
              "value": "={{\n  $json.content?.content \n  || $json.text \n  || (\n    $('Switch 2').item.json.content.data_url.endsWith('.txt') \n      ? $json.data + '\\n\\n' + $('Switch 2').item.json.content?.content \n      : null\n  )\n}}",
              "type": "string"
            },
            {
              "id": "e8da4202-58a2-4990-9e36-9a56f18c7263",
              "name": "loop_reset",
              "value": false,
              "type": "boolean"
            }
          ]
        },
        "includeOtherFields": true,
        "include": "selected",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        100,
        1500
      ],
      "id": "8e0bfa01-3df5-4f79-a805-9cada188d368",
      "name": "Keep Loop"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "core_chat_histories",
          "mode": "list",
          "cachedResultName": "core_chat_histories"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "date_created": "={{ $now }}",
            "session_id": "={{ $json.system.conversations_id }}",
            "message": "={{ JSON.parse(JSON.stringify({\n  \"type\": \"human\",\n  \"content\": $json.chatwoot.content,\n  \"user_name\": $json.chatwoot.user_name\n})) }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "message",
              "displayName": "message",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "date_created",
              "displayName": "date_created",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -300,
        480
      ],
      "id": "995200dd-f24d-4c62-86cf-459a81b1805b",
      "name": "Update History",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\nconst mapping = $('Mapping').first().json;\nconst { system, chatwoot } = mapping;\n\nif (\n  system.allow_human_interruption &&\n  system.enabled_condition === 'pending_status' &&\n  chatwoot.sender_type === 'User' &&\n  chatwoot.conversation_status !== 'open'\n) {\n  const chatwootService = system.chatwoot_service;\n  return axios.post(\n    `http://${chatwootService}:3000/api/v1/accounts/${chatwoot.account_id}/conversations/${chatwoot.conversation_id}/toggle_status`,\n    { status: \"open\" },\n    { headers: { api_access_token: chatwoot.bot_token } }\n  )\n  .then(res => [{ json: res.data }])\n  .catch(err => [{ json: { error: err.response?.data || err.message } }]);\n}\n\nreturn [{ json: { message: \"Nenhuma a√ß√£o realizada\" } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -100,
        480
      ],
      "id": "75d385e0-847d-406c-b433-32be456f9bbd",
      "name": "Open Conversation"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\n// Array para armazenar logs detalhados\nconst detailedLogs = [];\n\n// Fun√ß√µes de log aprimoradas\nfunction logMessage(msg) {\n  console.log(msg);\n  detailedLogs.push({ type: 'info', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logError(msg) {\n  console.error(msg);\n  detailedLogs.push({ type: 'error', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logRequest(method, url, headers, payload) {\n  detailedLogs.push({\n    type: 'request',\n    method,\n    url,\n    headers,\n    payload,\n    timestamp: new Date().toISOString()\n  });\n}\n\nfunction logResponse(status, data) {\n  detailedLogs.push({\n    type: 'response',\n    status,\n    data,\n    timestamp: new Date().toISOString()\n  });\n}\n\n// ------------------------------\n// Configura√ß√µes Gerais\n// ------------------------------\nconst MIN_TOTAL_LENGTH = 50;               // Texto menor que 50 caracteres: enviar inteiro.\nconst MIN_SEGMENT_LENGTH = 20;             // Segmentos menores que 20 caracteres ser√£o mesclados.\nconst DESIRED_TEXT_SEGMENT_SIZE = 200;       // Tamanho ideal para segmentos no modo \"text\".\nconst DESIRED_AUDIO_SEGMENT_SIZE = 450;      // Tamanho ideal para segmentos no modo \"audio\" (~30s).\nconst DELAY_FACTOR = 2000;                  // Delay: 200ms por 100 caracteres.\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// ------------------------------\n// Par√¢metros obtidos dos n√≥s\n// ------------------------------\nconst mapping = $('Mapping').first().json;\nconst chatwootData = mapping.chatwoot;\nconst accountId = chatwootData.account_id;\nconst conversationId = chatwootData.conversation_id;\nconst botToken = chatwootData.bot_token;\n\nconst system = mapping.system;\nconst outputFormat = system.output_format.toLowerCase(); // \"text\", \"audio\" ou \"smart\"\nconst elevenlabsKey = system.elevenlabs_key;\nconst elevenlabsVoice = system.elevenlabs_voice || \"JBFqnCBsd6RMkjVDRZzb\";\nconst elevenlabsModel = system.elevenlabs_model || \"eleven_multilingual_v2\";\nconst chatwootService = system.chatwoot_service; // Valor para a URL do Chatwoot\n\n// Texto original (ajustado para acessar o payload final corretamente)\nconst originalText = $('Execute Core').first().json.final.output;\nlogMessage(`[Main] Texto original possui ${originalText.length} caracteres.`);\nlogMessage(`[Main] Modo de sa√≠da: ${outputFormat}`);\n\n// Endpoint do Chatwoot (ajustado para usar chatwootService)\n//const chatwootUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\n//logMessage(`[Main] Chatwoot URL: ${chatwootUrl}`);\n\nconst chatwootUrl = `https://chat.spsystems.pro/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\nlogMessage(`[Main] Chatwoot URL: ${chatwootUrl}`);\n\n\n\n// Log dos par√¢metros de entrada\nlogMessage(`[Main] Par√¢metros: accountId=${accountId}, conversationId=${conversationId}`);\nlogMessage(`[Main] Chatwoot Service: ${chatwootService}`);\nlogMessage(`[Main] Token (primeiros 5 caracteres): ${botToken.substring(0, 5)}...`);\n\n// ------------------------------\n// Fun√ß√£o para enviar mensagem de texto\n// ------------------------------\nasync function sendTextMessage(content) {\n  const payload = { content, message_type: \"outgoing\" };\n  const headers = {\n    \"api_access_token\": botToken,\n    \"Content-Type\": \"application/json\"\n  };\n  \n  logMessage(`[sendTextMessage] Enviando mensagem de texto.`);\n  logMessage(`[sendTextMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendTextMessage] Payload: ${JSON.stringify(payload)}`);\n  logMessage(`[sendTextMessage] Headers: ${JSON.stringify(headers)}`);\n  \n  logRequest('POST', chatwootUrl, headers, payload);\n  \n  try {\n    const response = await axios.post(chatwootUrl, payload, { headers });\n    logMessage(`[sendTextMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendTextMessage] Erro ao enviar mensagem de texto: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendTextMessage] Status: ${error.response.status}`);\n      logError(`[sendTextMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendTextMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendTextMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Fun√ß√£o para enviar mensagem de √°udio\n// ------------------------------\nasync function sendAudioMessage(audioBuffer) {\n  const form = new FormData();\n  form.append(\"attachments[]\", audioBuffer, { filename: \"audio.mp3\", contentType: \"audio/mpeg\" });\n  form.append(\"message_type\", \"outgoing\");\n  \n  const headers = {\n    \"api_access_token\": botToken,\n    ...form.getHeaders()\n  };\n  \n  logMessage(`[sendAudioMessage] Enviando mensagem de √°udio.`);\n  logMessage(`[sendAudioMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendAudioMessage] Headers: ${JSON.stringify(headers)}`);\n  logMessage(`[sendAudioMessage] Tamanho do √°udio: ${audioBuffer.length} bytes`);\n  \n  logRequest('POST', chatwootUrl, headers, \"Form Data com √°udio\");\n  \n  try {\n    const response = await axios.post(chatwootUrl, form, { headers });\n    logMessage(`[sendAudioMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendAudioMessage] Erro ao enviar mensagem de √°udio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendAudioMessage] Status: ${error.response.status}`);\n      logError(`[sendAudioMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendAudioMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendAudioMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Fun√ß√£o para converter texto em √°udio via Elevenlabs\n// ------------------------------\nasync function convertTextToSpeech(text) {\n  const url = `https://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(elevenlabsVoice)}?output_format=mp3_44100_128`;\n  const headers = {\n    \"xi-api-key\": elevenlabsKey,\n    \"Content-Type\": \"application/json\"\n  };\n  const payload = {\n    text: text,\n    model_id: elevenlabsModel\n  };\n  \n  logMessage(`[convertTextToSpeech] Convertendo texto para √°udio (primeiros 50 caracteres): \"${text.substring(0,50)}...\"`);\n  logMessage(`[convertTextToSpeech] URL da API Elevenlabs: ${url}`);\n  logMessage(`[convertTextToSpeech] Modelo utilizado: ${elevenlabsModel}`);\n  \n  logRequest('POST', url, headers, payload);\n  \n  try {\n    const response = await axios.post(url, payload, { headers, responseType: 'arraybuffer' });\n    logMessage(`[convertTextToSpeech] Convers√£o realizada com sucesso. Status: ${response.status}`);\n    logResponse(response.status, \"Binary Audio Data\");\n    return response.data;\n  } catch (error) {\n    logError(`[convertTextToSpeech] Erro ao converter texto para √°udio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[convertTextToSpeech] Status: ${error.response.status}`);\n      logError(`[convertTextToSpeech] Headers: ${JSON.stringify(error.response.headers)}`);\n      // Para arraybuffer, precisamos converter para texto para ver o erro\n      if (error.response.data) {\n        try {\n          const errorText = Buffer.from(error.response.data).toString('utf8');\n          logError(`[convertTextToSpeech] Erro Response: ${errorText}`);\n          logResponse(error.response.status, errorText);\n        } catch (e) {\n          logError(`[convertTextToSpeech] N√£o foi poss√≠vel converter resposta de erro: ${e.toString()}`);\n        }\n      }\n    } else if (error.request) {\n      logError(`[convertTextToSpeech] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Fun√ß√£o para mesclar segmentos curtos (para modos text e audio)\n// ------------------------------\nfunction mergeShortSegments(segments, minLength) {\n  const merged = [];\n  let buffer = \"\";\n  for (const seg of segments) {\n    if ((buffer + \" \" + seg).trim().length < minLength) {\n      buffer = (buffer + \" \" + seg).trim();\n    } else {\n      if (buffer) {\n        merged.push(buffer);\n        buffer = \"\";\n      }\n      merged.push(seg);\n    }\n  }\n  if (buffer) {\n    if (merged.length > 0) {\n      merged[merged.length - 1] += \" \" + buffer;\n    } else {\n      merged.push(buffer);\n    }\n  }\n  return merged;\n}\n\n// ------------------------------\n// Fun√ß√£o de segmenta√ß√£o gen√©rica (evita quebrar palavras)\n// ------------------------------\nfunction segmentTextGeneric(text, desiredMaxLength) {\n  if (text.length <= desiredMaxLength) return [text];\n  \n  let segments = [];\n  // Tenta dividir por quebra de linha dupla\n  if (text.includes(\"\\n\\n\")) {\n    segments = text.split(/\\n\\s*\\n/).map(seg => seg.trim()) // .filter(seg => seg.length > 0);\n  }\n  // Se n√£o houver, ou se n√£o gerar resultados, dividir por delimitadores naturais (ponto, ?, !, v√≠rgula, ;, :)\n  if (segments.length === 0) {\n    segments = text.split(/(?<=[.?!,;:])\\s+/).map(seg => seg.trim()) // .filter(seg => seg.length > 0);\n  }\n  \n  // Mescla segmentos curtos\n  segments = mergeShortSegments(segments, MIN_SEGMENT_LENGTH);\n  \n  // Se algum segmento for muito longo, subdivide-o por espa√ßos, sem quebrar palavras\n  const finalSegments = [];\n  segments.forEach(seg => {\n    if (seg.length > desiredMaxLength * 1.5) {\n      const words = seg.split(\" \");\n      let current = \"\";\n      for (const word of words) {\n        if ((current + \" \" + word).trim().length > desiredMaxLength) {\n          finalSegments.push(current.trim());\n          current = word;\n        } else {\n          current += \" \" + word;\n        }\n      }\n      if (current.trim()) finalSegments.push(current.trim());\n    } else {\n      finalSegments.push(seg);\n    }\n  });\n  \n  return finalSegments;\n}\n\n// Fun√ß√£o para escapar caracteres especiais\nfunction textSegmentation(text, maxSize = 200, minSize = 30) {\n  // Divide o texto em par√°grafos\n  const parts = text.split(\"\\n\\n\");\n\n  // Se o texto n√£o cont√©m nenhum par√°grafo, retorna o texto original\n  if (parts.length === 1 && parts[0].length <= maxSize) {\n    return parts;\n  }\n\n  // Processa a segmenta√ß√£o de cada par√°grafo\n  const segments = parts.reduce((acc, part) => {\n    part = part.trim();\n\n    // Se o par√°grafo √© menor que o tamanho m√°ximo, mantemos ele inteiro\n    if (part.length <= maxSize) {\n      acc.push(part.trim());\n    } else {\n      // Para par√°grafos maiores que o tamanho m√°ximo, dividimos em segmentos\n      // baseados apenas nos pontos de separa√ß√£o (. ! ?)\n      let currentSegment = \"\";\n      let lastSegmentEnd = 0;\n\n      // Percorremos o texto caractere por caractere\n      for (let i = 0; i < part.length; i++) {\n        const char = part[i];\n        currentSegment += char;\n\n        // Verificamos se encontramos um ponto de quebra\n        if (char === \".\" || char === \"!\" || char === \"?\") {\n          // Verificar se n√£o √© parte de uma numera√ß√£o (ex: \"1.\", \"2.\")\n          const prevChar = i > 0 ? part[i - 1] : \"\";\n          const isNumbering = /\\d/.test(prevChar);\n\n          // Se for parte de uma numera√ß√£o, n√£o √© um ponto de quebra\n          if (isNumbering) {\n            continue;\n          }\n\n          // Regra especial para ponto final: verificar se tem menos de 4 caracteres ap√≥s o √∫ltimo espa√ßo\n          if (char === \".\") {\n            // Encontra a √∫ltima ocorr√™ncia de espa√ßo no segmento atual\n            const lastSpaceIndex = currentSegment.lastIndexOf(\" \");\n\n            // Se n√£o h√° espa√ßo ou a palavra ap√≥s o √∫ltimo espa√ßo tem menos de 4 caracteres, n√£o quebra\n            if (\n              lastSpaceIndex === -1 ||\n              currentSegment.length - lastSpaceIndex - 1 < 4\n            ) {\n              continue;\n            }\n          }\n\n          // Ponto de quebra v√°lido encontrado\n          if (currentSegment.length >= minSize) {\n            // Garantimos que n√£o h√° espa√ßos extras\n            const trimmedSegment = currentSegment.trim();\n            acc.push(trimmedSegment);\n\n            // Pegamos o pr√≥ximo caractere ap√≥s o ponto de quebra,\n            // mas pulamos qualquer espa√ßo inicial no pr√≥ximo segmento\n            currentSegment = \"\";\n            lastSegmentEnd = i + 1;\n\n            // Avan√ßamos o √≠ndice i para pular espa√ßos entre segmentos\n            while (\n              lastSegmentEnd < part.length &&\n              part[lastSegmentEnd] === \" \"\n            ) {\n              lastSegmentEnd++;\n              i = lastSegmentEnd - 1; // Ajustamos i para continuar do pr√≥ximo caractere n√£o-espa√ßo\n            }\n          }\n        }\n      }\n\n      // Adicionamos o segmento restante, se houver\n      if (currentSegment.length > 0) {\n        acc.push(currentSegment.trim());\n      }\n    }\n\n    return acc;\n  }, []);\n\n  return¬†segments;\n}\n\n// ------------------------------\n// Fun√ß√µes de segmenta√ß√£o para cada modo\n// ------------------------------\nfunction segmentForText(text) {\n  return textSegmentation(text, DESIRED_TEXT_SEGMENT_SIZE);\n}\n\nfunction segmentForAudio(text) {\n  return textSegmentation(text, DESIRED_AUDIO_SEGMENT_SIZE);\n}\n\n/**\n * Fun√ß√£o \"smartSegment\":\n * - Divide o texto em senten√ßas usando delimitadores finais.\n * - Para cada senten√ßa, se ela contiver d√≠gitos ou tiver menos de 80 ou mais de 600 caracteres,\n *   ela ser√° marcada para envio como texto.\n * - Caso contr√°rio, a senten√ßa √© considerada \"audio\".\n * - As senten√ßas marcadas para √°udio s√£o agrupadas at√© atingirem aproximadamente DESIRED_AUDIO_SEGMENT_SIZE.\n * - Ap√≥s a segmenta√ß√£o, os segmentos do tipo \"text\" com menos que MIN_SEGMENT_LENGTH s√£o mesclados.\n * \n * Retorna um array de objetos: { type: \"text\" | \"audio\", content: string }.\n */\nfunction smartSegment(text) {\n  const sentences = text.split(/(?<=[.?!])\\s+/).map(s => s.trim()).filter(s => s);\n  const segments = [];\n  let audioBuffer = \"\";\n  \n  for (const sentence of sentences) {\n    if (/\\d/.test(sentence) || sentence.length < 80 || sentence.length > 600) {\n      if (audioBuffer) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = \"\";\n      }\n      segments.push({ type: \"text\", content: sentence });\n    } else {\n      if ((audioBuffer + \" \" + sentence).trim().length > DESIRED_AUDIO_SEGMENT_SIZE) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = sentence;\n      } else {\n        audioBuffer = (audioBuffer + \" \" + sentence).trim();\n      }\n    }\n  }\n  if (audioBuffer) {\n    segments.push({ type: \"audio\", content: audioBuffer.trim() });\n  }\n  \n  const mergedSegments = [];\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    if (seg.type === \"text\" && seg.content.length < MIN_SEGMENT_LENGTH) {\n      if (mergedSegments.length > 0 && mergedSegments[mergedSegments.length - 1].type === \"text\") {\n        mergedSegments[mergedSegments.length - 1].content += \" \" + seg.content;\n      } else if (i < segments.length - 1 && segments[i+1].type === \"text\") {\n        segments[i+1].content = seg.content + \" \" + segments[i+1].content;\n      } else {\n        mergedSegments.push(seg);\n      }\n    } else {\n      mergedSegments.push(seg);\n    }\n  }\n  \n  return mergedSegments;\n}\n\n// ------------------------------\n// Fun√ß√£o principal para segmentar e enviar a mensagem\n// ------------------------------\nasync function main() {\n  try {\n    logMessage(`[Main] Modo de sa√≠da selecionado: ${outputFormat}`);\n    \n    // Verifica√ß√£o inicial de par√¢metros essenciais\n    if (!originalText || originalText.trim().length === 0) {\n      throw new Error(\"Texto original est√° vazio ou n√£o foi encontrado\");\n    }\n    \n    if (!chatwootService) {\n      throw new Error(\"chatwoot_service n√£o definido\");\n    }\n    \n    if (!accountId) {\n      throw new Error(\"account_id n√£o definido\");\n    }\n    \n    if (!conversationId) {\n      throw new Error(\"conversation_id n√£o definido\");\n    }\n    \n    if (!botToken) {\n      throw new Error(\"bot_token n√£o definido\");\n    }\n    \n    // Adicionando um delay inicial para garantir que o Chatwoot esteja pronto\n    await delay(1000);\n  \n    if (outputFormat === \"audio\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key n√£o definida para modo audio\");\n      }\n      \n      const segments = segmentForAudio(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para √°udio.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de √°udio: \"${segment.substring(0,50)}...\"`);\n        const audioBuffer = await convertTextToSpeech(segment);\n        await sendAudioMessage(audioBuffer);\n        logMessage(`[Main] Segmento de √°udio enviado: \"${segment.substring(0,50)}...\"`);\n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do pr√≥ximo segmento de √°udio.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem de √°udio enviada com sucesso.\", logs: detailedLogs };\n    } else if (outputFormat === \"smart\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key n√£o definida para modo smart\");\n      }\n      \n      const segments = smartSegment(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} parte(s) (smart mode).`);\n      \n      for (const seg of segments) {\n        if (seg.type === \"audio\") {\n          logMessage(`[Main] Processando segmento de √°udio smart: \"${seg.content.substring(0,50)}...\"`);\n          const audioBuffer = await convertTextToSpeech(seg.content);\n          await sendAudioMessage(audioBuffer);\n          logMessage(`[Main] Segmento de √°udio enviado: \"${seg.content.substring(0,50)}...\"`);\n        } else {\n          logMessage(`[Main] Processando segmento de texto smart: \"${seg.content.substring(0,50)}...\"`);\n          await sendTextMessage(seg.content);\n          logMessage(`[Main] Segmento de texto enviado: \"${seg.content.substring(0,50)}...\"`);\n        }\n        \n        const delayTime = Math.ceil(seg.content.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do pr√≥ximo segmento.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem smart enviada com sucesso.\", logs: detailedLogs };\n    } else {\n      // Modo padr√£o: text\n      const segments = segmentForText(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para texto.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de texto: \"${segment.substring(0,50)}...\"`);\n        await sendTextMessage(segment);\n        logMessage(`[Main] Segmento de texto enviado: \"${segment.substring(0,50)}...\"`);\n        \n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do pr√≥ximo segmento de texto.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagens de texto enviadas com sucesso.\", logs: detailedLogs };\n    }\n  } catch (error) {\n    logError(`[Main] Erro: ${error.toString()}`);\n    return { error: error.toString(), logs: detailedLogs };\n  }\n}\n\nreturn main().then(result => [{ json: result }]);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        500,
        1300
      ],
      "id": "3aa4b08c-0994-4cb9-9118-8b32ff38d404",
      "name": "Chatwoot Output"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH last_conversation AS (\n  -- Encontra a √∫ltima conversa do usu√°rio\n  SELECT id\n  FROM conversations\n  WHERE user_id = {{ $('Mapping').first().json.chatwoot.contact_id }}\n  ORDER BY date_created DESC\n  LIMIT 1\n),\nlast_two_chat_histories AS (\n  -- Obt√©m os dois √∫ltimos hist√≥ricos da conversa e define uma ordem para identificar o pen√∫ltimo\n  SELECT \n    id,\n    ROW_NUMBER() OVER (ORDER BY id DESC) AS rn\n  FROM core_chat_histories\n  WHERE session_id = (SELECT id FROM last_conversation)\n  ORDER BY id DESC\n  LIMIT 2\n),\nupdate_chat_histories AS (\n  UPDATE core_chat_histories c\n  SET \n    date_created = NOW(),\n    message = (\n      CASE \n        WHEN l.rn = 2 \n          THEN jsonb_set(c.message::jsonb, '{user_name}', to_jsonb('{{ $('Mapping').first().json.chatwoot.user_name }}'::text), true)\n        ELSE c.message::jsonb\n      END\n    )::json\n  FROM last_two_chat_histories l\n  WHERE c.id = l.id\n  RETURNING 1\n)\nUPDATE users u\nSET date_updated = NOW()\nWHERE u.id = {{ $('Mapping').first().json.chatwoot.contact_id }};",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        700,
        1300
      ],
      "id": "26d99333-8bcc-482d-b8c4-4e641412db17",
      "name": "Add Register",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "name": "set_timer",
        "description": "Invoque essa tool para configurar um timer que iniciar√° uma a√ß√£o ap√≥s o tempo especificado. Apenas usu√°rios admin podem usar essa tool. O tempo deve ser informado com valor e unidade (s, m, h). Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\nconst dayjs = require('dayjs');\nconst duration = require('dayjs/plugin/duration');\ndayjs.extend(duration);\n\n/**\n * Esta tool configura um timer via webhook.\n * Ela envia, para o endpoint, todo o objeto mapping (obtido em Core Input)\n * e o tempo em segundos calculado a partir dos par√¢metros \"timer_value\" e \"timer_unit\".\n * Apenas usu√°rios admin podem utilizar esta tool.\n */\n\n// Converte o mapping recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usu√°rio √© admin\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usu√°rio n√£o autorizado.\" });\n}\n\n// Obt√©m os par√¢metros do timer a partir do input (query)\nconst timerValue = query.timer_value;  // N√∫mero (ex: 30)\nconst timerUnit = query.timer_unit;      // \"s\", \"m\" ou \"h\"\n\n// Calcula o tempo em segundos usando dayjs.duration\nconst timerSeconds = dayjs.duration(timerValue, timerUnit).asSeconds();\n\n// Prepara o payload para o webhook\nconst payload = {\n  mapping: mapping,\n  timer_seconds: timerSeconds\n};\n\n// URL do webhook substituindo 'n8n_webhook' pelo valor da vari√°vel no mapping\nconst url = `http://${mapping.system.n8n_webhook_service}:5678/webhook/timer`;\n\n/**\n * Fun√ß√£o para enviar a requisi√ß√£o ao webhook.\n * Tenta enviar uma √∫nica vez e retorna o resultado.\n */\nasync function sendTimerRequest() {\n  try {\n    console.log(`Enviando requisi√ß√£o para configurar o timer para ${timerSeconds} segundos...`);\n    const response = await axios.post(url, payload, {\n      headers: { 'Content-Type': 'application/json' }\n    });\n    console.log(\"Timer configurado com sucesso.\");\n    return { success: true, message: `Timer configurado com sucesso. Ele ser√° acionado em ${timerSeconds} segundos.` };\n  } catch (error) {\n    console.error(\"Erro ao configurar o timer:\", error.response ? error.response.data : error.message);\n    return { success: false, error: error.response ? error.response.data : error.message };\n  }\n}\n\nreturn sendTimerRequest().then(result => JSON.stringify(result));",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"timer_value\": {\n      \"type\": \"number\",\n      \"description\": \"Valor do timer. Exemplo: 30\"\n    },\n    \"timer_unit\": {\n      \"type\": \"string\",\n      \"description\": \"Unidade de tempo para o timer: 's' para segundos, 'm' para minutos, 'h' para horas.\",\n      \"enum\": [\"s\", \"m\", \"h\"]\n    }\n  },\n  \"required\": [\"timer_value\", \"timer_unit\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1380,
        1580
      ],
      "id": "3680376d-7af6-4818-b051-0aedb4da4bfa",
      "name": "Set Timer"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "tableName": {
          "__rl": true,
          "value": "knowledge",
          "mode": "list",
          "cachedResultName": "knowledge"
        },
        "additionalFields": {},
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTrigger",
      "typeVersion": 1,
      "position": [
        -1300,
        1860
      ],
      "id": "b7185a67-4bc6-4b45-a71a-c1de89231c0f",
      "name": "Knowledge Trigger",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  k.*,\n  n.value AS namespace,\n  ph.value AS pinecone_host,\n  (\n    SELECT json_agg(ku.url)\n    FROM knowledge_urls ku\n    WHERE ku.knowledge_id = k.id\n  ) AS urls,\n  (\n    SELECT json_agg(kf.directus_files_id)\n    FROM knowledge_files kf\n    WHERE kf.knowledge_id = k.id\n  ) AS files_id,\n  (\n    SELECT row_to_json(gv)\n    FROM global_vars gv\n    LIMIT 1\n  ) AS global_vars\nFROM knowledge k\nLEFT JOIN namespace n ON n.id = k.name_id\nLEFT JOIN pinecone_host ph ON ph.id = k.pinecone_host_id\nWHERE k.id = {{ $('Knowledge Trigger').first().json.payload.id }};\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1100,
        1860
      ],
      "id": "42909b41-9d9d-4e31-9968-b83ea887b063",
      "name": "Get Global Vars",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\n// Delay configur√°vel\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Executa requisi√ß√£o GET com retry, usando par√¢metros configur√°veis.\nasync function axiosGetWithRetry(url, config, maxAttempts = 3, delayMs = 1000) {\n  let attempt = 1;\n  while (attempt <= maxAttempts) {\n    try {\n      return await axios.get(url, config);\n    } catch (err) {\n      console.error(`Tentativa ${attempt} para ${url} falhou:`, {\n        message: err.message,\n        status: err.response?.status,\n        data: err.response?.data,\n      });\n      if (attempt === maxAttempts) throw err;\n      attempt++;\n      await delay(delayMs);\n    }\n  }\n}\n\n// Prompt para gerar resumo de um bloco de texto\nconst SUMMARY_PROMPT = `Analise o texto a seguir e elabore um resumo conciso e direto, destacando os principais t√≥picos e informa√ß√µes essenciais. Esse resumo servir√° de base para compor a descri√ß√£o geral do documento.\n\nTexto:\n{conteudo}\n\nResumo:`;\n\n// Prompt para criar a descri√ß√£o diretamente a partir do texto completo\nconst DIRECT_DESCRIPTION_PROMPT = `Analise o texto a seguir e crie uma descri√ß√£o clara e objetiva do conte√∫do geral do documento. A resposta deve ser um √∫nico par√°grafo conciso de texto simples, sem formata√ß√£o, com aproximadamente 300 caracteres.\n\nTexto:\n{conteudo}\n\nDescri√ß√£o:`;\n\n// Prompt para gerar a descri√ß√£o final a partir dos resumos\nconst FINAL_DESCRIPTION_PROMPT = `Com base nos resumos a seguir, elabore uma descri√ß√£o clara e objetiva do conte√∫do geral do documento. A resposta deve ser um √∫nico par√°grafo conciso de texto simples, sem formata√ß√£o, com aproximadamente 300 caracteres.\n\nResumos:\n{conteudo}\n\nDescri√ß√£o:`;\n\n// Cria chunks de forma org√¢nica, sem misturar conte√∫dos de diferentes scrapings\nfunction createChunks(text, chunkLength, overlapPercentage) {\n  const overlapLength = Math.floor(chunkLength * (overlapPercentage / 100));\n  const chunks = [];\n  let currentPos = 0;\n  while (currentPos < text.length) {\n    let endPos = currentPos + chunkLength;\n    if (endPos >= text.length) {\n      endPos = text.length;\n    } else {\n      const searchStart = Math.max(currentPos, endPos - 100);\n      let breakPos = -1;\n      let pos = text.lastIndexOf(\"\\n\\n\", endPos);\n      if (pos >= searchStart) {\n        breakPos = pos + 2;\n      } else {\n        pos = text.lastIndexOf(\"\\n\", endPos);\n        if (pos >= searchStart) {\n          breakPos = pos + 1;\n        } else {\n          pos = text.lastIndexOf(\".\", endPos);\n          if (pos >= searchStart) {\n            breakPos = pos + 1;\n          } else {\n            pos = text.lastIndexOf(\"?\", endPos);\n            if (pos >= searchStart) {\n              breakPos = pos + 1;\n            } else {\n              pos = text.lastIndexOf(\"!\", endPos);\n              if (pos >= searchStart) {\n                breakPos = pos + 1;\n              }\n            }\n          }\n        }\n      }\n      if (breakPos > currentPos) {\n        endPos = breakPos;\n      }\n    }\n    const chunk = text.substring(currentPos, endPos).trim();\n    if (chunk.length > 0) chunks.push(chunk);\n    if (endPos === text.length) break;\n    currentPos = endPos - overlapLength;\n    if (currentPos < 0) currentPos = 0;\n  }\n  return chunks;\n}\n\n// Fun√ß√£o para atualizar o campo \"description\" da tabela \"knowledge\" no Directus\nasync function updateDirectusDescription(newDescription, globalVars, globalId) {\n  const patchUrl = `http://${globalVars.directus_service}:8055/items/knowledge/${globalId}`;\n  const patchPayload = { description: newDescription };\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": `Bearer ${globalVars.directus_token}`\n  };\n  let attempts = 0;\n  while (attempts < 3) {\n    try {\n      const response = await axios.patch(patchUrl, patchPayload, { headers });\n      console.log(`Directus update successful: ${JSON.stringify(response.data)}`);\n      return response.data;\n    } catch (error) {\n      attempts++;\n      console.error(`Directus update attempt ${attempts} failed: ${error.message}`);\n      if (attempts < 3) {\n        await delay(1000);\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n\nasync function processScraping() {\n  // Extrai dados do n√≥ Get Global Vars\n  const globalData = $('Get Global Vars').first().json;\n  const globalVars = globalData.global_vars;\n  const filesIds = Array.isArray(globalData.files_id) ? globalData.files_id : [];\n  const originalUrls = Array.isArray(globalData.urls) ? globalData.urls : [];\n  // Usa s3_url definido em global_vars\n  const host = globalVars.s3_url;\n  const directusToken = globalVars.directus_token;\n  const jinaToken = globalVars.jina_ai_token;\n  const openrouterKey = globalVars.openrouter_key;\n  const directusService = globalVars.directus_service;\n  const n8nWebhookService = globalVars.n8n_webhook_service;\n  const chunkLength = globalData.chunks_length || 2000; // fallback default\n  const overlapPercentage = globalData.overlap || 0;      // fallback default\n  \n  // Extrai o valor de Knowledge Trigger\n  const knowledgeTriggerId = $('Knowledge Trigger').first().json.payload.id;\n\n  // Processa arquivos para obter finalUrl com retry (se existirem)\n  const fileResults = await Promise.all(\n    filesIds.map(async (fileId) => {\n      try {\n        const response = await axiosGetWithRetry(\n          `http://${directusService}:8055/files/${fileId}`,\n          { headers: { Authorization: `Bearer ${directusToken}` } }\n        );\n        const filename_disk = response.data.data.filename_disk;\n        // Retira o \"s3\" pois j√° est√° incluso na URL\n        const finalUrl = `${host}/directus/${filename_disk}`;\n        return { type: 'file', fileId, url: finalUrl };\n      } catch (err) {\n        return {\n          type: 'file',\n          fileId,\n          error: err.message,\n          status: err.response?.status,\n          responseData: err.response?.data,\n        };\n      }\n    })\n  );\n\n  // Prepara URLs para scraping (se existirem)\n  const originalUrlsToScrape = originalUrls.map(url => ({ type: 'original', url }));\n  const allUrlsToScrape = [\n    ...fileResults.filter(item => item.url),\n    ...originalUrlsToScrape\n  ];\n\n  // Executa scraping com retry para cada URL (se houver)\n  const scrapeResults = await Promise.all(\n    allUrlsToScrape.map(async (item) => {\n      try {\n        const scrapingUrl = `https://r.jina.ai/${item.url}`;\n        const response = await axiosGetWithRetry(\n          scrapingUrl,\n          { headers: { Authorization: `Bearer ${jinaToken}` } }\n        );\n        return { ...item, scrapeData: response.data };\n      } catch (err) {\n        return {\n          ...item,\n          scrapeError: err.message,\n          status: err.response?.status,\n          errorData: err.response?.data,\n        };\n      }\n    })\n  );\n\n  // Agrega e limpa conte√∫do dos scrapings para gerar chunks e descri√ß√£o\n  const scrapedTexts = scrapeResults.map(item => item.scrapeData ? JSON.stringify(item.scrapeData) : '');\n  const aggregatedContent = scrapedTexts.join(' ');\n  const cleanedContent = aggregatedContent.replace(/[^a-zA-Z0-9\\s]/g, ' ');\n\n  // Gera chunks dos scrapings (mantendo conte√∫do org√¢nico por scraping)\n  const chunks = [];\n  scrapeResults.forEach(item => {\n    if (item.scrapeData) {\n      const text = JSON.stringify(item.scrapeData);\n      const itemChunks = createChunks(text, chunkLength, overlapPercentage);\n      itemChunks.forEach(chunk => {\n        chunks.push({ chunk, source: item.url });\n      });\n    }\n  });\n\n  // Gera√ß√£o da descri√ß√£o do conte√∫do\n  const blockSize = 200000;\n  let finalDescription;\n  async function enviarPrompt(promptContent) {\n    const response = await axios.post(\n      'https://openrouter.ai/api/v1/chat/completions',\n      {\n        model: 'google/gemini-2.5-pro-preview-03-25',\n        messages: [{ role: 'user', content: promptContent }]\n      },\n      { headers: { Authorization: `Bearer ${openrouterKey}` } }\n    );\n    return response.data;\n  }\n  if (cleanedContent.length > blockSize) {\n    const blocks = [];\n    for (let i = 0; i < cleanedContent.length; i += blockSize) {\n      blocks.push(cleanedContent.substring(i, i + blockSize));\n    }\n    const summaries = await Promise.all(\n      blocks.map(async (block) => {\n        const prompt = `<dados>${block}</dados>\\n` + SUMMARY_PROMPT.replace('{conteudo}', block);\n        try {\n          const summaryResponse = await enviarPrompt(prompt);\n          return (summaryResponse.choices && summaryResponse.choices[0].message.content) || '';\n        } catch (err) {\n          return '';\n        }\n      })\n    );\n    const aggregatedSummaries = summaries.join(' ');\n    const descriptionPrompt = `<dados>${aggregatedSummaries}</dados>\\n` + FINAL_DESCRIPTION_PROMPT.replace('{conteudo}', aggregatedSummaries);\n    try {\n      const descriptionResponse = await enviarPrompt(descriptionPrompt);\n      finalDescription = descriptionResponse;\n    } catch (err) {\n      finalDescription = { error: err.message, status: err.response?.status, errorData: err.response?.data };\n    }\n  } else {\n    const directPrompt = `<dados>${cleanedContent}</dados>\\n` + DIRECT_DESCRIPTION_PROMPT.replace('{conteudo}', cleanedContent);\n    try {\n      const descriptionResponse = await enviarPrompt(directPrompt);\n      finalDescription = descriptionResponse;\n    } catch (err) {\n      finalDescription = { error: err.message, status: err.response?.status, errorData: err.response?.data };\n    }\n  }\n  \n  // Extrai somente o conte√∫do da descri√ß√£o, se dispon√≠vel\n  if (finalDescription && finalDescription.choices && finalDescription.choices[0] && finalDescription.choices[0].message) {\n    finalDescription = finalDescription.choices[0].message.content;\n  }\n\n  // Atualiza o campo \"description\" na tabela \"knowledge\" no Directus\n  try {\n    const updateResponse = await updateDirectusDescription(finalDescription, globalVars, globalData.id);\n    console.log(\"Directus update response:\", updateResponse);\n  } catch (error) {\n    console.error(\"Falha ao atualizar o Directus ap√≥s 3 tentativas:\", error.message);\n  }\n\n  // Gera√ß√£o dos vetores a partir dos chunks\n  for (const chunkItem of chunks) {\n    const vectorPromptBody = {\n      messages: [\n        {\n          role: \"user\",\n          content: `Voc√™ √© um agente interno de um sistema especializado em extrair perguntas e respostas de documentos. Sua tarefa √© analisar o chunk fornecido, que representa um segmento de um documento completo, e gerar perguntas e respostas baseadas nas informa√ß√µes contidas nele. \n\nContexto do documento: ${globalData.Instruction_Prompt}\n\nDiretrizes:\n1. Extraia informa√ß√µes relevantes (respostas) do chunk fornecido. Essas informa√ß√µes devem ser associadas a perguntas principais, mantendo sempre o tom e o estilo do texto original.\n2. Para cada resposta extra√≠da:\n   - Crie uma pergunta principal (q) que tenha como resposta a informa√ß√£o extra√≠da (a).\n   - Identifique o trecho espec√≠fico do documento (t) de onde a resposta foi retirada.\n   - Formule perguntas alternativas (sq) que poderiam ser feitas para obter a mesma resposta (a).\n3. Sempre que encontrar m√∫ltiplas informa√ß√µes relevantes, crie m√∫ltiplas perguntas e respostas.\n4. Mantenha a originalidade e fidelidade ao conte√∫do fornecido.\n\nChunk:\n${chunkItem.chunk}`\n        }\n      ],\n      response_format: {\n        type: \"json_schema\",\n        json_schema: {\n          name: \"extracted_data\",\n          strict: true,\n          schema: {\n            type: \"object\",\n            properties: {\n              results: {\n                type: \"array\",\n                items: {\n                  type: \"object\",\n                  properties: {\n                    a: { type: \"string\", description: \"A resposta ou informa√ß√£o extra√≠da.\" },\n                    t: { type: \"string\", description: \"O trecho exato do documento de onde a resposta foi retirada.\" },\n                    q: { type: \"string\", description: \"A pergunta principal que leva √† resposta.\" },\n                    sq: { type: \"array\", items: { type: \"string\" }, description: \"Perguntas alternativas que poderiam obter a mesma resposta.\" }\n                  },\n                  required: [\"a\", \"t\", \"q\", \"sq\"],\n                  additionalProperties: false\n                }\n              }\n            },\n            required: [\"results\"],\n            additionalProperties: false\n          }\n        }\n      }\n    };\n    try {\n      const vectorResponse = await axios.post(\n        'https://openrouter.ai/api/v1/chat/completions',\n        vectorPromptBody,\n        { headers: { Authorization: `Bearer ${openrouterKey}` } }\n      );\n      // Envia a resposta para o webhook incluindo global_vars, knowledge_trigger_id, pinecone_host e namespace\n      await axios.post(\n        `http://${n8nWebhookService}:5678/webhook/vector`,\n        {\n          ...vectorResponse.data,\n          global_vars: globalVars,\n          knowledge_trigger_id: knowledgeTriggerId,\n          pinecone_host: globalData.pinecone_host,\n          namespace: globalData.namespace\n        }\n      );\n    } catch (err) {\n      console.error('Erro ao gerar vetor para chunk:', err.message);\n    }\n    // Aguarda 10 segundos antes da pr√≥xima requisi√ß√£o\n    await delay(10000);\n  }\n\n  return { files: fileResults, scraping: scrapeResults, description: finalDescription, chunks };\n}\n\nreturn processScraping()\n  .then(result => [{ json: result }])\n  .catch(error => {\n    console.error('Erro geral:', { message: error.message, details: error });\n    return [{ json: { error: error.message, details: error } }];\n  });"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -900,
        1860
      ],
      "id": "c2119d41-b433-48e6-9ebf-8a8e3b14dc0e",
      "name": "Process Docs"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "vector",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -580,
        1860
      ],
      "id": "9409bd76-0209-4faf-b1c6-8366498d25f4",
      "name": "Vector Trigger",
      "webhookId": "31a23ccc-c8b7-4a93-980c-783c0490d567"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $('Vector Trigger').first().json.body.global_vars.openai_key }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "input",
              "value": "={{ `Context: ${$('Split Vectors').item.json.t} Question: ${$('Split Vectors').item.json.q} Answer: ${$('Split Vectors').item.json.a} Similar Questions: ${$('Split Vectors').item.json.sq.join(\", \")}` }}"
            },
            {
              "name": "model",
              "value": "text-embedding-3-small"
            },
            {
              "name": "dimensions",
              "value": "={{ 1536 }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        20,
        1860
      ],
      "id": "495d7b40-b13f-433f-84cf-f7b455df6cdf",
      "name": "Embeddings",
      "notesInFlow": true
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={{ $json.body.choices[0].message.content.parseJson() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -380,
        1860
      ],
      "id": "2ceeb8fc-b92f-40e2-8c70-e114a08fcbd1",
      "name": "Parse JSON 2"
    },
    {
      "parameters": {
        "fieldToSplitOut": "results",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -180,
        1860
      ],
      "id": "3c0916ed-56a7-4e32-9e9c-3e0b71c9ef09",
      "name": "Split Vectors"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH new_vector AS (\n  INSERT INTO vectors \n    (id, date_created, question, answer, context, similar_questions, knowledge_id)\n  VALUES \n    (\n      uuid_generate_v4(), \n      NOW(), \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].q }} $$, \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].a }} $$, \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].t }} $$, \n      $$ {{ $('Parse JSON 2').item.json.results[$itemIndex].sq.join(',') }} $$, \n      {{ $('Vector Trigger').item.json.body.knowledge_trigger_id }}\n    )\n  RETURNING id AS vector_id\n),\nnew_dimension AS (\n  INSERT INTO dimensions (values, date_created, vector_id)\n  SELECT $$ {{ $('Embeddings').item.json.data[0].embedding.join(',') }} $$, NOW(), vector_id\n  FROM new_vector\n  RETURNING vector_id\n)\nINSERT INTO vectors_status (vector_id, value)\nSELECT vector_id, '#2ECDA7'\nFROM new_vector\nRETURNING vector_id;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        220,
        1860
      ],
      "id": "4bbeb6e1-2bb9-455f-9383-4852ee74b9f9",
      "name": "Add Vectors",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rag",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1300,
        2180
      ],
      "id": "e564df0d-aad6-40d2-8d7a-018d6c709550",
      "name": "RAG Input",
      "webhookId": "d503e6f9-0989-42d5-a598-e268b20c3182"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Por favor, analise a entrada do usu√°rio e o hist√≥rico recente. \n\nEntrada do usu√°rio: \n<user_input>{{ $('RAG Input').first().json.body.content }}</user_input>\n\nHist√≥rico das √∫ltimas 10 mensagens: \n<conversation_history>{{ $('Get History').first().json.chat_histories.map(item => item.message).slice(-10).toJsonString() }}</conversation_history>",
        "options": {
          "systemMessage": "=Voc√™ √© um agente especializado em realizar buscas no banco vetorial para fornecer contexto adicional √† intelig√™ncia artificial principal.\n\nObjetivo:\nAnalisar a entrada do usu√°rio e o hist√≥rico recente de mensagens para decidir se deve invocar a tool 'retriever' e, caso necess√°rio, realizar buscas eficientes.\n\nDiretrizes:\nBusca desnecess√°ria: Se a entrada do usu√°rio n√£o contiver perguntas relevantes ou espec√≠ficas (ex.: sauda√ß√µes, mensagens gen√©ricas ou irrelevantes), retorne: \"Busca desnecess√°ria.\"\nNenhuma informa√ß√£o encontrada: Se, ao usar a tool 'retriever', nenhuma informa√ß√£o relevante for encontrada, retorne: \"Nenhuma informa√ß√£o relevante encontrada.\"\nForne√ßa respostas precisas: Se encontrar informa√ß√µes no banco vetorial, forne√ßa apenas o conte√∫do necess√°rio para responder √† solicita√ß√£o do usu√°rio, de forma objetiva e sem interpreta√ß√µes adicionais.\nRegras para invocar a tool 'retriever':\nAnalise cuidadosamente a entrada do usu√°rio e as descri√ß√µes dos conhecimentos dispon√≠veis para identificar qualquer possibilidade de rela√ß√£o com os temas abordados nos conhecimentos.\nConsidere como relevante qualquer pergunta do usu√°rio que possa estar relacionada aos documentos descritos nos conhecimentos dispon√≠veis. Se houver uma chance de associa√ß√£o, a busca deve ser realizada.\nUse as descri√ß√µes dos conhecimentos dispon√≠veis para identificar o knowledge_id mais adequado:\n\n<knowledge_metadata>{{ $('Get History').first().json.knowledge.map(item => ({ knowledge_id: item.id, description: item.description })).toJsonString() }}</knowledge_metadata>\n\nUse m√∫ltiplas queries, se necess√°rio: Se a solicita√ß√£o do usu√°rio for ampla ou amb√≠gua, fa√ßa buscas utilizando palavras-chave diferentes para cobrir todas as possibilidades.\nCombine os resultados de forma precisa e concisa, retornando apenas o contexto essencial √† AI principal.\nInstru√ß√µes adicionais:\nSe houver qualquer rela√ß√£o potencial entre a solicita√ß√£o do usu√°rio e os conhecimentos dispon√≠veis, realize a busca imediatamente.\nAo invocar a tool 'retriever', fa√ßa perguntas claras e precisas, alinhadas ao contexto da entrada do usu√°rio e aos temas descritos nos conhecimentos dispon√≠veis.\nO foco √© fornecer contexto relevante e direto para a AI principal.",
          "passthroughBinaryImages": true
        }
      },
      "id": "a2ded5bf-177d-4a12-89b4-b8eab7ca769c",
      "name": "RAG Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        -900,
        2180
      ],
      "retryOnFail": false,
      "executeOnce": false
    },
    {
      "parameters": {
        "name": "retriever",
        "description": "=Invoque essa tool para buscar informa√ß√µes no banco vetorial e fornecer respostas relevantes com base nos conhecimentos dispon√≠veis. Use-a somente quando necess√°rio para complementar o contexto.",
        "jsCode": "const axios = require('axios');\n\nasync function runTool() {\n  let logs = \"\";\n  \n  try {\n    // Obter par√¢metros de entrada\n    logs += \"Obtendo par√¢metros de entrada...\\n\";\n    const searchQuery = query.query;\n    const knowledgeId = query.knowledge_id;\n    logs += `searchQuery: ${searchQuery}\\nknowledgeId: ${knowledgeId}\\n`;\n    \n    // Obter mapping a partir do n√≥ \"RAG Input\"\n    let mappingInput = $('RAG Input').first().json.body.mapping;\n    if (typeof mappingInput === 'string') {\n      try {\n        mappingInput = JSON.parse(mappingInput);\n        logs += \"Mapping Input convertido de string para objeto.\\n\";\n      } catch (e) {\n        throw new Error(\"Falha ao converter mapping para objeto.\");\n      }\n    }\n    logs += \"Mapping Input obtido.\\n\";\n    \n    if (!mappingInput.system) {\n      throw new Error(\"mappingInput.system est√° indefinido.\");\n    }\n    \n    // Gerar embeddings usando a API do OpenAI\n    logs += \"Chamando endpoint de embeddings da OpenAI...\\n\";\n    const openaiKey = mappingInput.system.openai_key;\n    const embeddingResponse = await axios.post(\n      'https://api.openai.com/v1/embeddings',\n      {\n        input: searchQuery,\n        model: \"text-embedding-3-small\"\n      },\n      {\n        headers: {\n          \"Authorization\": `Bearer ${openaiKey}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    logs += \"Embeddings obtidos com sucesso.\\n\";\n    const embedding = embeddingResponse.data.data[0].embedding;\n    logs += `Embedding (primeiros 5 valores): ${embedding.slice(0,5).join(\", \")}...\\n`;\n    \n    // Obter pinecone_host e namespace do hist√≥rico\n    logs += \"Obtendo pinecone_host e namespace a partir do hist√≥rico...\\n\";\n    const historyKnowledge = $('Get History').first().json.knowledge;\n    const knowledgeItem = historyKnowledge.find(item => item.id === knowledgeId);\n    if (!knowledgeItem) {\n      throw new Error(`Conhecimento com id ${knowledgeId} n√£o encontrado.`);\n    }\n    const pineconeHostRaw = knowledgeItem.pinecone_host;\n    const namespace = knowledgeItem.namespace;\n    logs += `pineconeHostRaw: ${pineconeHostRaw}, namespace: ${namespace}\\n`;\n    \n    // Garantir que pinecone_host comece com \"https://\"\n    let pineconeHost = pineconeHostRaw;\n    if (!pineconeHost.startsWith(\"https://\")) {\n      pineconeHost = \"https://\" + pineconeHost;\n    }\n    logs += `pineconeHost final: ${pineconeHost}\\n`;\n    \n    // Requisi√ß√£o para a API do Pinecone\n    logs += \"Chamando API do Pinecone...\\n\";\n    const pineconeKey = mappingInput.system.pinecone_key;\n    const pineconeQueryUrl = `${pineconeHost}/query`;\n    const pineconeResponse = await axios.post(\n      pineconeQueryUrl,\n      {\n        namespace: namespace,\n        vector: embedding,\n        topK: 3,\n        includeValues: false,\n        includeMetadata: true\n      },\n      {\n        headers: {\n          \"Api-Key\": pineconeKey,\n          \"X-Pinecone-API-Version\": \"2024-10\",\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    logs += \"Resposta do Pinecone obtida com sucesso.\\n\";\n    logs += `Pinecone response data: ${JSON.stringify(pineconeResponse.data)}\\n`;\n    \n    // Processar os resultados do Pinecone usando as chaves corretas dos metadados (\"a\", \"q\" e \"t\")\n    const matches = pineconeResponse.data.matches;\n    matches.forEach((m, idx) => {\n      logs += `Match ${idx + 1}: id=${m.id}, score=${m.score}, metadata=${JSON.stringify(m.metadata)}\\n`;\n    });\n    \n    const filteredMatches = matches.filter(item => item.score >= 0.0)\n      .map(item => ({\n        vector: item.id,\n        score: item.score,\n        answer: item.metadata ? item.metadata.a : null,\n        question: item.metadata ? item.metadata.q : null,\n        context: item.metadata ? item.metadata.t : null\n      }));\n    logs += `Matches filtrados: ${JSON.stringify(filteredMatches)}\\n`;\n    \n    const resultString = `Os vetores retornados foram: ${JSON.stringify(filteredMatches)}`;\n    logs += \"Processamento final conclu√≠do.\\n\";\n    \n    console.log(\"Logs:\", logs);\n    // Retorna apenas o resultado final (string) sem os logs.\n    return resultString;\n  } catch (error) {\n    logs += `Erro: ${error.message}\\n`;\n    console.error(\"Erro:\", error.message, \"Logs:\", logs);\n    return `Erro: ${error.message}`;\n  }\n}\n\nreturn runTool();\n",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"knowledge_id\": {\n      \"type\": \"integer\",\n      \"description\": \"O ID do conhecimento espec√≠fico no qual a busca ser√° realizada.\"\n    },\n    \"query\": {\n      \"type\": \"string\",\n      \"description\": \"A pergunta ou consulta que ser√° usada para realizar a busca no banco vetorial.\"\n    }\n  }\n}"
      },
      "id": "41fc08f8-545b-4630-aa13-8ec4b7b26c85",
      "name": "Retriever",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        -600,
        2460
      ]
    },
    {
      "parameters": {
        "content": "",
        "height": 660,
        "width": 1860,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1420,
        1740
      ],
      "typeVersion": 1,
      "id": "8cca0dfb-74e9-479b-85a4-daeb7626a164",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1100,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1400,
        2080
      ],
      "id": "be558bf9-3986-490d-97da-afe857ba3cd7",
      "name": "Sticky Note9"
    },
    {
      "parameters": {
        "content": "",
        "width": 300,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -780,
        2420
      ],
      "typeVersion": 1,
      "id": "bb80c8c5-a160-46fa-a53f-c0fbe1e83fe7",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "model": "={{ $('RAG Input').item.json.body.mapping.parseJson().system.model }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -720,
        2460
      ],
      "id": "d2ffb844-73bd-434b-82f3-a24f1961c2b0",
      "name": "OpenRouter ",
      "credentials": {
        "openRouterApi": {
          "id": "fbVI3oy00ZqZFPfH",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 700,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1400,
        1760
      ],
      "id": "b1c86e44-32d6-4db3-aea5-094e05d0e47f",
      "name": "Sticky Note10"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1100,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -680,
        1760
      ],
      "id": "1bfd9788-7df8-4dcb-aa39-e3d9e3c3bc3b",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"chatwoot\": {\n    \"account_id\": {{ $('Consumer').first().json.body.account.id }},\n    \"contact_id\": {{ $('Consumer').first().json.body.conversation.contact_inbox.contact_id }},\n\n    \"conversation_id\": {{ $('Consumer').first().json.body.conversation.messages[0].conversation_id }},\n    \"sender_type\": {{ JSON.stringify($('Consumer').first().json.body.conversation.messages[0].sender_type) }},\n    \"bot_token\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.bot_token) }},\n    \"conversation_status\": {{ JSON.stringify($json.current_status) }},\n    \"assignee\": {{ JSON.stringify($('Consumer').first().json.body.conversation?.meta?.assignee?.name || null ) }},\n    \n    \"content\": {{ JSON.stringify(\n      ($('Consumer').first().json.body?.content || '')\n        .replace(\n          /^\\*\\*(.*?)\\*\\*\\n\\n/,\n          $('Consumer').first().json.body.sender.identifier?.match(/@g\\.us$/) ? '' : '$&'\n        )\n        .replace(\n          new RegExp('@' + ($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, ''), 'g'),\n          '@YOU'\n        )\n        .trim()\n    ) }},\n    \n    \"data_url\": {{ JSON.stringify(\n        $('Consumer').first().json.body.conversation.messages?.[0]?.attachments?.[0]?.data_url || null\n      )\n    }},\n    \n    \"message_id\": {{ $('Consumer').first().json.body.id }},\n    \n    \"channel\": {{\n      JSON.stringify(\n        $('Consumer').first().json.body.conversation.channel === 'Channel::Api' \n        ? (\n            /@s\\.whatsapp\\.net$/.test($('Consumer').first().json.body.sender.identifier) \n            ? 'WhatsApp Web' \n            : /@g\\.us$/.test($('Consumer').first().json.body.sender.identifier) \n            ? 'WhatsApp Web Group' \n            : $('Consumer').first().json.body.conversation.channel.replace('Channel::', '')\n          ) \n        : $('Consumer').first().json.body.conversation.channel.replace('Channel::', '')\n      )\n    }},\n    \n    \"user_name\": {{ JSON.stringify(\n      $('Consumer').first().json.body.sender.identifier?.match(/@g\\.us$/)\n        ? (\n            $('Consumer').first().json.body?.content?.match(/^\\*\\*(.*?)\\*\\*/)?.[1] || ''\n          )\n        : $('Consumer').first().json.body.sender?.name || ''\n    ) }},\n\n    \"phone_number\": {{ JSON.stringify($('Consumer').first().json.body.sender.phone_number) || null }},\n\n    \"events\": {{ JSON.stringify($('Get Vars').first().json.events) }}\n  },\n  \n  \"system\": {\n    \"cooldown\": {{ $('Get Vars').first().json.ai_agents.cooldown }},\n    \"workflow_path\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.workflow_path) }},\n    \"model\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.model) }},\n    \"openai_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.openai_key) }},\n    \"directus_token\": {{ JSON.stringify($('Get Vars').first().json.global_vars.directus_token) }},\n    \"stirling_pdf_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.stirling_pdf_key) }},\n    \"elevenlabs_key\": \"{{ $('Get Vars').first().json.global_vars.elevenlabs_key }}\",\n    \"conversations_id\": {{ JSON.stringify($('Get Vars').first().json.conversations.id) }},\n    \"context_window\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.context_window) }},\n    \"enabled_condition\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.enabled_condition) }},\n    \"allow_whatsapp_groups\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.allow_whatsapp_groups) }},\n    \"allow_human_interruption\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.allow_human_interruption) }},\n    \"agent_phone_number\": {{ JSON.stringify(($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, '')) }},\n    \"agent_mentioned\": {{ JSON.stringify(($('Consumer').first().json.body?.content || '' ).includes('@' + ($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, ''))) }},\n    \"agent_name\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.name) }},\n    \"system_message\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.system_message) }},\n    \"user_type\": {{ JSON.stringify($('Get Vars').first().json.users.type) }},\n    \"output_format\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.output_format) }},\n    \"elevenlabs_model\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.elevenlabs_model) }},\n    \"elevenlabs_voice\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.elevenlabs_voice) }},\n    \"chatwoot_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.chatwoot_service) }},\n    \"n8n_webhook_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.n8n_webhook_service) }},\n    \"stirling_pdf_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.stirling_pdf_service) }},\n    \"directus_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.directus_service) }},\n    \"enabled_rag\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.enabled_rag) }},\n    \"ai_agent_id\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.id) }},\n    \"pinecone_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.pinecone_key) }},\n    \"downtime\": {{ new Date(\"1970-01-01T\" + $('Get Vars').first().json.ai_agents.downtime + \"Z\").getTime() / 1000 }},\n    \"clientId\": {{ JSON.stringify($('Get Vars').first().json.global_vars.clientId) }},\n    \"clientSecret\": {{ JSON.stringify($('Get Vars').first().json.global_vars.clientSecret) }},\n    \"refreshToken\": {{ JSON.stringify($('Get Vars').first().json.global_vars.refreshToken) }},\n    \"accessToken\": {{ JSON.stringify($('Get Vars').first().json.global_vars.accessToken) }},\n    \"core_chat_histories\": {{ JSON.stringify($('Get Vars').item.json.core_chat_histories, null, 2) }}\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -700,
        580
      ],
      "id": "cc1cc3ea-47e2-439b-9960-b775136dd90b",
      "name": "Mapping"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        300,
        1100
      ],
      "id": "1391b948-718b-45b7-a5aa-29bc0d8c009f",
      "name": "No Operation "
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\nasync function runTool() {\n  const logArray = [];\n  let currentStatus = \"\";\n  \n  try {\n    console.log(\"Obtendo data de √∫ltima intera√ß√£o e downtime...\");\n    logArray.push(\"Obtendo data de √∫ltima intera√ß√£o e downtime...\");\n    \n    const dateUpdatedStr = $('Get Vars').first().json.users.date_updated;\n    const downtimeStr = $('Get Vars').first().json.ai_agents.downtime;\n    console.log(`date_updated: ${dateUpdatedStr}`);\n    console.log(`downtime: ${downtimeStr}`);\n    logArray.push(`date_updated: ${dateUpdatedStr}`);\n    logArray.push(`downtime: ${downtimeStr}`);\n    \n    // Se downtime for \"00:00:00\", considere desativado e n√£o realizar a requisi√ß√£o.\n    if (downtimeStr === \"00:00:00\") {\n      console.log(\"Downtime √© 00:00:00. Nenhuma a√ß√£o ser√° realizada.\");\n      logArray.push(\"Downtime √© 00:00:00. Nenhuma a√ß√£o ser√° realizada.\");\n      currentStatus = $('Consumer').first().json.body.conversation.status;\n      return [{ json: { current_status: currentStatus, logs: logArray } }];\n    }\n    \n    const lastUpdated = new Date(dateUpdatedStr);\n    const now = new Date();\n    const diffMs = now - lastUpdated;\n    const diffMinutes = (diffMs / 60000).toFixed(2);\n    \n    // Converter downtime (HH:MM:SS) para milissegundos e para minutos\n    const [hours, minutes, seconds] = downtimeStr.split(':').map(Number);\n    const downtimeMs = ((hours * 3600) + (minutes * 60) + seconds) * 1000;\n    const downtimeMinutes = (downtimeMs / 60000).toFixed(2);\n    \n    console.log(`diff: ${diffMinutes} minutes, downtime: ${downtimeMinutes} minutes`);\n    logArray.push(`diff: ${diffMinutes} minutes, downtime: ${downtimeMinutes} minutes`);\n    \n    // Obter conversation status e conversation_id do n√≥ Consumer\n    const conversationStatus = $('Consumer').first().json.body.conversation.status;\n    const convId = $('Consumer').first().json.body.conversation.messages[0].conversation_id;\n    console.log(`conversation status: ${conversationStatus}`);\n    console.log(`conversation_id: ${convId}`);\n    logArray.push(`conversation status: ${conversationStatus}`);\n    logArray.push(`conversation_id: ${convId}`);\n    \n    // Inicialmente, currentStatus recebe o status atual\n    currentStatus = conversationStatus;\n    \n    // Verifica se o tempo de inatividade foi excedido e se conversation.status √© diferente de \"pending\"\n    if (diffMs >= downtimeMs && conversationStatus !== \"pending\") {\n      console.log(\"Condi√ß√µes atendidas: tempo de inatividade excedido e conversation.status n√£o √© 'pending'.\");\n      logArray.push(\"Condi√ß√µes atendidas: tempo de inatividade excedido e conversation.status n√£o √© 'pending'. Tentando abrir conversa no Chatwoot...\");\n      \n      const chatwootService = $('Get Vars').first().json.global_vars.chatwoot_service;\n      const accountId = $('Consumer').first().json.body.account.id;\n      const conversationId = convId;\n      const botToken = $('Get Vars').first().json.ai_agents.bot_token;\n      \n      const toggleUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/toggle_status`;\n      console.log(`Toggle URL: ${toggleUrl}`);\n      logArray.push(`Toggle URL: ${toggleUrl}`);\n      \n      try {\n        const response = await axios.post(\n          toggleUrl,\n          { status: \"pending\" },\n          { headers: { api_access_token: botToken } }\n        );\n        console.log(\"Conversa aberta com sucesso no Chatwoot.\");\n        logArray.push(\"Conversa aberta com sucesso no Chatwoot.\");\n        currentStatus = \"pending\";\n      } catch (err) {\n        console.error(\"Erro ao abrir conversa:\", err.message);\n        logArray.push(`Erro ao abrir conversa: ${err.message}`);\n      }\n    } else {\n      console.log(\"Condi√ß√µes n√£o atendidas: tempo de inatividade n√£o excedido ou conversation.status √© 'pending'. Nenhuma a√ß√£o realizada.\");\n      logArray.push(\"Condi√ß√µes n√£o atendidas: tempo de inatividade n√£o excedido ou conversation.status √© 'pending'. Nenhuma a√ß√£o realizada.\");\n    }\n    \n    return [{ json: { current_status: currentStatus, logs: logArray } }];\n  } catch (error) {\n    console.error(\"Erro geral:\", error.message);\n    logArray.push(`Erro geral: ${error.message}`);\n    return [{ json: { error: error.message, current_status: currentStatus, logs: logArray } }];\n  }\n}\n\nreturn runTool();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -900,
        580
      ],
      "id": "9990a106-8f3e-402f-8a23-6af38a90cf44",
      "name": "Downtime",
      "alwaysOutputData": false
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -100,
        1300
      ],
      "id": "8508753a-1eb9-4d07-9fc3-a171ba5a866f",
      "name": "No Operation 0"
    },
    {
      "parameters": {
        "triggerMode": "listenTrigger",
        "channelName": "specific_channel",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTrigger",
      "typeVersion": 1,
      "position": [
        -180,
        2180
      ],
      "id": "14a66f3e-937f-4bfc-9c10-4772492baffb",
      "name": "Postgres Trigger",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "async function main() {\n  // Fun√ß√£o auxiliar para limitar o tamanho dos logs\n  const trimLog = (msg, limit = 100) =>\n    (typeof msg === 'string' && msg.length > limit ? msg.substring(0, limit) + '...' : msg);\n\n  // Array para armazenar os logs de debug\n  let logs = [];\n\n  try {\n    // Obt√©m o payload do n√≥ \"Postgres Trigger\"\n    const payload = $('Postgres Trigger').first().json.payload;\n    logs.push(\"Payload carregado.\");\n    console.log(\"Payload:\", trimLog(JSON.stringify(payload)));\n\n    // Determina a opera√ß√£o\n    const op = payload.operation;\n    logs.push(\"Opera√ß√£o: \" + op);\n    console.log(\"Opera√ß√£o:\", op);\n\n    // Garante que pinecone_host comece com \"https://\"\n    let pineconeHost = payload.data.pinecone_host;\n    if (!pineconeHost.startsWith(\"https://\")) {\n      pineconeHost = \"https://\" + pineconeHost;\n      logs.push(\"Prefixo 'https://' adicionado.\");\n      console.log(\"pinecone_host modificado:\", pineconeHost);\n    }\n\n    // Configura os headers para o Pinecone\n    const pineconeHeaders = {\n      \"Api-Key\": payload.global_vars.pinecone_key,\n      \"X-Pinecone-API-Version\": \"2024-10\",\n      \"Content-Type\": \"application/json\"\n    };\n    logs.push(\"Headers Pinecone configurados.\");\n    console.log(\"Headers Pinecone:\", pineconeHeaders);\n\n    let endpoint, options, response, mainResponse;\n\n    // Branch para dele√ß√£o: DISABLED ou DELETE\n    if (op === \"DISABLED\" || op === \"DELETE\") {\n      endpoint = pineconeHost + \"/vectors/delete\";\n      logs.push(\"Endpoint para dele√ß√£o: \" + endpoint);\n      console.log(\"Endpoint de dele√ß√£o:\", endpoint);\n\n      const deleteBody = {\n        ids: [payload.data.id],\n        namespace: payload.data.namespace\n      };\n      logs.push(\"Body para dele√ß√£o: \" + trimLog(JSON.stringify(deleteBody)));\n      console.log(\"Body de dele√ß√£o:\", deleteBody);\n\n      options = {\n        method: \"POST\",\n        uri: endpoint,\n        headers: pineconeHeaders,\n        body: deleteBody,\n        json: true\n      };\n\n      response = await this.helpers.request(options);\n      logs.push(\"Resposta da dele√ß√£o recebida.\");\n      console.log(\"Resposta da dele√ß√£o:\", trimLog(JSON.stringify(response)));\n\n      mainResponse = response;\n\n    // Branch para upsert via OpenAI (para UPDATE ou INSERT com enabled true)\n    } else if ((op === \"UPDATE\" || op === \"INSERT\") && payload.data.enabled === true) {\n      let embedding; // Para o upsert no Pinecone\n\n      // Se for INSERT, verifica se j√° existe embedding em Directus (tabela dimensions)\n      if (op === \"INSERT\") {\n        const directusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\n        const directusEndpoint = directusHost + \"/items/dimensions\";\n        const directusHeaders = {\n          \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n          \"Content-Type\": \"application/json\"\n        };\n        logs.push(\"Consultando Directus (dimensions) para vector_id: \" + payload.data.id);\n        console.log(\"Directus endpoint (dimensions):\", directusEndpoint);\n\n        const directusQueryOptions = {\n          method: \"GET\",\n          uri: directusEndpoint,\n          qs: { \"filter[vector_id][_eq]\": payload.data.id },\n          headers: directusHeaders,\n          json: true\n        };\n\n        let directusRecord = await this.helpers.request(directusQueryOptions);\n        logs.push(\"Resposta Directus (dimensions): \" + trimLog(JSON.stringify(directusRecord)));\n        console.log(\"Directus GET response (dimensions):\", trimLog(JSON.stringify(directusRecord)));\n\n        if (\n          directusRecord &&\n          directusRecord.data &&\n          directusRecord.data.length > 0 &&\n          directusRecord.data[0].values\n        ) {\n          let directusValues = directusRecord.data[0].values;\n          // Se for string, converte para array de floats; se j√° for array, utiliza diretamente.\n          if (typeof directusValues === \"string\") {\n            embedding = directusValues.split(\",\").map(item => parseFloat(item.trim()));\n          } else if (Array.isArray(directusValues)) {\n            embedding = directusValues;\n          }\n          logs.push(\"Embedding reutilizado do Directus (dimensions).\");\n          console.log(\"Embedding reutilizado:\", trimLog(JSON.stringify(embedding)));\n        }\n      }\n\n      // Se embedding n√£o foi obtido (ou para UPDATE), gere via OpenAI\n      if (!embedding) {\n        const openAIEndpoint = \"https://api.openai.com/v1/embeddings\";\n        const openAIHeaders = {\n          \"Authorization\": \"Bearer \" + payload.global_vars.openai_key,\n          \"Content-Type\": \"application/json\"\n        };\n        logs.push(\"Endpoint OpenAI: \" + openAIEndpoint);\n        console.log(\"Endpoint OpenAI:\", openAIEndpoint);\n        logs.push(\"Headers OpenAI configurados.\");\n        console.log(\"Headers OpenAI:\", openAIHeaders);\n\n        // Constr√≥i o input para OpenAI (adiciona espa√ßo ap√≥s cada v√≠rgula em similar_questions)\n        const similarQuestionsInput = payload.data.similar_questions\n          ? payload.data.similar_questions.replace(/,/g, ', ')\n          : \"\";\n        const openAIInput = `Context: ${payload.data.context} Question: ${payload.data.question} Answer: ${payload.data.answer} Similar Questions: ${similarQuestionsInput}`;\n        logs.push(\"Input para OpenAI: \" + trimLog(openAIInput));\n        console.log(\"Input OpenAI:\", openAIInput);\n\n        const openAIBody = {\n          input: openAIInput,\n          model: \"text-embedding-3-small\",\n          dimensions: 1536\n        };\n        logs.push(\"Body para OpenAI: \" + trimLog(JSON.stringify(openAIBody)));\n        console.log(\"Body OpenAI:\", openAIBody);\n\n        options = {\n          method: \"POST\",\n          uri: openAIEndpoint,\n          headers: openAIHeaders,\n          body: openAIBody,\n          json: true\n        };\n\n        let openAIResponse = await this.helpers.request(options);\n        logs.push(\"Resposta do OpenAI recebida.\");\n        console.log(\"Resposta OpenAI:\", trimLog(JSON.stringify(openAIResponse)));\n\n        if (openAIResponse && openAIResponse.data && openAIResponse.data.length > 0) {\n          embedding = openAIResponse.data[0].embedding;\n          logs.push(\"Embedding extra√≠do do OpenAI.\");\n          console.log(\"Embedding:\", trimLog(JSON.stringify(embedding)));\n        } else {\n          throw new Error(\"Embedding n√£o retornado pelo OpenAI.\");\n        }\n      }\n\n      // Converte similar_questions CSV para array\n      let similarQuestionsArray = [];\n      if (payload.data.similar_questions) {\n        similarQuestionsArray = payload.data.similar_questions.split(\",\").map(s => s.trim());\n      }\n      logs.push(\"similar_questions convertido para array: \" + trimLog(JSON.stringify(similarQuestionsArray)));\n      console.log(\"similar_questions array:\", similarQuestionsArray);\n\n      // Upsert no Pinecone usando o embedding obtido\n      endpoint = pineconeHost + \"/vectors/upsert\";\n      logs.push(\"Endpoint para upsert (Pinecone): \" + endpoint);\n      console.log(\"Endpoint de upsert:\", endpoint);\n\n      const upsertBody = {\n        vectors: [\n          {\n            id: payload.data.id,\n            values: embedding, // embedding √© um array de floats\n            metadata: {\n              a: payload.data.answer,\n              t: payload.data.context,\n              q: payload.data.question,\n              sq: similarQuestionsArray\n            }\n          }\n        ],\n        namespace: payload.data.namespace\n      };\n      logs.push(\"Body para upsert (Pinecone): \" + trimLog(JSON.stringify(upsertBody)));\n      console.log(\"Body de upsert:\", upsertBody);\n\n      options = {\n        method: \"POST\",\n        uri: endpoint,\n        headers: pineconeHeaders,\n        body: upsertBody,\n        json: true\n      };\n\n      response = await this.helpers.request(options);\n      logs.push(\"Resposta do upsert Pinecone recebida.\");\n      console.log(\"Resposta do upsert:\", trimLog(JSON.stringify(response)));\n\n      mainResponse = response;\n\n      // Atualiza ou cria o registro na tabela dimensions do Directus (como j√° estava implementado)\n      const directusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\n      const directusDimensionsEndpoint = directusHost + \"/items/dimensions\";\n      const directusHeaders = {\n        \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n        \"Content-Type\": \"application/json\"\n      };\n      logs.push(\"Directus dimensions endpoint: \" + directusDimensionsEndpoint);\n      console.log(\"Directus dimensions endpoint:\", directusDimensionsEndpoint);\n\n      const directusQueryOptions = {\n        method: \"GET\",\n        uri: directusDimensionsEndpoint,\n        qs: { \"filter[vector_id][_eq]\": payload.data.id },\n        headers: directusHeaders,\n        json: true\n      };\n\n      let directusRecord = await this.helpers.request(directusQueryOptions);\n      logs.push(\"Resposta Directus (dimensions): \" + trimLog(JSON.stringify(directusRecord)));\n      console.log(\"Directus GET response (dimensions):\", trimLog(JSON.stringify(directusRecord)));\n\n      const currentTimestamp = new Date().toISOString();\n      // Converte o embedding para string sem colchetes\n      const directusValues = Array.isArray(embedding) ? embedding.join(\",\") : embedding;\n      const dimensionsBody = {\n        values: directusValues,\n        vector_id: payload.data.id,\n        date_created: currentTimestamp,\n        date_updated: currentTimestamp\n      };\n\n      if (directusRecord && directusRecord.data && directusRecord.data.length > 0) {\n        const recordId = directusRecord.data[0].id;\n        const directusUpdateEndpoint = directusDimensionsEndpoint + \"/\" + recordId;\n        logs.push(\"Atualizando registro dimensions Directus com id: \" + recordId);\n        console.log(\"Atualizando Directus dimensions em:\", directusUpdateEndpoint);\n\n        const directusUpdateOptions = {\n          method: \"PATCH\",\n          uri: directusUpdateEndpoint,\n          headers: directusHeaders,\n          body: dimensionsBody,\n          json: true\n        };\n\n        const directusUpdateResponse = await this.helpers.request(directusUpdateOptions);\n        logs.push(\"Resposta atualiza√ß√£o Directus dimensions: \" + trimLog(JSON.stringify(directusUpdateResponse)));\n        console.log(\"Directus dimensions update response:\", trimLog(JSON.stringify(directusUpdateResponse)));\n      } else {\n        logs.push(\"Nenhum registro Dimensions Directus encontrado, criando novo.\");\n        console.log(\"Criando novo registro Dimensions Directus.\");\n\n        const directusCreateOptions = {\n          method: \"POST\",\n          uri: directusDimensionsEndpoint,\n          headers: directusHeaders,\n          body: dimensionsBody,\n          json: true\n        };\n\n        const directusCreateResponse = await this.helpers.request(directusCreateOptions);\n        logs.push(\"Resposta cria√ß√£o Directus dimensions: \" + trimLog(JSON.stringify(directusCreateResponse)));\n        console.log(\"Directus dimensions create response:\", trimLog(JSON.stringify(directusCreateResponse)));\n      }\n\n    // Branch para upsert usando valores do \"Get Dimensions\" (caso op seja ENABLED)\n    } else if (op === \"ENABLED\") {\n      endpoint = pineconeHost + \"/vectors/upsert\";\n      logs.push(\"Endpoint para upsert (Get Dimensions): \" + endpoint);\n      console.log(\"Endpoint de upsert:\", endpoint);\n\n      let similarQuestionsArray = [];\n      if (payload.data.similar_questions) {\n        similarQuestionsArray = payload.data.similar_questions.split(\",\").map(s => s.trim());\n      }\n      logs.push(\"similar_questions convertido para array: \" + trimLog(JSON.stringify(similarQuestionsArray)));\n      console.log(\"similar_questions array:\", similarQuestionsArray);\n\n      let values = $('Get Dimensions').first().json.values;\n      if (typeof values === \"string\") {\n        values = values.split(\",\").map(item => parseFloat(item.trim()));\n        logs.push(\"Valores convertidos de string para array: \" + trimLog(JSON.stringify(values)));\n        console.log(\"Valores convertidos:\", values);\n      } else if (Array.isArray(values)) {\n        if (values.length > 0 && typeof values[0] === \"string\") {\n          values = values.map(item => parseFloat(item.trim()));\n          logs.push(\"Valores convertidos de array de strings para floats: \" + trimLog(JSON.stringify(values)));\n          console.log(\"Valores convertidos:\", values);\n        }\n      } else {\n        values = [values];\n        logs.push(\"Valores encapsulados em array: \" + trimLog(JSON.stringify(values)));\n        console.log(\"Valores encapsulados:\", values);\n      }\n\n      const upsertBody = {\n        vectors: [\n          {\n            id: payload.data.id,\n            values: values,\n            metadata: {\n              a: payload.data.answer,\n              t: payload.data.context,\n              q: payload.data.question,\n              sq: similarQuestionsArray\n            }\n          }\n        ],\n        namespace: payload.data.namespace\n      };\n      logs.push(\"Body para upsert (Get Dimensions): \" + trimLog(JSON.stringify(upsertBody)));\n      console.log(\"Body de upsert:\", upsertBody);\n\n      options = {\n        method: \"POST\",\n        uri: endpoint,\n        headers: pineconeHeaders,\n        body: upsertBody,\n        json: true\n      };\n\n      response = await this.helpers.request(options);\n      logs.push(\"Resposta do upsert recebida.\");\n      console.log(\"Resposta do upsert:\", trimLog(JSON.stringify(response)));\n\n      mainResponse = response;\n    } else {\n      logs.push(\"Opera√ß√£o n√£o compat√≠vel. Nenhuma requisi√ß√£o enviada.\");\n      console.log(\"Opera√ß√£o n√£o compat√≠vel.\");\n      mainResponse = { message: \"Opera√ß√£o n√£o compat√≠vel.\" };\n    }\n\n    // Atualiza a tabela vectors_status para os casos ENABLED, DISABLED, INSERT ou UPDATE (ou DELETE)\n    if ([\"ENABLED\", \"DISABLED\", \"INSERT\", \"UPDATE\", \"DELETE\"].includes(op)) {\n      const statusValue = payload.data.enabled === true ? \"#2ECDA7\" : \"#E35169\";\n      const directusStatusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\n      const directusStatusEndpoint = directusStatusHost + \"/items/vectors_status\";\n      const directusHeaders = {\n        \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n        \"Content-Type\": \"application/json\"\n      };\n      logs.push(\"Atualizando tabela vectors_status em: \" + directusStatusEndpoint);\n      console.log(\"Directus vectors_status endpoint:\", directusStatusEndpoint);\n\n      const statusQueryOptions = {\n        method: \"GET\",\n        uri: directusStatusEndpoint,\n        qs: { \"filter[vector_id][_eq]\": payload.data.id },\n        headers: directusHeaders,\n        json: true\n      };\n\n      let statusRecord = await this.helpers.request(statusQueryOptions);\n      logs.push(\"Resposta da consulta vectors_status: \" + trimLog(JSON.stringify(statusRecord)));\n      console.log(\"Directus vectors_status GET response:\", trimLog(JSON.stringify(statusRecord)));\n\n      const currentTimestamp = new Date().toISOString();\n      const statusBody = {\n        value: statusValue,\n        vector_id: payload.data.id,\n        date_created: currentTimestamp,\n        date_updated: currentTimestamp\n      };\n\n      if (statusRecord && statusRecord.data && statusRecord.data.length > 0) {\n        const recordId = statusRecord.data[0].id;\n        const statusUpdateEndpoint = directusStatusEndpoint + \"/\" + recordId;\n        logs.push(\"Atualizando registro vectors_status com id: \" + recordId);\n        console.log(\"Atualizando vectors_status em:\", statusUpdateEndpoint);\n\n        const statusUpdateOptions = {\n          method: \"PATCH\",\n          uri: statusUpdateEndpoint,\n          headers: directusHeaders,\n          body: statusBody,\n          json: true\n        };\n\n        var statusResponse = await this.helpers.request(statusUpdateOptions);\n        logs.push(\"Resposta atualiza√ß√£o vectors_status: \" + trimLog(JSON.stringify(statusResponse)));\n        console.log(\"Directus vectors_status update response:\", trimLog(JSON.stringify(statusResponse)));\n      } else {\n        logs.push(\"Nenhum registro vectors_status encontrado, criando novo.\");\n        console.log(\"Criando novo registro vectors_status.\");\n\n        const statusCreateOptions = {\n          method: \"POST\",\n          uri: directusStatusEndpoint,\n          headers: directusHeaders,\n          body: statusBody,\n          json: true\n        };\n\n        var statusResponse = await this.helpers.request(statusCreateOptions);\n        logs.push(\"Resposta cria√ß√£o vectors_status: \" + trimLog(JSON.stringify(statusResponse)));\n        console.log(\"Directus vectors_status create response:\", trimLog(JSON.stringify(statusResponse)));\n      }\n    }\n\n    return [{\n      json: {\n        mainResponse,\n        logs\n      }\n    }];\n  } catch (error) {\n    console.error(\"Erro:\", error);\n    logs.push(\"Erro: \" + error.message);\n    return [{\n      json: {\n        error: error.message,\n        logs\n      }\n    }];\n  }\n}\n\nreturn main();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        2180
      ],
      "id": "d31c7c9a-a837-4f69-b5c7-9fa5e5a792d1",
      "name": "Update Vectors"
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "dimensions",
          "mode": "list",
          "cachedResultName": "dimensions"
        },
        "returnAll": true,
        "where": {
          "values": [
            {
              "column": "vector_id",
              "value": "={{ $json.payload.data.id }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        20,
        2180
      ],
      "id": "f62eaf07-9275-4845-bbf7-3a49cf42160c",
      "name": "Get Dimensions",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 700,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -280,
        2080
      ],
      "id": "4a2caf6e-ee2d-4767-9774-092cd7bff5cb",
      "name": "Sticky Note15"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -540,
        2180
      ],
      "id": "83b2bc4b-d2a1-4e10-adf2-86e70eb07f2e",
      "name": "No Operation 3"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH knowledge_descriptions AS (\n  SELECT json_agg(\n    json_build_object(\n      'id', k.id,\n      'description', k.description,\n      'pinecone_host', ph.value,\n      'namespace', ns.value\n    )\n  ) AS knowledge_data\n  FROM knowledge_ai_agents kaa\n  JOIN knowledge k ON k.id = kaa.knowledge_id\n  LEFT JOIN pinecone_host ph ON ph.id = k.pinecone_host_id\n  LEFT JOIN namespace ns ON ns.id = k.name_id\n  WHERE kaa.ai_agents_id = {{ $('RAG Input').item.json.body.mapping.parseJson().system.ai_agent_id }}\n),\nchat_histories AS (\n  SELECT json_agg(ch.*) AS chat_items\n  FROM core_chat_histories ch\n  WHERE ch.session_id = '{{ $('RAG Input').item.json.body.mapping.parseJson().system.conversations_id }}'\n)\nSELECT\n  (SELECT knowledge_data FROM knowledge_descriptions) AS knowledge,\n  (SELECT chat_items FROM chat_histories) AS chat_histories;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1100,
        2180
      ],
      "id": "fac17f0f-52f1-46a1-8978-93ff90435f7f",
      "name": "Get History",
      "credentials": {
        "postgres": {
          "id": "zftfnmd5SAWF1ri0",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "name": "scheduling",
        "description": "Ferramenta para gerenciar agendamentos e compromissos atrav√©s do n8n. Processa solicita√ß√µes relacionadas a cria√ß√£o, atualiza√ß√£o, consulta e cancelamento de eventos agendados.\n",
        "jsCode": "// SchedulingAssistant tool for n8n\nconst axios = require('axios');\n\n// Parse the incoming query and mapping data\ntry {\n  // Access the operation from the input query\n  const params = query;\n  \n  // Get the mapping data\n  const mapping = JSON.parse($('Core Input').item.json.body.mapping);\n  \n  // Define the webhook URL using the mapping\n  const url = `http://${mapping.system.n8n_webhook_service}:5678/webhook/scheduling`;\n  \n  // Prepare payload with operation details\n  const payload = {\n    params: { \n      ...params \n    },\n    mapping: mapping\n  };\n  \n  // Send request to webhook endpoint\n  const response = await axios.post(url, payload);\n  \n  // Return webhook response as string\n  return JSON.stringify(response.data);\n  \n} catch (error) {\n  // Handle errors\n  return `Error processing request: ${error.message}`;\n}",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"operation\": {\n      \"type\": \"string\",\n      \"description\": \"The scheduling operation\",\n      \"enum\": [\"create\", \"update\", \"query\", \"delete\", \"query-slots\"]\n    },\n    \"dateTime\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"description\": \"Data e hora do agendamento (hor√°rio de Bras√≠lia)\"\n    },\n    \"newDateTime\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"description\": \"Nova data e hora para o agendamento quando estiver atualizando (hor√°rio de Bras√≠lia)\"\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"description\": \"T√≠tulo do agendamento\",\n      \"default\": \"compromisso\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"Descri√ß√£o do agendamento\",\n      \"default\": \"nenhuma\"\n    },\n    \"calendarId\": {\n      \"type\": \"string\",\n      \"description\": \"Identificador do calend√°rio\",\n      \"default\": \"primary\"\n    }\n  },\n  \"required\": [\"operation\", \"dateTime\"],\n  \"dependencies\": {\n    \"operation\": {\n      \"oneOf\": [\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"update\"]\n            }\n          },\n          \"required\": [\"newDateTime\"]\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"create\", \"query\", \"query-slots\"]\n            }\n          }\n        }\n      ]\n    }\n  },\n  \"additionalProperties\": false\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1500,
        1580
      ],
      "id": "7a796314-1f8a-4efc-8e3f-799cd66e7ae4",
      "name": "Scheduling"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 500,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        960,
        840
      ],
      "id": "cb3cf431-dbba-4669-9caa-a6f4d62b54d7",
      "name": "Sticky Note12"
    },
    {
      "parameters": {
        "content": "",
        "height": 340,
        "width": 540,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        940,
        820
      ],
      "typeVersion": 1,
      "id": "0b5dee9e-9557-43a3-a6ab-106176749969",
      "name": "Sticky Note16"
    },
    {
      "parameters": {
        "content": "Modulo de agendamento",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1000,
        800
      ],
      "id": "768376fe-f7a1-46b1-9cac-9830236e35e8",
      "name": "Sticky Note17"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "scheduling",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        1060,
        940
      ],
      "id": "d7234d25-ff53-4156-8ec0-cb2d151ba181",
      "name": "Scheduling Trigger",
      "webhookId": "e5ac896b-72e2-4095-a781-3ce17a36b792"
    },
    {
      "parameters": {
        "jsCode": "const CONFIG = {\n  timezone: 'America/Sao_Paulo',  // Fuso hor√°rio padr√£o\n  maxCommitmentsPerClient: -1,    // -1 para desativar, 1 para um agendamento por email\n  saveToDirectus: true,           // Habilitar salvamento no Directus\n  validateBeforeBooking: true,    // Habilitar valida√ß√£o de horario antes do agendamento\n  startHour: 9,                   // Par√¢metros de inicio do hor√°rio comercial \n  endHour: 18,                    // Par√¢metros de fim do hor√°rio comercial \n  defaultDuration: 60             // Dura√ß√£o padr√£o em minutos\n};\n\nconst inputData = $('Scheduling Trigger').first().json.body.params\nconst inputMapping = $('Scheduling Trigger').first().json.body.mapping;\nconst systemData = inputMapping.system;\nconst chatwootData = inputMapping.chatwoot;\nconst eventData = chatwootData.events\n      .filter(calendar => calendar.calendar_id == inputData.calendarId);\nconst { contact_id } = chatwootData;\nconst logs = [];\n\nconst credentials = {\n  accessToken: systemData.accessToken,\n  refreshToken: systemData.refreshToken,\n  clientId: systemData.clientId,\n  clientSecret: systemData.clientSecret,\n  directusToken: systemData.directus_token,\n  directusService: systemData.directus_service\n};\n\nconst dayjs = require('dayjs');\nconst utc = require('dayjs/plugin/utc');\nconst timezone = require('dayjs/plugin/timezone');\nconst isSameOrAfter = require('dayjs/plugin/isSameOrAfter');\nconst isSameOrBefore = require('dayjs/plugin/isSameOrBefore');\n\n// Configurar os plugins do dayjs logo no in√≠cio\ndayjs.extend(utc);\ndayjs.extend(timezone);\ndayjs.extend(isSameOrAfter);\ndayjs.extend(isSameOrBefore);\n\n// Definir timezone padr√£o para todas as opera√ß√µes\ndayjs.tz.setDefault(CONFIG.timezone);\n\n// =========================================================\n// FUN√á√ïES AUXILIARES PARA MANIPULA√á√ÉO DE DATAS\n// =========================================================\n\n// Converte uma data para o formato UTC (para salvar no Directus)\nfunction formatToUTC(dateTime) {\n  // Garantir que estamos tratando a data no timezone local primeiro\n  const localDate = dayjs(dateTime).tz(CONFIG.timezone);\n  // Converter para UTC\n  return localDate.utc().format();\n}\n\n// Converte uma data de UTC para o fuso hor√°rio local (para exibi√ß√£o)\nfunction formatFromUTC(dateTime, format = null) {\n  const localDate = dayjs(dateTime).tz(CONFIG.timezone);\n  return format ? localDate.format(format) : localDate;\n}\n\n// Extrai componentes de data e hora de uma string ISO\nfunction extractDateTimeComponents(dateTimeStr) {\n  // Garantir que estamos lidando com a data no fuso hor√°rio correto\n  const dateTime = dayjs(dateTimeStr).tz(CONFIG.timezone);\n  \n  return {\n    date: dateTime.format('YYYY-MM-DD'),\n    time: dateTime.format('HH:mm'),\n    dateTime: dateTime.format(), // ISO string completo\n    formattedDate: dateTime.format('DD/MM/YYYY'), // Formato brasileiro\n    formattedTime: dateTime.format('HH:mm')\n  };\n}\n\n// =========================================================\n// FUN√á√ïES AUXILIARES\n// =========================================================\n\nfunction log(message, data = null) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    message\n  };\n  \n  if (data) {\n    if (typeof data === 'string' && data.length > 200) {\n      entry.data = data.substring(0, 200) + '... (truncado)';\n    } else if (typeof data === 'object') {\n      const stringified = JSON.stringify(data);\n      entry.data = stringified.length > 200 \n        ? JSON.stringify(data).substring(0, 200) + '... (truncado)' \n        : data;\n    } else {\n      entry.data = data;\n    }\n  }\n  \n  logs.push(entry);\n}\n\nfunction calculateDateTime() {\n  if (!inputData.dateTime) {\n    throw new Error(\"Para criar um evento, forne√ßa uma data e hora.\");\n  }\n\n  // Garantir que as datas est√£o no fuso hor√°rio local\n  const startTime = formatFromUTC(inputData.dateTime);\n  const endTime = startTime.add(CONFIG.defaultDuration, 'minute');\n\n  return {\n    startTime,\n    endTime\n  };\n}\n\nfunction createClient(token) {\n  const axios = require('axios');\n  return {\n    get: (url, params = {}) => axios({\n      method: 'get',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` },\n      params\n    }),\n    post: (url, data) => axios({\n      method: 'post',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    put: (url, data) => axios({\n      method: 'put',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    delete: (url) => axios({\n      method: 'delete',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` }\n    })\n  };\n};\n\nasync function validateAvailability(token, calendarId, dateTime, duration) {\n  log('Validando disponibilidade para agendamento', { calendarId, dateTime, duration });\n  \n  try {\n    // Calcular hor√°rio de in√≠cio e fim no fuso hor√°rio local\n    const startTime = formatFromUTC(dateTime);\n    const endTime = startTime.add(duration, 'minute');\n    \n    log('Per√≠odo para valida√ß√£o:', {\n      start: startTime.format('YYYY-MM-DD HH:mm'),\n      end: endTime.format('YYYY-MM-DD HH:mm')\n    });\n    \n    // Para o Google Calendar, precisamos enviar em UTC ISO\n    // O Google Calendar vai interpretar corretamente baseado no timezone especificado no evento\n    const timeMin = startTime.subtract(1, 'minute').toISOString();\n    const timeMax = endTime.add(1, 'minute').toISOString();\n    \n    const client = createClient(token);\n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n      {\n        timeMin,\n        timeMax,\n        singleEvents: true,\n        orderBy: 'startTime'\n      }\n    );\n    \n    // Filtrar apenas eventos que se sobrep√µem ao per√≠odo desejado\n    const conflictingEvents = (response.data.items || []).filter(event => {\n      // Pular eventos cancelados\n      if (event.status === 'cancelled') return false;\n      \n      // Converter hor√°rios do evento para o mesmo fuso hor√°rio local\n      const eventStart = event.start.dateTime \n        ? formatFromUTC(event.start.dateTime)\n        : formatFromUTC(event.start.date).startOf('day');\n        \n      const eventEnd = event.end.dateTime \n        ? formatFromUTC(event.end.dateTime)\n        : formatFromUTC(event.end.date).endOf('day');\n        \n      // Verificar sobreposi√ß√£o\n      // Caso 1: Evento come√ßa durante o per√≠odo desejado\n      const startsInPeriod = eventStart.isAfter(startTime) && eventStart.isBefore(endTime);\n      \n      // Caso 2: Evento termina durante o per√≠odo desejado\n      const endsInPeriod = eventEnd.isAfter(startTime) && eventEnd.isBefore(endTime);\n      \n      // Caso 3: Evento engloba completamente o per√≠odo desejado\n      const surroundsPeriod = eventStart.isSameOrBefore(startTime) && eventEnd.isSameOrAfter(endTime);\n      \n      // Caso 4: Exata correspond√™ncia de in√≠cio ou fim\n      const exactMatchStart = eventStart.isSame(startTime);\n      const exactMatchEnd = eventEnd.isSame(endTime);\n      \n      return startsInPeriod || endsInPeriod || surroundsPeriod || exactMatchStart || exactMatchEnd;\n    });\n    \n    const isAvailable = conflictingEvents.length === 0;\n    \n    if (isAvailable) {\n      log('Hor√°rio dispon√≠vel para agendamento');\n    } else {\n      log('Conflito de agendamento detectado', \n        conflictingEvents.map(e => ({\n          title: e.summary, \n          start: e.start.dateTime || e.start.date,\n          end: e.end.dateTime || e.end.date\n        }))\n      );\n    }\n    \n    return {\n      available: isAvailable,\n      conflictingEvents: isAvailable ? [] : conflictingEvents.map(e => ({\n        title: e.summary || 'Sem t√≠tulo',\n        start: e.start.dateTime || e.start.date,\n        end: e.end.dateTime || e.end.date,\n        id: e.id\n      }))\n    };\n  } catch (error) {\n    // Verificar se √© erro de token expirado - se for, deixe propagar para executeWithToken tratar\n    if (error.response && error.response.status === 401) {\n      log('Token expirado durante valida√ß√£o de disponibilidade, propagando erro');\n      throw error; // Propagar o erro para executeWithToken tratar\n    }\n    \n    // Para outros erros, continuamos com o comportamento atual\n    log('Erro ao validar disponibilidade', error.message);\n    return {\n      available: false,\n      error: error.message,\n      errorType: 'validation_error'\n    };\n  }\n}\n\nasync function getCalendarName(token, calendarId) {\n  log(`Buscando informa√ß√µes do calend√°rio: ${calendarId}`);\n  \n  try {\n    const client = createClient(token);\n    let response;\n    \n    try {\n      response = await client.get(\n        `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}`\n      );\n      log('Resposta da API Google:', response.data);\n    } catch (error) {\n      // Se for erro de token expirado, tenta renovar e fazer nova requisi√ß√£o\n      if (error.response && error.response.status === 401) {\n        log('Token expirado durante busca de calend√°rio, renovando');\n        try {\n          const newToken = await refreshGoogleToken();\n          credentials.accessToken = newToken; // Atualizar o token localmente\n          const newClient = createClient(newToken);\n          \n          try {\n            response = await newClient.get(\n              `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}`\n            );\n            log('Resposta da API Google ap√≥s renova√ß√£o de token:', response.data);\n          } catch (secondError) {\n            // Se falhar novamente, usamos o ID como nome\n            log('Falha na segunda tentativa de buscar nome do calend√°rio', secondError.message);\n            return calendarId;\n          }\n        } catch (renewError) {\n          log('Erro ao renovar token', renewError.message);\n          return calendarId; // Fallback para ID em caso de erro na renova√ß√£o\n        }\n      } else {\n        // Outros erros\n        log('Erro n√£o relacionado a token expirado:', error.message);\n        throw error;\n      }\n    }\n\n    // O nome do calend√°rio est√° no campo \"summary\"\n    const calendarName = response.data.summary || 'Calend√°rio sem nome';\n    log(`Nome do calend√°rio obtido: ${calendarName}`);\n    return calendarName;\n  } catch (error) {\n    log('Erro ao buscar nome do calend√°rio', error.message);\n    \n    // Para calend√°rios especiais como \"primary\", podemos definir nomes amig√°veis\n    if (calendarId === 'primary') {\n      return 'Calend√°rio Principal';\n    }\n    \n    // Em caso de erro, retorna o pr√≥prio ID como nome\n    return calendarId;\n  }\n}\n\nasync function ensureSchedulingRelation(calendarId) {\n  if (!CONFIG.saveToDirectus) return { calendarId, calendarName: calendarId };\n  \n  log('Verificando/criando rela√ß√£o na tabela scheduling para calendar_id', calendarId);\n  \n  try {\n    const client = createClient(credentials.directusToken);\n    \n    // Obter o nome do calend√°rio (com tratamento de erros aprimorado)\n    const token = credentials.accessToken;\n    let calendarName;\n    \n    try {\n      calendarName = await getCalendarName(token, calendarId);\n    } catch (error) {\n      // Se falhar ao obter o nome, usa o ID como fallback\n      log('Falha ao obter nome do calend√°rio, usando ID como fallback', error.message);\n      calendarName = calendarId;\n    }\n    \n    // Verificar se o calend√°rio j√° existe na tabela scheduling\n    const searchResponse = await client.get(\n      `http://${credentials.directusService}:8055/items/event_history_user`\n    );\n\n    const calendars = searchResponse.data.data;\n    const calendarCurrent = calendars.find(calendar => calendar.calendar_id === calendarId && calendar.user_id === contact_id);\n    let newCalendarId = null;\n\n    // Se n√£o existir, criar o registro\n    if (!calendarCurrent) {\n      log('Criando novo registro na tabela scheduling', { calendarId, calendarName, contact_id });\n      \n      const response = await client.post(\n        `http://${credentials.directusService}:8055/items/event_history_user`,\n        {\n          name: calendarName,\n          calendar_id: calendarId,\n          user_id: contact_id\n        }\n      );\n\n      newCalendarId = response.data.data.id;\n      \n      log('Rela√ß√£o na tabela scheduling criada com sucesso');\n    } else {\n      // Verificar se precisamos atualizar o nome do calend√°rio\n      if (calendarCurrent.name !== calendarName && calendarName !== calendarId) {\n        // S√≥ atualiza se tivermos um nome real (diferente do ID)\n        log('Atualizando nome do calend√°rio na tabela scheduling', { \n          oldName: calendarCurrent.name, \n          newName: calendarName \n        });\n        const axios = require('axios');\n\n        await axios({\n          method: 'patch',\n          url: `http://${credentials.directusService}:8055/items/event_history_user/${calendarCurrent.id}`,\n          headers: {\n            'Authorization': `Bearer ${credentials.directusToken}`,\n            'Content-Type': 'application/json'\n          },\n          data: {\n            name: calendarName\n          }\n        });\n        \n        log('Nome do calend√°rio atualizado com sucesso');\n      } else {\n        log('Rela√ß√£o na tabela scheduling j√° existe');\n      }\n    }\n    \n    return {\n      id: newCalendarId || calendarCurrent.id,\n      calendarId,\n      calendarName\n    };\n  } catch (error) {\n    // Log detalhado para ajudar no debug\n    if (error.response) {\n      log('Detalhes do erro ao criar rela√ß√£o scheduling', {\n        status: error.response.status,\n        data: error.response.data,\n        headers: error.response.headers\n      });\n    } else if (error.request) {\n      log('Erro na resposta do Directus', error.request);\n    }\n    \n    log('Erro ao verificar/criar rela√ß√£o na tabela scheduling', error.message);\n    return {\n      calendarId,\n      calendarName: calendarId // Fallback para o ID em caso de erro\n    };\n  }\n}\n\nasync function saveToDirectus(eventData) {\n  if (!CONFIG.saveToDirectus) return true;\n  \n  log('Salvando agendamento no Directus', eventData);\n  \n  try {\n    \n    // Primeiro, verificar/criar a rela√ß√£o na tabela scheduling\n    const calendarId = inputData.calendarId || 'primary';\n    const scheduling = await ensureSchedulingRelation(calendarId);\n\n    // Converter a data para UTC antes de salvar no Directus\n    const dateInUTC = formatToUTC(eventData.startTime);\n    log('Data convertida para UTC para salvar no Directus:', dateInUTC);\n    \n    // Preparar dados para envio\n    const directusData = {\n      title: eventData.title,\n      description: eventData.description || '',\n      date: dateInUTC,  // Aqui garantimos que estamos salvando em UTC\n      event_id: eventData.eventId,\n      session_id: scheduling.id, \n      calendar_id: calendarId\n    };\n    \n    log('Payload para Directus', directusData);\n    \n    // Realizar a requisi√ß√£o\n    const client = createClient(credentials.directusToken);\n    await client.post(\n      `http://${credentials.directusService}:8055/items/event_history`,\n      directusData\n    );\n    \n    log('Agendamento salvo com sucesso no Directus');\n    return true;\n  } catch (error) {\n    if (error.response) {\n      log('Detalhes do erro do Directus', {\n        status: error.response.status,\n        data: error.response.data,\n        headers: error.response.headers\n      });\n    } else if (error.request) {\n      log('Erro na resposta do Directus', error.request);\n    }\n    log('Erro ao salvar agendamento no Directus', error.message);\n    return false;\n  }\n}\n\nasync function refreshGoogleToken() {\n  log('Renovando token do Google');\n\n  try {\n    const axios = require('axios');\n    const qs = require('querystring');\n\n    const response = await axios({\n      method: 'post',\n      url: 'https://oauth2.googleapis.com/token',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      data: qs.stringify({\n        client_id: credentials.clientId,\n        client_secret: credentials.clientSecret,\n        refresh_token: credentials.refreshToken,\n        grant_type: 'refresh_token'\n      })\n    });\n    \n    const newToken = response.data.access_token;\n    \n    // Atualizar token no Directus\n    await axios({\n      method: 'patch',\n      url: `http://${credentials.directusService}:8055/items/global_vars`,\n      headers: {\n        'Authorization': `Bearer ${credentials.directusToken}`,\n        'Content-Type': 'application/json'\n      },\n      data: { accessToken: newToken }\n    });\n    \n    log('Token renovado e atualizado com sucesso');\n    return newToken;\n  } catch (error) {\n    log('Erro ao renovar token', error.message);\n    throw error;\n  }\n}\n\nasync function executeWithToken(operation) {\n  try {\n    return await operation(credentials.accessToken);\n  } catch (error) {\n    // Se for erro de token expirado, renovar e tentar novamente\n    if (error.response && error.response.status === 401) {\n      log('Token expirado, renovando e tentando novamente');\n      try {\n        const newToken = await refreshGoogleToken();\n        credentials.accessToken = newToken; // Atualizar o token localmente tamb√©m\n        const result = await operation(newToken);\n        return {\n          ...result,\n          message: result.message + \" (ap√≥s renova√ß√£o do token)\"\n        };\n      } catch (renewError) {\n        log('Erro ao renovar token durante executeWithToken', renewError.message);\n        throw { message: 'Falha ao renovar token: ' + renewError.message, errorType: 'token_refresh_failed' };\n      }\n    }\n    \n    // Outros erros\n    const errorMsg = error.message || 'Erro desconhecido';\n    let errorType = \"general_error\";\n    \n    if (errorMsg.includes(\"Limite m√°ximo\")) errorType = \"appointment_limit_exceeded\";\n    if (errorMsg.includes(\"Acesso negado\") || errorMsg.includes(\"Email obrigat√≥rio\")) errorType = \"access_denied\";\n    \n    throw { message: errorMsg, errorType };\n  }\n}\n\n// =========================================================\n// FUN√á√ïES BASE\n// =========================================================\n\nasync function createEvent(token) {\n  const calendarId = inputData.calendarId ? inputData.calendarId : \"primary\";\n  let { title, description } = inputData;\n\n  if (!title) {\n    throw new Error(\"Para criar um evento, forne√ßa um t√≠tulo\");\n  }\n\n  const { startTime, endTime } = calculateDateTime();\n  \n  // Validar disponibilidade se a op√ß√£o estiver ativada\n  if (CONFIG.validateBeforeBooking) {\n    log('Validando disponibilidade antes de agendar');\n    \n    // Usamos executeWithToken para garantir a renova√ß√£o de token se necess√°rio\n    const validateWithToken = async (currentToken) => {\n      return await validateAvailability(\n        currentToken,\n        calendarId,\n        startTime.format(),\n        CONFIG.defaultDuration\n      );\n    };\n    \n    const validationResult = await executeWithToken(validateWithToken);\n    \n    if (!validationResult.available) {\n      // Hor√°rio n√£o dispon√≠vel, retornar erro com detalhes\n      const errorMsg = \"O hor√°rio solicitado j√° est√° ocupado.\";\n      log(errorMsg, validationResult.conflictingEvents);\n      \n      throw {\n        message: errorMsg,\n        errorType: \"scheduling_conflict\",\n        conflictingEvents: validationResult.conflictingEvents\n      };\n    }\n  }\n\n  // Verificar limite de agendamentos\n  if (CONFIG.maxCommitmentsPerClient != -1) {\n    if (eventData.length >= CONFIG.maxCommitmentsPerClient) {\n      throw new Error(`Limite m√°ximo de ${CONFIG.maxCommitmentsPerClient} agendamento(s) excedido.`);\n    }\n  }\n\n  const event = {\n    summary: title,\n    description: description || '',\n    start: {\n      dateTime: startTime.toISOString(),\n      timeZone: CONFIG.timezone\n    },\n    end: {\n      dateTime: endTime.toISOString(),\n      timeZone: CONFIG.timezone\n    }\n  };\n\n  log('Criando evento', { title, calendarId });\n  \n  let client = createClient(token);\n  const response = await client.post(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n    event\n  );\n\n  // Formatar os hor√°rios no fuso hor√°rio local para exibi√ß√£o\n  const formattedStartTime = startTime.format();\n  const formattedEndTime = endTime.format();\n\n  let savedToDirectus = false;\n  if(CONFIG.saveToDirectus){\n    // Dados para salvar no Directus\n    const eventData = {\n      title,\n      description: description || '',\n      startTime: formattedStartTime,\n      endTime: formattedEndTime,\n      eventId: response.data.id\n    };\n    savedToDirectus = await saveToDirectus(eventData);\n  }\n\n  return {\n    success: true,\n    message: \"Evento criado com sucesso\" + (savedToDirectus ? \" e registrado no event_history\" : \"\"),\n    eventId: response.data.id,\n    eventLink: response.data.htmlLink,\n    startTime: formattedStartTime,\n    endTime: formattedEndTime,\n    savedToDirectus\n  };\n}\n\nasync function updateEvent(token) {\n  log('Iniciando processo de atualiza√ß√£o de evento');\n  \n  try {\n    // Verificar par√¢metros obrigat√≥rios\n    const calendarId = inputData.calendarId || 'primary';\n    \n    if (!inputData.dateTime) {\n      throw new Error(\"Para atualizar um evento, forne√ßa a data e hora original do agendamento.\");\n    }\n    \n    if (!inputData.newDateTime && !inputData.title && !inputData.description) {\n      throw new Error(\"Para atualizar um evento, forne√ßa pelo menos um novo valor (data/hora, t√≠tulo ou descri√ß√£o).\");\n    }\n    \n    log('Tentando atualizar evento no calend√°rio:', calendarId);\n    log('Data/hora original:', inputData.dateTime);\n    \n    if (inputData.newDateTime) {\n      log('Nova data/hora:', inputData.newDateTime);\n    }\n    \n    // Extrair data e hora original para buscar o evento - usando nossa fun√ß√£o auxiliar\n    const originalDateTime = formatFromUTC(inputData.dateTime);\n    const originalDateTimeComponents = extractDateTimeComponents(originalDateTime.format());\n    \n    log('Buscando evento com data:', originalDateTimeComponents.date, 'e hora:', originalDateTimeComponents.time);\n    \n    // Verificar se h√° eventos dispon√≠veis\n    if (!eventData || !Array.isArray(eventData) || eventData.length === 0) {\n      log('Nenhum evento encontrado para este calend√°rio');\n      return {\n        message: \"Nenhum evento encontrado para atualizar neste calend√°rio.\",\n        success: false\n      };\n    }\n    \n    // Filtrar eventos do calend√°rio especificado\n    const calendarEvents = eventData.filter(event => event.calendar_id === calendarId);\n    \n    if (calendarEvents.length === 0) {\n      log('Nenhum evento encontrado para este calend√°rio espec√≠fico');\n      return {\n        message: \"Nenhum evento encontrado para este calend√°rio.\",\n        success: false\n      };\n    }\n    \n    // Buscar evento que corresponda √† data e hora original\n    const eventToUpdate = calendarEvents.find(event => {\n      // Converter data/hora do evento do Directus para local usando nossa fun√ß√£o auxiliar\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n      \n      // Verificar correspond√™ncia de data e hora\n      const dateMatches = eventDateTimeComponents.date === originalDateTimeComponents.date;\n      const timeMatches = eventDateTimeComponents.time === originalDateTimeComponents.time;\n      \n      log(`Comparando evento: ${event.title}, data: ${eventDateTimeComponents.date} (match: ${dateMatches}), hora: ${eventDateTimeComponents.time} (match: ${timeMatches})`);\n      \n      return dateMatches && timeMatches;\n    });\n    \n    if (!eventToUpdate) {\n      // Se n√£o encontrar o evento exato, retornar todos os eventos dispon√≠veis\n      const allEvents = calendarEvents.map(event => {\n        // Converter data/hora do evento do Directus para local\n        const eventDateTime = formatFromUTC(event.date);\n        const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n        \n        return {\n          id: event.id,\n          title: event.title,\n          description: event.description || '',\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          dateTime: eventDateTime.format(),\n          eventId: event.event_id\n        };\n      });\n      \n      // Ordenar por data/hora\n      allEvents.sort((a, b) => {\n        if (a.date !== b.date) return a.date.localeCompare(b.date);\n        return a.time.localeCompare(b.time);\n      });\n      \n      log('Evento n√£o encontrado, retornando lista de eventos dispon√≠veis');\n      \n      return {\n        message: `Nenhum evento encontrado na data e hora especificadas. Voc√™ possui ${allEvents.length} eventos neste calend√°rio.`,\n        success: false,\n        events: allEvents\n      };\n    }\n    \n    log('Evento encontrado para atualiza√ß√£o:', {\n      id: eventToUpdate.id,\n      eventId: eventToUpdate.event_id,\n      title: eventToUpdate.title,\n      date: formatFromUTC(eventToUpdate.date).format('YYYY-MM-DD HH:mm')\n    });\n    \n    // Se vai atualizar a data/hora, validar disponibilidade\n    if (inputData.newDateTime && CONFIG.validateBeforeBooking) {\n      log('Validando disponibilidade para a nova data/hora');\n      \n      // Usar executeWithToken para garantir renova√ß√£o do token se necess√°rio\n      const validateWithToken = async (currentToken) => {\n        return await validateAvailability(\n          currentToken,\n          calendarId,\n          inputData.newDateTime,\n          CONFIG.defaultDuration\n        );\n      };\n      \n      const validationResult = await executeWithToken(validateWithToken);\n      \n      // Verificar se o resultado encontrou conflitos al√©m do pr√≥prio evento\n      if (!validationResult.available) {\n        // Filtrar o pr√≥prio evento da lista de conflitos\n        const otherConflicts = validationResult.conflictingEvents.filter(\n          conflict => conflict.id !== eventToUpdate.event_id\n        );\n        \n        if (otherConflicts.length > 0) {\n          // Hor√°rio n√£o dispon√≠vel, retornar erro com detalhes\n          const errorMsg = \"O novo hor√°rio solicitado est√° ocupado por outro evento.\";\n          log(errorMsg, otherConflicts);\n          \n          throw {\n            message: errorMsg,\n            errorType: \"scheduling_conflict\",\n            conflictingEvents: otherConflicts\n          };\n        }\n      }\n    }\n    \n    // Preparar dados para a atualiza√ß√£o no Google Calendar\n    const { startTime, endTime } = inputData.newDateTime \n      ? {\n          startTime: formatFromUTC(inputData.newDateTime),\n          endTime: formatFromUTC(inputData.newDateTime).add(CONFIG.defaultDuration, 'minute')\n        }\n      : {\n          startTime: formatFromUTC(inputData.dateTime),\n          endTime: formatFromUTC(inputData.dateTime).add(CONFIG.defaultDuration, 'minute')\n        };\n    \n    // Construir o objeto de atualiza√ß√£o\n    const updatedEvent = {\n      summary: inputData.title || eventToUpdate.title,\n      description: inputData.description !== undefined ? inputData.description : eventToUpdate.description || '',\n      start: {\n        dateTime: startTime.toISOString(),\n        timeZone: CONFIG.timezone\n      },\n      end: {\n        dateTime: endTime.toISOString(),\n        timeZone: CONFIG.timezone\n      }\n    };\n    \n    log('Enviando atualiza√ß√£o para o Google Calendar', updatedEvent);\n    \n    // Executar a atualiza√ß√£o no Google Calendar\n    const updateGoogleCalendar = async (currentToken) => {\n      const client = createClient(currentToken);\n      return await client.put(\n        `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventToUpdate.event_id)}`,\n        updatedEvent\n      );\n    };\n    \n    // Usar executeWithToken para garantir renova√ß√£o do token se necess√°rio\n    const response = await executeWithToken(updateGoogleCalendar);\n    \n    log('Evento atualizado no Google Calendar com sucesso');\n    \n    // Atualizar no Directus se necess√°rio\n    if (CONFIG.saveToDirectus) {\n      try {\n        // Preparar dados para atualiza√ß√£o no Directus\n        const directusData = {\n          title: inputData.title || eventToUpdate.title,\n          description: inputData.description !== undefined ? inputData.description : eventToUpdate.description || ''\n        };\n        \n        // Se a data foi alterada, atualizar tamb√©m - sempre salvando em UTC\n        if (inputData.newDateTime) {\n          const dateInUTC = formatToUTC(startTime);\n          directusData.date = dateInUTC;\n          log('Nova data em UTC para o Directus:', dateInUTC);\n        }\n        \n        log('Atualizando evento no Directus', directusData);\n\n        // Atualizar no Directus - Usando PATCH em vez de PUT\n        const axios = require('axios');\n        \n        // Atualizar no Directus\n        await axios({\n          method: 'patch',\n          url: `http://${credentials.directusService}:8055/items/event_history/${eventToUpdate.id}`,\n          headers: {\n            'Authorization': `Bearer ${credentials.directusToken}`,\n            'Content-Type': 'application/json'\n          },\n          data: directusData\n        });\n        \n        log('Evento atualizado no Directus com sucesso');\n      } catch (directusError) {\n        log('Erro ao atualizar evento no Directus', directusError.message);\n        // Continuar mesmo com erro no Directus\n      }\n    }\n    \n    // Formatar resultado - retornando no fuso hor√°rio local\n    const formattedStartTime = startTime.format();\n    const formattedEndTime = endTime.format();\n    \n    return {\n      success: true,\n      message: \"Evento atualizado com sucesso\",\n      eventId: eventToUpdate.event_id,\n      eventLink: response.data.htmlLink,\n      startTime: formattedStartTime,\n      endTime: formattedEndTime,\n      title: updatedEvent.summary,\n      description: updatedEvent.description\n    };\n    \n  } catch (error) {\n    log('Erro ao atualizar evento', error.message);\n    \n    // Verificar se o erro √© espec√≠fico de conflito de agendamento\n    if (error.errorType === \"scheduling_conflict\") {\n      return {\n        success: false,\n        message: error.message,\n        errorType: error.errorType,\n        conflictingEvents: error.conflictingEvents\n      };\n    }\n    \n    throw { \n      message: `Erro ao atualizar evento: ${error.message}`, \n      errorType: \"update_failed\" \n    };\n  }\n}\n\nasync function deleteEvent(token) {\n  log('Iniciando processo de cancelamento de agendamento');\n  \n  try {\n    const calendarId = inputData.calendarId || 'primary';\n    log('Verificando eventos no calend√°rio:', calendarId);\n    \n    // Verificar se temos a data e hora para cancelamento\n    if (!inputData.dateTime) {\n      throw new Error(\"Para cancelar um evento, forne√ßa a data e hora do agendamento.\");\n    }\n    \n    // Converter a data/hora de entrada para o fuso hor√°rio local\n    const inputDateTime = formatFromUTC(inputData.dateTime);\n    const inputDateTimeComponents = extractDateTimeComponents(inputDateTime.format());\n    \n    log('Data alvo para cancelamento:', inputDateTimeComponents.date);\n    log('Hora alvo para cancelamento:', inputDateTimeComponents.time);\n    \n    // Verificar se h√° eventos dispon√≠veis\n    if (!eventData || !Array.isArray(eventData) || eventData.length === 0) {\n      log('Nenhum evento encontrado para este calend√°rio');\n      return {\n        message: \"Nenhum agendamento encontrado para cancelar. N√£o h√° eventos marcados neste calend√°rio.\",\n        success: false,\n        events: []\n      };\n    }\n    \n    // Filtrar apenas eventos do calend√°rio especificado\n    const calendarEvents = eventData.filter(event => event.calendar_id === calendarId);\n    \n    if (calendarEvents.length === 0) {\n      log('Nenhum evento encontrado para este calend√°rio espec√≠fico');\n      return {\n        message: \"Nenhum agendamento encontrado para este calend√°rio.\",\n        success: false,\n        events: []\n      };\n    }\n    \n    log('Eventos dispon√≠veis no calend√°rio:', calendarEvents.length);\n    \n    // Buscar eventos que correspondam √† data/hora especificada\n    const matchingEvents = calendarEvents.filter(event => {\n      // Converter data/hora do evento do Directus para o fuso hor√°rio local\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n      \n      // Verificar correspond√™ncia direta de data, hora e calend√°rio\n      const dateMatches = eventDateTimeComponents.date === inputDateTimeComponents.date;\n      const timeMatches = eventDateTimeComponents.time === inputDateTimeComponents.time;\n      \n      log(`Analisando evento ${event.id}: data=${dateMatches} (${eventDateTimeComponents.date}), hora=${timeMatches} (${eventDateTimeComponents.time})`);\n      \n      return dateMatches && timeMatches;\n    });\n    \n    log('Eventos correspondentes encontrados:', matchingEvents.length);\n    \n    if (matchingEvents.length === 0) {\n      // Se n√£o encontrar eventos correspondentes, retornar todos os eventos dispon√≠veis\n      const allEvents = calendarEvents.map(event => {\n        // Converter data/hora do evento do Directus para o fuso hor√°rio local\n        const eventDateTime = formatFromUTC(event.date);\n        const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n        \n        return {\n          id: event.id,\n          title: event.title,\n          description: event.description || '',\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          dateTime: eventDateTime.format(),\n          eventId: event.event_id\n        };\n      });\n      \n      // Ordenar por data/hora\n      allEvents.sort((a, b) => {\n        if (a.date !== b.date) return a.date.localeCompare(b.date);\n        return a.time.localeCompare(b.time);\n      });\n      \n      log('Nenhum evento correspondente, retornando lista de eventos dispon√≠veis:', allEvents.length);\n      \n      return {\n        message: `Nenhum agendamento encontrado para a data/hora especificada. Voc√™ possui ${allEvents.length} agendamentos neste calend√°rio.`,\n        success: false,\n        events: allEvents\n      };\n    }\n    \n    // Processar o cancelamento de cada evento correspondente\n    const results = [];\n    for (const event of matchingEvents) {\n      // Converter data/hora do evento do Directus para o fuso hor√°rio local para logging\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n      \n      log('Cancelando evento:', { \n        id: event.id, \n        eventId: event.event_id, \n        title: event.title, \n        date: eventDateTimeComponents.date,\n        time: eventDateTimeComponents.time\n      });\n      \n      try {\n        // Fun√ß√£o para executar a exclus√£o com tratamento de token\n        const deleteFromGoogleCalendar = async (currentToken) => {\n          const client = createClient(currentToken);\n          return await client.delete(\n            `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(event.event_id)}`\n          );\n        };\n        \n        // Usar executeWithToken para garantir que o token seja renovado se necess√°rio\n        await executeWithToken(deleteFromGoogleCalendar);\n        \n        log('Evento cancelado no Google Calendar com sucesso');\n        \n        // 2. Se o evento foi cancelado com sucesso no Google, remover do Directus\n        if (CONFIG.saveToDirectus) {\n          try {\n            const directusClient = createClient(credentials.directusToken);\n            await directusClient.delete(\n              `http://${credentials.directusService}:8055/items/event_history/${event.id}`\n            );\n            log('Evento removido do Directus com sucesso');\n          } catch (directusError) {\n            log('Erro ao remover evento do Directus', directusError.message);\n            // Continuar mesmo com erro no Directus\n          }\n        }\n        \n        // Adicionar ao resultado\n        results.push({\n          eventId: event.event_id,\n          title: event.title,\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          status: 'canceled'\n        });\n      } catch (error) {\n        log('Erro ao cancelar evento no Google Calendar', error.message);\n        \n        results.push({\n          eventId: event.event_id,\n          title: event.title,\n          date: eventDateTimeComponents.date,\n          time: eventDateTimeComponents.time,\n          status: 'error',\n          error: error.message\n        });\n      }\n    }\n    \n    // Determinar mensagem baseada nos resultados\n    const successCount = results.filter(r => r.status === 'canceled').length;\n    const errorCount = results.filter(r => r.status === 'error').length;\n    \n    let message;\n    if (successCount > 0 && errorCount === 0) {\n      message = `${successCount} agendamento(s) cancelado(s) com sucesso.`;\n    } else if (successCount > 0 && errorCount > 0) {\n      message = `${successCount} agendamento(s) cancelado(s) com sucesso. ${errorCount} apresentaram erro.`;\n    } else {\n      message = `Falha ao cancelar os agendamentos. Todos os ${errorCount} eventos apresentaram erro.`;\n    }\n    \n    return {\n      message,\n      success: successCount > 0,\n      canceledCount: successCount,\n      errorCount,\n      results\n    };\n    \n  } catch (error) {\n    log('Erro ao processar cancelamento de evento', error.message);\n    \n    // Se o erro for \"Nenhum evento encontrado\", tentar retornar a lista de eventos\n    if (error.message.includes(\"Nenhum evento encontrado\")) {\n      try {\n        const calendarId = inputData.calendarId || 'primary';\n        const calendarEvents = eventData.filter(event => event.session_id === calendarId);\n        \n        if (calendarEvents && calendarEvents.length > 0) {\n          const allEvents = calendarEvents.map(event => {\n            // Converter data/hora do evento do Directus para o fuso hor√°rio local\n            const eventDateTime = formatFromUTC(event.date);\n            const eventDateTimeComponents = extractDateTimeComponents(eventDateTime.format());\n            \n            return {\n              id: event.id,\n              title: event.title,\n              description: event.description || '',\n              date: eventDateTimeComponents.date,\n              time: eventDateTimeComponents.time,\n              eventId: event.event_id\n            };\n          }).sort((a, b) => {\n            if (a.date !== b.date) return a.date.localeCompare(b.date);\n            return a.time.localeCompare(b.time);\n          });\n          \n          return {\n            message: `Nenhum agendamento encontrado na data e hora especificadas. Voc√™ possui ${allEvents.length} agendamentos neste calend√°rio.`,\n            success: false,\n            events: allEvents\n          };\n        }\n      } catch (secondError) {\n        log('Erro ao tentar recuperar lista de eventos', secondError.message);\n      }\n    }\n    \n    throw { message: error.message, errorType: \"general_error\" };\n  }\n}\n\nasync function queryEvents(token) {\n  log('Consultando eventos do calend√°rio');\n  \n  try {\n    const calendarId = inputData.calendarId || 'primary';\n    log('ID do calend√°rio para consulta:', calendarId);\n\n    // Verificar se h√° eventos dispon√≠veis\n    if (!eventData || !Array.isArray(eventData) || eventData.length === 0) {\n      log('Nenhum evento encontrado para este calend√°rio');\n      return {\n        message: \"Nenhum evento encontrado para este calend√°rio\",\n        eventsToday: [],\n        upcomingEvents: []\n      };\n    }\n    \n    // Obter a data atual no fuso hor√°rio local\n    const today = dayjs().tz(CONFIG.timezone).startOf('day');\n    log('Data de refer√™ncia para consulta:', today.format('YYYY-MM-DD'));\n    \n    // Separar eventos de hoje e pr√≥ximos eventos\n    const eventsToday = [];\n    const upcomingEvents = [];\n    \n    eventData.forEach(event => {\n      // Converter a data do evento de UTC para o fuso hor√°rio local\n      const eventDateTime = formatFromUTC(event.date);\n      const eventDate = eventDateTime.startOf('day');\n      \n      // Extrair componentes para criar objeto de resultado\n      const components = extractDateTimeComponents(eventDateTime.format());\n      \n      // Criar objeto base para o evento\n      const eventObject = {\n        id: event.id,\n        title: event.title,\n        description: event.description || '',\n        date: components.date,\n        time: components.time,\n        formattedDate: components.formattedDate,\n        dateTime: eventDateTime.format(),\n        eventId: event.event_id\n      };\n      \n      // Verificar se o evento √© de hoje\n      if (eventDate.isSame(today, 'day')) {\n        eventsToday.push(eventObject);\n      } \n      // Verificar se o evento √© futuro (ap√≥s hoje)\n      else if (eventDate.isAfter(today, 'day')) {\n        upcomingEvents.push(eventObject);\n      }\n    });\n    \n    // Ordenar eventos por data/hora\n    eventsToday.sort((a, b) => dayjs(a.dateTime).diff(dayjs(b.dateTime)));\n    upcomingEvents.sort((a, b) => dayjs(a.dateTime).diff(dayjs(b.dateTime)));\n    \n    log('Eventos encontrados para hoje:', eventsToday.length);\n    log('Eventos futuros encontrados:', upcomingEvents.length);\n    \n    return {\n      message: `Encontrados ${eventsToday.length} eventos para hoje e ${upcomingEvents.length} eventos futuros`,\n      eventsToday,\n      upcomingEvents\n    };\n  } catch (error) {\n    log('Erro ao consultar eventos', error.message);\n    throw new Error(`Erro ao consultar eventos: ${error.message}`);\n  }\n}\n\nasync function queryAvailableSlots(token) {\n  log('Iniciando busca por slots dispon√≠veis');\n  \n  try {\n    // Definir timezone padr√£o para todas as opera√ß√µes\n    dayjs.tz.setDefault(CONFIG.timezone);\n    \n    const calendarId = inputData.calendarId || 'primary';\n    log('Calend√°rio selecionado:', calendarId);\n    \n    // Determinar a data alvo - sempre convertendo para o timezone local\n    let targetDate;\n    \n    if (inputData.dateTime) {\n      // Se tiver dateTime (como usado em createEvent), extrair a data\n      targetDate = formatFromUTC(inputData.dateTime).startOf('day');\n      log('Usando data de dateTime:', targetDate.format('YYYY-MM-DD'));\n    } else if (inputData.date) {\n      // Se tiver date espec√≠fico\n      targetDate = formatFromUTC(inputData.date).startOf('day');\n      log('Usando data fornecida:', targetDate.format('YYYY-MM-DD'));\n    } else {\n      // Default para a data atual em fuso hor√°rio local\n      targetDate = dayjs().tz(CONFIG.timezone).startOf('day');\n      log('Nenhuma data fornecida, usando data atual:', targetDate.format('YYYY-MM-DD'));\n    }\n    \n    const targetDateStr = targetDate.format('YYYY-MM-DD');\n    \n    // Par√¢metros de hor√°rio comercial (padr√µes caso n√£o sejam fornecidos)\n    const startHour = CONFIG.startHour;  \n    const endHour = CONFIG.endHour;\n    const slotDuration = inputData.slotDuration || CONFIG.defaultDuration; // Dura√ß√£o em minutos (padr√£o: 60 min)\n    \n    log('Hor√°rio comercial configurado:', `${startHour}:00 - ${endHour}:00, slots de ${slotDuration} minutos`);\n    log('Data alvo para consulta:', targetDateStr);\n    \n    // Fun√ß√£o para buscar eventos no Google Calendar para a data selecionada\n    const fetchGoogleCalendarEvents = async (authToken) => {\n      const client = createClient(authToken);\n      \n      // Definir in√≠cio e fim do dia na timezone configurada (Bras√≠lia)\n      const startOfDay = targetDate;\n      const endOfDay = targetDate.add(1, 'day');\n      \n      // Converter para ISO para a API do Google\n      const timeMin = startOfDay.toISOString();\n      const timeMax = endOfDay.toISOString();\n      \n      log('Buscando eventos no per√≠odo (ISO):', { timeMin, timeMax });\n      \n      const response = await client.get(\n        `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n        {\n          timeMin,\n          timeMax,\n          singleEvents: true,\n          orderBy: 'startTime'\n        }\n      );\n      \n      return response.data.items || [];\n    };\n    \n    // Buscar eventos no Google Calendar\n    const googleEvents = await executeWithToken(fetchGoogleCalendarEvents);\n    log('Eventos encontrados no Google Calendar:', googleEvents.length);\n    \n    // Combinar com os eventos do Directus (se dispon√≠veis)\n    let allEvents = [];\n    \n    // Adicionar eventos do Google Calendar, convertendo para timezone local\n    if(googleEvents.length)\n      googleEvents.forEach(event => {\n        if (event.status !== 'cancelled') {\n          // Converter datas para o fuso hor√°rio local\n          const startTime = event.start.dateTime \n            ? formatFromUTC(event.start.dateTime)\n            : formatFromUTC(event.start.date).startOf('day');\n            \n          const endTime = event.end.dateTime \n            ? formatFromUTC(event.end.dateTime)\n            : formatFromUTC(event.end.date).endOf('day');\n          \n          log(`Evento do Google: ${event.summary}, In√≠cio: ${startTime.format('YYYY-MM-DD HH:mm')}, Fim: ${endTime.format('YYYY-MM-DD HH:mm')}`);\n          \n          allEvents.push({\n            id: event.id,\n            title: event.summary || 'Sem t√≠tulo',\n            start: startTime,\n            end: endTime,\n            source: 'google'\n          });\n        }\n      });\n    \n    // Adicionar eventos do Directus (se existirem), convertendo de UTC para o fuso hor√°rio local\n    if (eventData && Array.isArray(eventData)) {\n      const directusEvents = eventData.filter(event => {\n        // Converter para o fuso hor√°rio local para compara√ß√£o\n        const eventDateTime = formatFromUTC(event.date);\n        return eventDateTime.format('YYYY-MM-DD') === targetDateStr && \n               event.session_id === calendarId;\n      });\n      \n      directusEvents.forEach(event => {\n        // Converter de UTC para o fuso hor√°rio local\n        const eventStart = formatFromUTC(event.date);\n        const eventEnd = eventStart.add(slotDuration, 'minutes');\n        \n        log(`Evento do Directus: ${event.title}, In√≠cio: ${eventStart.format('YYYY-MM-DD HH:mm')}, Fim: ${eventEnd.format('YYYY-MM-DD HH:mm')}`);\n        \n        // Verificar se j√° existe um evento do Google com o mesmo ID\n        const exists = allEvents.some(e => e.id === event.event_id && e.source === 'google');\n        \n        if (!exists) {\n          allEvents.push({\n            id: event.id,\n            title: event.title || 'Sem t√≠tulo',\n            start: eventStart,\n            end: eventEnd,\n            source: 'directus'\n          });\n        }\n      });\n    }\n    \n    log('Total de eventos ap√≥s combina√ß√£o:', allEvents.length);\n    \n    // Gerar todos os slots poss√≠veis para o hor√°rio comercial\n    const availableSlots = [];\n    const busySlots = [];\n    \n    // Criar hor√°rio comercial no fuso hor√°rio local\n    const businessStart = targetDate.hour(startHour).minute(0).second(0);\n    const businessEnd = targetDate.hour(endHour).minute(0).second(0);\n    \n    log(`Hor√°rio comercial: ${businessStart.format('YYYY-MM-DD HH:mm')} at√© ${businessEnd.format('YYYY-MM-DD HH:mm')}`);\n    \n    // Formatar data para exibi√ß√£o no padr√£o brasileiro\n    const formattedDate = targetDate.format('DD/MM/YYYY');\n    \n    // Iterar sobre os slots do hor√°rio comercial\n    let currentSlotStart = businessStart;\n    \n    while (currentSlotStart.isBefore(businessEnd)) {\n      const currentSlotEnd = currentSlotStart.add(slotDuration, 'minutes');\n      \n      log(`Analisando slot: ${currentSlotStart.format('HH:mm')} - ${currentSlotEnd.format('HH:mm')}`);\n      \n      // Verificar se este slot est√° ocupado por algum evento\n      const isSlotBusy = allEvents.some(event => {\n        // Verificar sobreposi√ß√£o com o hor√°rio no fuso hor√°rio local\n        const eventStart = event.start;\n        const eventEnd = event.end;\n        \n        // Log de debug para verificar compara√ß√£o de hor√°rios\n        log(`  Comparando com evento: ${event.title}`);\n        log(`    Evento: ${eventStart.format('HH:mm')} - ${eventEnd.format('HH:mm')}`);\n        \n        // Verificar sobreposi√ß√£o utilizando m√©todos b√°sicos do dayjs\n        const startsInSlot = eventStart.isAfter(currentSlotStart) && eventStart.isBefore(currentSlotEnd);\n        const endsInSlot = eventEnd.isAfter(currentSlotStart) && eventEnd.isBefore(currentSlotEnd);\n        const coversSlot = eventStart.isSameOrBefore(currentSlotStart) && eventEnd.isSameOrAfter(currentSlotEnd);\n        const exactMatchStart = eventStart.isSame(currentSlotStart);\n        const exactMatchEnd = eventEnd.isSame(currentSlotEnd);\n        \n        // Verifica√ß√£o combinada\n        const overlaps = startsInSlot || endsInSlot || coversSlot || exactMatchStart || exactMatchEnd;\n        \n        if (overlaps) {\n          log(`    SOBREPOSI√á√ÉO ENCONTRADA`);\n        }\n        \n        return overlaps;\n      });\n      \n      const slotInfo = {\n        start: currentSlotStart.format('HH:mm'),\n        end: currentSlotEnd.format('HH:mm'),\n        startISO: currentSlotStart.format(),\n        endISO: currentSlotEnd.format(),\n        formattedDateTime: `${formattedDate} ${currentSlotStart.format('HH:mm')}` // Formato brasileiro\n      };\n      \n      if (isSlotBusy) {\n        busySlots.push(slotInfo);\n        log(`Slot ocupado: ${slotInfo.start} - ${slotInfo.end}`);\n      } else {\n        availableSlots.push(slotInfo);\n        log(`Slot dispon√≠vel: ${slotInfo.start} - ${slotInfo.end}`);\n      }\n      \n      // Avan√ßar para o pr√≥ximo slot\n      currentSlotStart = dayjs(currentSlotEnd);  // Criar nova inst√¢ncia para evitar problemas de refer√™ncia\n    }\n    \n    log('Slots dispon√≠veis encontrados:', availableSlots.length);\n    log('Slots ocupados encontrados:', busySlots.length);\n    \n    // Informa√ß√µes do dia para o resultado\n    const dayInfo = {\n      date: targetDateStr,\n      formattedDate: formattedDate, // Formato brasileiro DD/MM/YYYY\n      dayOfWeek: targetDate.format('dddd'),\n      isToday: targetDate.isSame(dayjs().tz(CONFIG.timezone), 'day'),\n      businessHours: `${startHour}:00 - ${endHour}:00`\n    };\n    \n    return {\n      success: true,\n      message: `Encontrados ${availableSlots.length} hor√°rios dispon√≠veis para ${formattedDate}`,\n      day: dayInfo,\n      availableSlots,\n      busySlots,\n      slotDuration\n    };\n    \n  } catch (error) {\n    log('Erro ao consultar slots dispon√≠veis', error.message);\n    if (error.response) {\n      log('Detalhes do erro da API', {\n        status: error.response.status,\n        data: error.response.data\n      });\n    } else if (error.stack) {\n      log('Stack trace do erro', error.stack);\n    }\n    \n    throw { \n      message: `Erro ao consultar hor√°rios dispon√≠veis: ${error.message}`, \n      errorType: \"general_error\" \n    };\n  }\n}\n\n// =========================================================\n// FUN√á√ÄO PRINCIPAL\n// =========================================================\n\nasync function main() {\n  try {\n    const operations = {\n      'create': createEvent,\n      'update': updateEvent,\n      'delete': deleteEvent,\n      'query': queryEvents,\n      'query-slots': queryAvailableSlots\n    };\n    \n    if (!inputData.operation || !operations[inputData.operation]) {\n      throw new Error(\"Opera√ß√£o inv√°lida. Use 'create', 'update', 'delete', 'query' ou 'query_slots'\");\n    }\n    \n    const operation = inputData.operation;\n    const result = await executeWithToken(operations[operation]);\n    \n    return {\n      success: true,\n      ...result,\n      logs\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error.message || \"Erro desconhecido\",\n      errorType: error.errorType || \"general_error\",\n      logs\n    };\n  }\n}\n\n// Iniciar execu√ß√£o\nreturn [{\n  json: await main()\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        940
      ],
      "id": "dd167075-48c7-406b-82bd-7c213443c3b4",
      "name": "Calendar Manager"
    },
    {
      "parameters": {
        "name": "clickup",
        "description": "Ferramenta para gerenciar tarefas no ClickUp. Permite criar, listar, atualizar ou remover tarefas. Para criar, forne√ßa pelo menos o t√≠tulo. Para atualizar ou remover, voc√™ precisa fornecer o ID da tarefa. Para listar, voc√™ pode aplicar filtros opcionais.",
        "jsCode": "const workspaceId = '9011917991';\nconst listId = '901109860036';\nconst apiKey = 'pk_44163283_ZIFREHZQNJWKZ5YSD0XVV45B272AOARG';\nconst https = require('https');\n\nconst logs = [];\n\nfunction log(message) {\n  logs.push({ time: new Date().toISOString(), message });\n}\n\nfunction request(path, method, body = null) {\n  log(`Requisi√ß√£o: ${method} ${path}`);\n  \n  return new Promise((resolve, reject) => {\n    const options = {\n      hostname: 'api.clickup.com',\n      path,\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': apiKey\n      }\n    };\n    \n    const req = https.request(options, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        try {\n          log(`Resposta: status ${res.statusCode}`);\n          \n          // Tratamento de respostas vazias (comum em DELETEs)\n          if (!data || data.trim() === '') {\n            return res.statusCode < 300 \n              ? resolve({ success: true }) \n              : reject({ \n                  success: false, \n                  message: `Erro: ${res.statusMessage}`, \n                  statusCode: res.statusCode \n                });\n          }\n          \n          const responseData = JSON.parse(data);\n          \n          if (res.statusCode < 300) {\n            resolve(responseData);\n          } else {\n            reject({\n              success: false,\n              message: `Erro: ${responseData.err || res.statusMessage}`,\n              statusCode: res.statusCode\n            });\n          }\n        } catch (error) {\n          log(`Erro ao processar resposta: ${error.message}`);\n          reject({\n            success: false,\n            message: `Erro ao processar resposta: ${error.message}`,\n            data\n          });\n        }\n      });\n    });\n\n    req.on('error', (error) => {\n      log(`Erro na requisi√ß√£o: ${error.message}`);\n      reject({ success: false, message: `Erro na requisi√ß√£o: ${error.message}` });\n    });\n\n    if (body) {\n      const data = typeof body === 'string' ? body : JSON.stringify(body);\n      log(`Enviando dados: ${data.substring(0, 100)}${data.length > 100 ? '...' : ''}`);\n      req.write(data);\n    }\n    \n    req.end();\n  });\n}\n\nconst operations = {\n  async list(query) {\n    log('Opera√ß√£o: listar tarefas');\n    \n    try {\n      // Construir par√¢metros de consulta\n      const params = [];\n      \n      if (query.status) params.push(`statuses[]=${encodeURIComponent(query.status)}`);\n      if (query.assignee) params.push(`assignees[]=${encodeURIComponent(query.assignee)}`);\n      if (query.due_date_gt) params.push(`due_date_gt=${encodeURIComponent(query.due_date_gt)}`);\n      if (query.due_date_lt) params.push(`due_date_lt=${encodeURIComponent(query.due_date_lt)}`);\n      \n      // Pagina√ß√£o\n      params.push(`page=${query.page || 0}`);\n      const limit = Math.min(query.limit || 20, 100);\n      params.push(`limit=${limit}`);\n      \n      log(`Par√¢metros: ${params.join('&')}`);\n      \n      // Fazer requisi√ß√£o\n      const data = await request(\n        `/api/v2/list/${listId}/task?${params.join('&')}`, \n        'GET'\n      );\n      \n      log(`Tarefas encontradas: ${data.tasks.length}`);\n      \n      return {\n        success: true,\n        tasks: data.tasks,\n        total_count: data.tasks.length,\n        has_more: data.tasks.length === limit\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n\n  async create(query) {\n    log('Opera√ß√£o: criar tarefa');\n    \n    if (!query.title) {\n      log('Erro: T√≠tulo da tarefa n√£o fornecido');\n      return { success: false, message: \"T√≠tulo da tarefa √© obrigat√≥rio para cria√ß√£o\" };\n    }\n    \n    const body = {\n      name: query.title,\n      description: query.description || '',\n      due_date: query.due_date || null,\n      priority: query.priority || 3,\n      assignees: query.assignees || []\n    };\n    \n    try {\n      log(`Criando tarefa: \"${query.title}\"`);\n      const data = await request(`/api/v2/list/${listId}/task`, 'POST', body);\n      log(`Tarefa criada com sucesso, ID: ${data.id}`);\n      \n      return {\n        success: true,\n        message: \"Tarefa criada com sucesso\",\n        taskId: data.id,\n        taskUrl: data.url\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n  \n  async delete(query) {\n    log('Opera√ß√£o: remover tarefa');\n    \n    if (!query.task_id) {\n      log('Erro: ID da tarefa n√£o fornecido');\n      return { success: false, message: \"ID da tarefa √© obrigat√≥rio para remo√ß√£o\" };\n    }\n    \n    try {\n      log(`Removendo tarefa: ${query.task_id}`);\n      await request(`/api/v2/task/${query.task_id}`, 'DELETE');\n      log('Tarefa removida com sucesso');\n      \n      return {\n        success: true,\n        message: \"Tarefa removida com sucesso\",\n        taskId: query.task_id\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  },\n  \n  async update(query) {\n    log('Opera√ß√£o: atualizar tarefa');\n    \n    if (!query.task_id) {\n      log('Erro: ID da tarefa n√£o fornecido');\n      return { success: false, message: \"ID da tarefa √© obrigat√≥rio para atualiza√ß√£o\" };\n    }\n    \n    // Mapear campos\n    const fields = {\n      title: 'name',\n      description: 'description',\n      due_date: 'due_date',\n      priority: 'priority',\n      status: 'status',\n      assignees: 'assignees'\n    };\n    \n    const body = {};\n    \n    // Filtrar campos fornecidos\n    Object.entries(fields).forEach(([src, dest]) => {\n      if (query[src] !== undefined) body[dest] = query[src];\n    });\n    \n    if (Object.keys(body).length === 0) {\n      log('Erro: Nenhum campo fornecido para atualiza√ß√£o');\n      return { success: false, message: \"Nenhum campo fornecido para atualiza√ß√£o\" };\n    }\n    \n    try {\n      log(`Atualizando tarefa: ${query.task_id}`);\n      await request(`/api/v2/task/${query.task_id}`, 'PUT', body);\n      log('Tarefa atualizada com sucesso');\n      \n      return {\n        success: true,\n        message: \"Tarefa atualizada com sucesso\",\n        taskId: query.task_id\n      };\n    } catch (error) {\n      log(`Erro: ${error.message || JSON.stringify(error)}`);\n      return error;\n    }\n  }\n};\n\ntry {\n  log(`Iniciando processamento: ${JSON.stringify(query)}`);\n  \n  const operation = query.operation || 'create';\n  \n  const result = await operations[operation](query);\n  \n  return JSON.stringify({\n    success: true,\n    ...result,\n    logs: logs\n  });\n} catch (error) {\n  log(`Erro n√£o tratado: ${error.message || JSON.stringify(error)}`);\n  return JSON.stringify({ \n    success: false, \n    message: `Erro n√£o tratado: ${error.message || 'Erro desconhecido'}`,\n    logs \n  });\n}",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"operation\": {\n      \"type\": \"string\",\n      \"description\": \"Opera√ß√£o a ser realizada: criar, listar, atualizar ou remover tarefas\",\n      \"enum\": [\"create\", \"list\", \"update\", \"delete\"],\n      \"default\": \"create\"\n    },\n    \"task_id\": {\n      \"type\": \"string\",\n      \"description\": \"ID da tarefa (obrigat√≥rio para atualizar ou remover)\"\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"description\": \"T√≠tulo da tarefa (obrigat√≥rio para criar, opcional para atualizar)\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"Descri√ß√£o detalhada da tarefa (opcional)\"\n    },\n    \"due_date\": {\n      \"type\": \"string\",\n      \"description\": \"Data de vencimento no formato timestamp ou ISO 8601 (opcional)\"\n    },\n    \"priority\": {\n      \"type\": \"integer\",\n      \"description\": \"Prioridade da tarefa (1: Urgente, 2: Alta, 3: Normal, 4: Baixa) (opcional)\",\n      \"enum\": [1, 2, 3, 4]\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"description\": \"Status da tarefa (para atualizar ou filtrar na listagem)\"\n    },\n    \"assignees\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"integer\"\n      },\n      \"description\": \"Lista de IDs dos usu√°rios atribu√≠dos √† tarefa (opcional)\"\n    },\n    \"assignee\": {\n      \"type\": \"integer\",\n      \"description\": \"Filtrar por ID do usu√°rio atribu√≠do (para listar)\"\n    },\n    \"due_date_gt\": {\n      \"type\": \"string\",\n      \"description\": \"Filtrar tarefas com data de vencimento posterior (para listar)\"\n    },\n    \"due_date_lt\": {\n      \"type\": \"string\",\n      \"description\": \"Filtrar tarefas com data de vencimento anterior (para listar)\"\n    },\n    \"page\": {\n      \"type\": \"integer\",\n      \"description\": \"N√∫mero da p√°gina para pagina√ß√£o (para listar)\",\n      \"default\": 0\n    },\n    \"limit\": {\n      \"type\": \"integer\",\n      \"description\": \"N√∫mero de tarefas por p√°gina (m√°ximo 100, para listar)\",\n      \"default\": 20\n    }\n  },\n  \"required\": [\"operation\"],\n  \"dependencies\": {\n    \"operation\": {\n      \"oneOf\": [\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"create\"]\n            }\n          },\n          \"required\": [\"title\"]\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"list\"]\n            }\n          }\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"update\"]\n            }\n          },\n          \"required\": [\"task_id\"]\n        },\n        {\n          \"properties\": {\n            \"operation\": {\n              \"enum\": [\"delete\"]\n            }\n          },\n          \"required\": [\"task_id\"]\n        }\n      ]\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1620,
        1580
      ],
      "id": "6a06dfcc-eb35-41cb-b35b-313783de7027",
      "name": "Clickup"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -940,
        2460
      ],
      "id": "828e3074-8af6-4072-8085-b0e91dc613f6",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "3raLgi1Pp00Yk6mH",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        920,
        1580
      ],
      "id": "fbae12cb-887e-4604-ad27-2fb16a50746e",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "3raLgi1Pp00Yk6mH",
          "name": "OpenAi account"
        }
      }
    }
  ],
  "connections": {
    "Memory": {
      "ai_memory": [
        [
          {
            "node": "Main Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Main Agent": {
      "main": [
        [
          {
            "node": "No Operation 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add to List": {
      "main": [
        [
          {
            "node": "Get List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get List": {
      "main": [
        [
          {
            "node": "Switch 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON": {
      "main": [
        [
          {
            "node": "Split Itens",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop": {
      "main": [
        [
          {
            "node": "Execute Core",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Itens": {
      "main": [
        [
          {
            "node": "Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Media": {
      "main": [
        [
          {
            "node": "Switch 02",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 02": {
      "main": [
        [
          {
            "node": "Transcription",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Convert PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset List": {
      "main": [
        [
          {
            "node": "Chatwoot Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Final List 2": {
      "main": [
        [
          {
            "node": "Switch 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Final List 1": {
      "main": [
        [
          {
            "node": "Parse JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cooldown": {
      "main": [
        [
          {
            "node": "Get List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation 2": {
      "main": [
        []
      ]
    },
    "Consumer": {
      "main": [
        [
          {
            "node": "Get Vars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 3": {
      "main": [
        [
          {
            "node": "No Operation ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Reset List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Input": {
      "main": [
        [
          {
            "node": "Main Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter": {
      "ai_languageModel": [
        []
      ]
    },
    "Get Vars": {
      "main": [
        [
          {
            "node": "Downtime",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert PDF": {
      "main": [
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transcription": {
      "main": [
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Core": {
      "main": [
        [
          {
            "node": "Get Final List 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear History": {
      "main": [
        [
          {
            "node": "Parse JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restart History": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Switch 2": {
      "main": [
        [
          {
            "node": "Download Media",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Keep Loop",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Switch 1": {
      "main": [
        [
          {
            "node": "No Operation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Final List 1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Cooldown",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 0": {
      "main": [
        [
          {
            "node": "Update History",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Add to List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Keep Loop": {
      "main": [
        [
          {
            "node": "Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update History": {
      "main": [
        [
          {
            "node": "Open Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chatwoot Output": {
      "main": [
        [
          {
            "node": "Add Register",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Register": {
      "main": [
        []
      ]
    },
    "Set Timer": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Knowledge Trigger": {
      "main": [
        [
          {
            "node": "Get Global Vars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Global Vars": {
      "main": [
        [
          {
            "node": "Process Docs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Docs": {
      "main": [
        []
      ]
    },
    "Vector Trigger": {
      "main": [
        [
          {
            "node": "Parse JSON 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON 2": {
      "main": [
        [
          {
            "node": "Split Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Vectors": {
      "main": [
        [
          {
            "node": "Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings": {
      "main": [
        [
          {
            "node": "Add Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Vectors": {
      "main": [
        []
      ]
    },
    "RAG Input": {
      "main": [
        [
          {
            "node": "Get History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retriever": {
      "ai_tool": [
        [
          {
            "node": "RAG Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter ": {
      "ai_languageModel": [
        []
      ]
    },
    "Mapping": {
      "main": [
        [
          {
            "node": "Switch 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation ": {
      "main": [
        [
          {
            "node": "Clear History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Downtime": {
      "main": [
        [
          {
            "node": "Mapping",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation 0": {
      "main": [
        [
          {
            "node": "Keep Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Trigger": {
      "main": [
        [
          {
            "node": "Get Dimensions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Dimensions": {
      "main": [
        [
          {
            "node": "Update Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG Agent": {
      "main": [
        [
          {
            "node": "No Operation 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get History": {
      "main": [
        [
          {
            "node": "RAG Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scheduling": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Scheduling Trigger": {
      "main": [
        [
          {
            "node": "Calendar Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clickup": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "RAG Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Main Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {},
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "2b8d7a95-2cf6-40a7-a152-881c09ad83b6",
  "triggerCount": 7,
  "tags": []
}